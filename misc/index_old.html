<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Art-AI Renderer - Selective Resolution</title>

<style>
body { font-family: Arial, sans-serif; max-width: 900px; margin: 20px auto; padding: 0 20px; }
.section { margin: 20px 0; }
h3 { margin: 10px 0; font-size: 16px; }
input[type="file"] { margin: 10px 0; }
.radio-group label { display: block; margin: 5px 0; }
button { padding: 8px 16px; margin: 5px; cursor: pointer; }
button.active { background: #4CAF50; color: white; }
.slider-container { margin: 15px 0; }
#slider, #colorGroupSlider { width: 100%; }
canvas { border: 2px solid #ccc; margin-top: 10px; display: block; cursor: crosshair; }
canvas.drawing { cursor: crosshair; }
.info { color: #666; font-size: 14px; }
.modal { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 1000; }
.modal-content { background: white; margin: 10% auto; padding: 20px; width: 500px; border-radius: 8px; max-height: 80vh; overflow-y: auto; }
.modal-content h3 { margin-top: 0; }
.modal-content textarea { width: 100%; height: 150px; font-family: monospace; font-size: 12px; }
.modal-buttons { margin-top: 10px; text-align: right; }
.color-palette { display: flex; flex-wrap: wrap; gap: 8px; margin: 15px 0; }
.color-chip { width: 80px; height: 80px; border-radius: 4px; cursor: move; border: 2px solid #333; display: flex; flex-direction: column; align-items: center; justify-content: center; font-size: 9px; color: white; text-shadow: 1px 1px 2px black; position: relative; box-shadow: 0 2px 4px rgba(0,0,0,0.2); }
.color-chip.dragging { opacity: 0.5; }
.color-chip:hover { border-color: #000; transform: scale(1.05); box-shadow: 0 4px 8px rgba(0,0,0,0.3); }
.color-chip .count { font-size: 8px; font-weight: bold; margin-top: 2px; background: rgba(0,0,0,0.7); padding: 2px 4px; border-radius: 3px; }
.color-chip .chip-number { background: rgba(0,0,0,0.7); padding: 2px 4px; border-radius: 3px; font-size: 9px; }
.color-chip .rgb-value { font-size: 7px; background: rgba(0,0,0,0.7); padding: 2px 3px; border-radius: 2px; margin-top: 2px; font-family: monospace; }
.frequency-info { margin: 10px 0; padding: 10px; background: #f5f5f5; border-radius: 4px; font-size: 13px; }
.region-box { position: absolute; border: 3px solid #FF5722; background: rgba(255, 87, 34, 0.2); pointer-events: none; }
.region-list { margin: 10px 0; padding: 10px; background: #f0f0f0; border-radius: 4px; }
.region-item { display: flex; justify-content: space-between; align-items: center; padding: 5px; margin: 3px 0; background: white; border-radius: 3px; }
.region-item button { padding: 4px 8px; font-size: 12px; }
.highlight { background: #fff3cd; padding: 5px; border-radius: 3px; }
/* Color Picker Styles */
.color-picker-panel { 
    margin: 15px 0; 
    padding: 15px; 
    background: #f8f9fa; 
    border-radius: 8px; 
    border: 2px solid #dee2e6;
    display: none;
}
.color-picker-panel.active { display: block; }
.color-picker-header { 
    display: flex; 
    justify-content: space-between; 
    align-items: center; 
    margin-bottom: 10px;
}
.color-picker-header h4 { margin: 0; font-size: 14px; }
.color-preview-box {
    width: 60px;
    height: 60px;
    border: 3px solid #333;
    border-radius: 8px;
    box-shadow: 0 2px 8px rgba(0,0,0,0.2);
}
.color-details {
    display: grid;
    grid-template-columns: repeat(2, 1fr);
    gap: 8px;
    margin-top: 10px;
}
.color-detail-item {
    background: white;
    padding: 8px 12px;
    border-radius: 4px;
    font-size: 13px;
    border: 1px solid #e0e0e0;
}
.color-detail-item label {
    font-weight: bold;
    color: #666;
    font-size: 11px;
    display: block;
    margin-bottom: 2px;
}
.color-detail-item span {
    font-family: monospace;
    font-size: 14px;
}
.shape-highlight {
    pointer-events: none;
}
canvas.picking { cursor: crosshair; }
#colorPickerBtn.active { background: #00BCD4; color: white; }

/* Color Matcher Styles */
.color-matcher-section {
    margin-top: 15px;
    padding-top: 15px;
    border-top: 1px dashed #dee2e6;
}
.color-matcher-section h5 {
    margin: 0 0 10px 0;
    font-size: 13px;
    color: #495057;
}
.color-matcher-input {
    width: 100%;
    height: 80px;
    font-family: monospace;
    font-size: 11px;
    padding: 8px;
    border: 1px solid #ced4da;
    border-radius: 4px;
    resize: vertical;
    margin-bottom: 8px;
}
.color-matcher-input:focus {
    outline: none;
    border-color: #00BCD4;
    box-shadow: 0 0 0 2px rgba(0, 188, 212, 0.15);
}
#matchColorsBtn {
    background: #673AB7;
    color: white;
    border: none;
    padding: 8px 16px;
    border-radius: 4px;
    cursor: pointer;
    font-size: 13px;
    width: 100%;
}
#matchColorsBtn:hover { background: #5E35B1; }
#matchColorsBtn:disabled { background: #ccc; cursor: not-allowed; }

.match-results {
    margin-top: 12px;
    max-height: 250px;
    overflow-y: auto;
}
.match-results-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 8px;
    font-size: 12px;
    color: #666;
}
.match-result-item {
    display: flex;
    align-items: center;
    gap: 10px;
    padding: 8px;
    background: white;
    border: 1px solid #e0e0e0;
    border-radius: 4px;
    margin-bottom: 6px;
    transition: border-color 0.2s;
}
.match-result-item:hover {
    border-color: #00BCD4;
}
.match-result-item.best-match {
    border: 2px solid #4CAF50;
    background: linear-gradient(135deg, rgba(76, 175, 80, 0.08) 0%, rgba(76, 175, 80, 0.02) 100%);
}
.match-color-swatch {
    width: 36px;
    height: 36px;
    border-radius: 4px;
    border: 1px solid #333;
    flex-shrink: 0;
}
.match-info {
    flex: 1;
    min-width: 0;
}
.match-hex {
    font-family: monospace;
    font-size: 12px;
    font-weight: 600;
}
.match-delta {
    font-size: 10px;
    color: #888;
}
.match-percentage {
    text-align: right;
}
.match-percentage-value {
    font-size: 18px;
    font-weight: bold;
}
.match-percentage-value.high { color: #4CAF50; }
.match-percentage-value.medium { color: #FF9800; }
.match-percentage-value.low { color: #f44336; }
.match-percentage-label {
    font-size: 9px;
    color: #888;
    text-transform: uppercase;
}
.best-badge {
    display: inline-block;
    background: #4CAF50;
    color: white;
    font-size: 9px;
    font-weight: bold;
    padding: 2px 6px;
    border-radius: 3px;
    margin-left: 6px;
    text-transform: uppercase;
}
.match-progress-bar {
    width: 100%;
    height: 4px;
    background: #e0e0e0;
    border-radius: 2px;
    margin-top: 4px;
    overflow: hidden;
}
.match-progress-fill {
    height: 100%;
    border-radius: 2px;
    transition: width 0.3s ease;
}
.match-progress-fill.high { background: #4CAF50; }
.match-progress-fill.medium { background: #FF9800; }
.match-progress-fill.low { background: #f44336; }
.match-error {
    background: #ffebee;
    border: 1px solid #ffcdd2;
    color: #c62828;
    padding: 10px;
    border-radius: 4px;
    font-size: 12px;
    text-align: center;
}
.match-empty {
    text-align: center;
    padding: 20px;
    color: #888;
    font-size: 12px;
}
.threshold-control {
    display: flex;
    align-items: center;
    gap: 8px;
    margin-bottom: 8px;
    font-size: 11px;
    color: #666;
}
.threshold-control input[type="range"] {
    flex: 1;
    height: 4px;
}
.threshold-control span {
    min-width: 35px;
    text-align: right;
    font-family: monospace;
}
/* Palette Preset Styles */
.palette-preset-section {
    margin: 15px 0;
    padding: 15px;
    background: #f8f9fa;
    border-radius: 8px;
    border: 2px solid #dee2e6;
}
.palette-preset-section h4 {
    margin: 0 0 10px 0;
    font-size: 14px;
    color: #495057;
}
.palette-preset-controls {
    display: flex;
    gap: 10px;
    align-items: center;
}
.palette-preset-controls select {
    flex: 1;
    padding: 8px 12px;
    border: 1px solid #ced4da;
    border-radius: 4px;
    font-size: 13px;
    background: white;
    cursor: pointer;
}
.palette-preset-controls select:focus {
    outline: none;
    border-color: #673AB7;
    box-shadow: 0 0 0 2px rgba(103, 58, 183, 0.15);
}
.palette-preset-controls button {
    background: #673AB7;
    color: white;
    border: none;
    padding: 8px 16px;
    border-radius: 4px;
    cursor: pointer;
    font-size: 13px;
}
.palette-preset-controls button:hover {
    background: #5E35B1;
}
.palette-preset-controls button:disabled {
    background: #ccc;
    cursor: not-allowed;
}

/* Unmix / Recipe Styles */
.unmix-section {
    margin-top: 15px;
    padding-top: 15px;
    border-top: 2px solid #4CAF50;
    background: linear-gradient(135deg, rgba(76, 175, 80, 0.05) 0%, rgba(76, 175, 80, 0.02) 100%);
    padding: 15px;
    border-radius: 0 0 8px 8px;
    margin: 0 -15px -15px -15px;
}
.unmix-section h5 {
    margin: 0 0 12px 0;
    font-size: 14px;
    color: #2E7D32;
    display: flex;
    align-items: center;
    gap: 8px;
}
.unmix-section h5::before {
    content: "üé®";
}
.unmix-controls {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 10px;
    margin-bottom: 12px;
}
.unmix-control-item {
    display: flex;
    flex-direction: column;
    gap: 4px;
}
.unmix-control-item label {
    font-size: 11px;
    color: #666;
    font-weight: 600;
}
.unmix-control-item input[type="number"] {
    padding: 6px 10px;
    border: 1px solid #ced4da;
    border-radius: 4px;
    font-size: 13px;
    width: 100%;
    box-sizing: border-box;
}
.unmix-control-item input[type="number"]:focus {
    outline: none;
    border-color: #4CAF50;
    box-shadow: 0 0 0 2px rgba(76, 175, 80, 0.15);
}
#getRecipeBtn {
    background: #4CAF50;
    color: white;
    border: none;
    padding: 10px 16px;
    border-radius: 4px;
    cursor: pointer;
    font-size: 13px;
    font-weight: 600;
    width: 100%;
    transition: background 0.2s;
}
#getRecipeBtn:hover { background: #43A047; }
#getRecipeBtn:disabled { background: #ccc; cursor: not-allowed; }

.recipe-results {
    margin-top: 12px;
}
.recipe-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 10px;
    padding-bottom: 8px;
    border-bottom: 1px solid #e0e0e0;
}
.recipe-header-left {
    display: flex;
    align-items: center;
    gap: 10px;
}
.recipe-target-swatch {
    width: 40px;
    height: 40px;
    border-radius: 4px;
    border: 2px solid #333;
}
.recipe-result-swatch {
    width: 40px;
    height: 40px;
    border-radius: 4px;
    border: 2px solid #333;
}
.recipe-arrow {
    font-size: 20px;
    color: #666;
}
.recipe-match-info {
    text-align: right;
}
.recipe-match-value {
    font-size: 24px;
    font-weight: bold;
}
.recipe-match-value.high { color: #4CAF50; }
.recipe-match-value.medium { color: #FF9800; }
.recipe-match-value.low { color: #f44336; }
.recipe-match-label {
    font-size: 10px;
    color: #888;
}
.recipe-method {
    font-size: 10px;
    color: #666;
    background: #f0f0f0;
    padding: 2px 6px;
    border-radius: 3px;
    margin-top: 2px;
}
.recipe-components {
    display: flex;
    flex-direction: column;
    gap: 8px;
}
.recipe-component {
    display: flex;
    align-items: center;
    gap: 10px;
    padding: 10px;
    background: white;
    border: 1px solid #e0e0e0;
    border-radius: 6px;
    transition: border-color 0.2s;
}
.recipe-component:hover {
    border-color: #4CAF50;
}
.recipe-component-swatch {
    width: 44px;
    height: 44px;
    border-radius: 4px;
    border: 2px solid #333;
    flex-shrink: 0;
}
.recipe-component-info {
    flex: 1;
    min-width: 0;
}
.recipe-component-name {
    font-weight: 600;
    font-size: 13px;
    color: #333;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}
.recipe-component-hex {
    font-family: monospace;
    font-size: 11px;
    color: #666;
}
.recipe-component-amount {
    text-align: right;
    flex-shrink: 0;
}
.recipe-component-parts {
    font-size: 20px;
    font-weight: bold;
    color: #333;
}
.recipe-component-parts-label {
    font-size: 10px;
    color: #888;
}
.recipe-component-percent {
    font-size: 12px;
    color: #4CAF50;
    font-weight: 600;
}
.recipe-total {
    margin-top: 10px;
    padding-top: 10px;
    border-top: 1px dashed #ccc;
    font-size: 12px;
    color: #666;
    text-align: center;
}
.recipe-empty {
    text-align: center;
    padding: 20px;
    color: #888;
    font-size: 12px;
}
.recipe-error {
    background: #ffebee;
    border: 1px solid #ffcdd2;
    color: #c62828;
    padding: 10px;
    border-radius: 4px;
    font-size: 12px;
    text-align: center;
}
</style>
<script type="application/json" id="colorsData">
{
    "Common Color Names & Values": [
        [255, 127, 80], [178, 34, 34], [34, 139, 34], [255, 215, 0], [124, 252, 0],
        [128, 0, 0], [25, 25, 112], [0, 0, 128], [128, 128, 0], [107, 142, 35],
        [205, 133, 63], [139, 69, 19], [46, 139, 87]
    ],
    "Artisan - Winsor & Newton": [
        [58, 22, 14], [50, 27, 15], [221, 63, 0], [171, 0, 5], [221, 63, 0],
        [229, 42, 0], [166, 0, 9], [255, 139, 0], [255, 194, 0], [255, 161, 0],
        [0, 97, 102], [0, 74, 91], [0, 39, 71], [21, 15, 17], [8, 8, 32],
        [27, 28, 28], [21, 21, 20], [239, 173, 0], [98, 4, 32], [74, 1, 16],
        [130, 0, 24], [28, 42, 10], [17, 12, 37], [0, 32, 24], [3, 26, 33],
        [15, 11, 11], [117, 70, 17], [37, 26, 20], [0, 53, 40], [187, 128, 18]
    ],
    "Artists Oil - Winsor & Newton": [
        [68, 2, 6], [255, 232, 0], [197, 0, 15], [82, 42, 31], [255, 222, 0],
        [204, 12, 22], [255, 164, 0], [255, 127, 15], [0, 41, 117], [46, 90, 76],
        [0, 99, 127], [78, 23, 80], [50, 61, 164], [168, 113, 37], [71, 74, 14],
        [144, 87, 0], [119, 85, 26], [33, 23, 57], [16, 15, 17], [26, 27, 27],
        [235, 215, 84], [39, 38, 39], [222, 156, 72], [47, 43, 32], [57, 95, 58],
        [84, 2, 17], [71, 16, 26], [68, 50, 73], [34, 24, 24], [18, 28, 41],
        [108, 8, 36], [144, 32, 40], [130, 83, 39], [64, 49, 35], [69, 53, 53],
        [213, 33, 22], [146, 75, 63], [38, 59, 47], [149, 66, 40], [233, 162, 0],
        [70, 21, 17], [62, 38, 126], [39, 27, 19], [127, 49, 29], [0, 62, 53],
        [0, 134, 84], [0, 50, 40], [0, 60, 33], [248, 65, 0], [129, 0, 24],
        [255, 204, 0], [255, 145, 0], [29, 23, 41], [151, 104, 47]
    ],
    "Createx Airbrush Colors": [
        [164, 129, 99], [130, 107, 92], [120, 90, 76], [100, 74, 66], [133, 94, 41],
        [119, 47, 47], [108, 45, 36], [61, 52, 50], [68, 57, 57], [55, 46, 59],
        [85, 43, 36], [36, 31, 42], [91, 55, 54], [78, 56, 47], [42, 36, 49],
        [71, 62, 62], [100, 79, 68], [53, 53, 63], [63, 58, 52], [114, 98, 98]
    ],
    "Sennelier": [
        [68, 47, 38], [50, 42, 33], [125, 80, 35], [95, 40, 20], [168, 110, 40],
        [235, 166, 51], [0, 90, 136], [36, 68, 131], [15, 12, 79], [22, 17, 54],
        [35, 41, 42], [56, 55, 68], [66, 35, 26], [251, 214, 0], [255, 210, 0],
        [255, 155, 0], [251, 223, 0], [255, 131, 0], [214, 159, 0], [230, 124, 0],
        [202, 20, 19], [163, 0, 28], [178, 0, 18], [242, 76, 0], [206, 14, 7],
        [131, 7, 23], [139, 16, 26], [78, 42, 43], [59, 29, 27], [25, 25, 24],
        [22, 20, 18], [74, 112, 66], [0, 46, 37], [34, 45, 48], [8, 76, 60],
        [0, 68, 59], [57, 20, 65], [28, 25, 41], [57, 57, 55], [73, 28, 39],
        [65, 30, 69]
    ],
    "System 3 Original Acrylic - Dal": [
        [51, 49, 50], [49, 49, 49], [43, 91, 192], [51, 48, 80], [46, 46, 60],
        [49, 45, 81], [123, 62, 51], [75, 60, 55], [67, 60, 55], [46, 62, 52],
        [38, 58, 58], [81, 117, 76], [42, 75, 49], [57, 51, 53], [138, 47, 68],
        [189, 45, 44], [159, 43, 44], [210, 45, 37], [238, 139, 0], [227, 71, 37],
        [241, 222, 0], [189, 137, 62], [163, 105, 59], [254, 208, 0]
    ],
    "Vallejo Acrylic Studio": [
        [246, 226, 0], [172, 23, 28], [143, 27, 37], [42, 41, 77], [39, 33, 78],
        [22, 47, 53], [194, 134, 33], [134, 55, 45], [48, 47, 47], [223, 132, 0],
        [43, 38, 39], [220, 58, 34], [37, 52, 40], [96, 81, 62], [82, 59, 51],
        [163, 109, 40], [131, 63, 45], [255, 187, 0], [125, 16, 61], [50, 97, 192],
        [114, 29, 30], [251, 205, 0], [148, 43, 32], [40, 39, 51]
    ]
}
</script>
</head>

<body>
<h2>Art-AI Renderer - Selective Resolution</h2>

<!-- ========================== LOAD JSON ========================= -->
<div class="section">
    <h3>Load JSON Files</h3>

    <label>Base (Low-res):</label>
    <input type="file" id="baseFileInput" accept=".json">
    <span id="baseFileStatus" class="info"></span>
    
    <label>Detail (High-res):</label>
    <input type="file" id="detailFileInput" accept=".json">
    <span id="detailFileStatus" class="info"></span>
</div>

<!-- ====================== SELECTIVE RESOLUTION =================== -->
<div class="section highlight">
    <h3>Selective Resolution Tool</h3>
    <div class="info">Draw rectangles on the canvas to enhance specific regions with high-resolution shapes.</div>

    <button id="selectRegionsBtn">Select Regions for Detail</button>
    <button id="clearRegionsBtn">Clear All Regions</button>
    <button id="applySelectiveBtn">Apply Selective Resolution</button>

    <div class="region-list" id="regionList" style="display:none;"></div>
</div>

<!-- ====================== RENDERING LOGIC ======================== -->
<div class="section">
    <h3>Rendering Logic</h3>

    <div class="radio-group">
        <label><input type="radio" name="logic" value="original" checked> Original Order</label>
        <label><input type="radio" name="logic" value="exterior_to_center"> Exterior ‚Üí Center</label>
        <label><input type="radio" name="logic" value="center_to_exterior"> Center ‚Üí Exterior</label>
        <label><input type="radio" name="logic" value="top_to_bottom"> Top ‚Üí Bottom</label>
        <label><input type="radio" name="logic" value="bottom_to_top"> Bottom ‚Üí Top</label>
        <label><input type="radio" name="logic" value="color_sequence"> Color Sequence</label>
        <label><input type="radio" name="logic" value="light_to_dark"> Light ‚Üí Dark</label>
        <label><input type="radio" name="logic" value="dark_to_light"> Dark ‚Üí Light</label>
        <label><input type="radio" name="logic" value="frequency_by_color"> Most Count ‚Üí Least Count</label>
        <label><input type="radio" name="logic" value="frequency_by_color_reverse"> Least Count ‚Üí Most Count</label>
        <label><input type="radio" name="logic" value="custom_sequence"> Custom Sequence (Drag Colors)</label>
    </div>

    <button id="editColorBtn">Edit Color Sequence</button>
    <button id="dragColorBtn">Drag & Drop Color Order</button>

    <!-- ‚≠ê NEW BAKE OPAQUE BUTTON (Option A) -->
    <button id="bakeOpaqueBtn" style="background:#2196F3; color:white; margin-top:10px;">
        Bake Opaque (Fix Order Issues)
    </button>
    <div class="info">Makes shapes order-independent</div>
</div>

<!-- ====================== COLOR PICKER ======================== -->
<div class="section">
    <h3>Color Picker</h3>
    <div class="info">Click on shapes in the canvas to inspect their color values.</div>
    <button id="colorPickerBtn">Enable Color Picker</button>
    
    <div id="colorPickerPanel" class="color-picker-panel">
        <div class="color-picker-header">
            <h4>Selected Shape</h4>
            <div id="colorPreviewBox" class="color-preview-box"></div>
        </div>
        <div class="color-details">
            <div class="color-detail-item">
                <label>Shape Type</label>
                <span id="shapeTypeValue">-</span>
            </div>
            <div class="color-detail-item">
                <label>Shape Index</label>
                <span id="shapeIndexValue">-</span>
            </div>
            <div class="color-detail-item">
                <label>RGB</label>
                <span id="rgbValue">-</span>
            </div>
            <div class="color-detail-item">
                <label>RGBA</label>
                <span id="rgbaValue">-</span>
            </div>
            <div class="color-detail-item">
                <label>HEX</label>
                <span id="hexValue">-</span>
            </div>
            <div class="color-detail-item">
                <label>Alpha</label>
                <span id="alphaValue">-</span>
            </div>
        </div>
        <div class="color-details" style="margin-top: 8px;">
            <div class="color-detail-item">
                <label>Position (center)</label>
                <span id="positionValue">-</span>
            </div>
            <div class="color-detail-item">
                <label>Score</label>
                <span id="scoreValue">-</span>
            </div>
        </div>
        
        <!-- Palette Preset Section -->
        <div class="palette-preset-section">
            <h4>Load Palette Preset</h4>
            <div class="palette-preset-controls">
                <select id="palettePresetSelect">
                    <option value="">-- Select a palette --</option>
                </select>
                <button id="loadPaletteBtn" disabled>Load</button>
            </div>
        </div>
        
        <!-- Color Matcher Section -->
        <div class="color-matcher-section">
            <h5>Match Against Palette</h5>
            <textarea id="colorMatcherInput" class="color-matcher-input" placeholder="Enter hex colors to compare against (one per line or comma-separated):
#FF5733
#3498DB
#2ECC71"></textarea>

            <div id="matchResults" class="match-results">
                <div class="match-empty">Select a shape and enter palette colors to compare</div>
            </div>
        </div>
        
        <!-- Unmix / Get Recipe Section -->
        <div class="unmix-section">
            <h5>Get Mix Recipe (Unmix)</h5>
            <p style="font-size: 11px; color: #666; margin: 0 0 12px 0;">
                Find which paints to mix (and in what proportions) to recreate the selected color.
            </p>
            <div class="unmix-controls">
                <div class="unmix-control-item">
                    <label>Max Colors in Recipe</label>
                    <input type="number" id="maxColorsInput" value="3" min="1" max="5">
                </div>
                <div class="unmix-control-item">
                    <label>Max Parts (Precision)</label>
                    <input type="number" id="maxPartsInput" value="10" min="2" max="20">
                </div>
            </div>
            <button id="getRecipeBtn" disabled>Get Mix Recipe</button>
            <div id="recipeResults" class="recipe-results">
                <div class="recipe-empty">Select a shape and load a palette to get a mixing recipe</div>
            </div>
        </div>
    </div>
</div>

<!-- ========================= SLIDERS ============================= -->
<div class="section slider-container">
    <h3>Progressive Render</h3>
    <div class="info" id="sliderLabel">Shapes: 0 / 0</div>
    <input type="range" id="slider" min="0" max="0" value="0">
</div>

<div class="section slider-container">
    <h3>Color Grouping (Compress Similar Colors)</h3>
    <div class="info" id="colorGroupLabel">Tolerance: 0 (Unique colors: 0)</div>
    <input type="range" id="colorGroupSlider" min="0" max="100" value="0">
</div>

<!-- ========================== CANVAS ============================= -->
<div style="position: relative;">
    <canvas id="canvas" width="600" height="600"></canvas>
    <div id="regionOverlay" style="position:absolute; top:0; left:0; pointer-events:none;"></div>
</div>

<!-- ========== MODALS (COLOR SEQUENCE + DRAG) ‚Äî UNCHANGED ========= -->
<div id="colorModal" class="modal">
    <div class="modal-content">
        <h3>Edit Color Sequence</h3>
        <textarea id="colorInput"></textarea>
        <div class="modal-buttons">
            <button id="cancelColorBtn">Cancel</button>
            <button id="saveColorBtn">Save</button>
        </div>
    </div>
</div>

<div id="dragModal" class="modal">
    <div class="modal-content">
        <h3>Drag & Drop Color Order</h3>
        <div id="frequencyInfo" class="frequency-info"></div>
        <div id="colorPalette" class="color-palette"></div>
        <div class="modal-buttons">
            <button id="cancelDragBtn">Cancel</button>
            <button id="saveDragBtn">Save Order</button>
        </div>
    </div>
</div>

<script>
//const API_BASE = "http://127.0.0.1:8000";
const API_BASE = "https://slider-options-img-production.up.railway.app";

let baseShapes = [];
let detailShapes = [];
let currentShapes = [];
let groupedShapes = [];
let regions = [];
let customColorOrder = null;
let colorOrder = null;
let colorTolerance = 0;

const baseFileInput = document.getElementById("baseFileInput");
const detailFileInput = document.getElementById("detailFileInput");
const baseFileStatus = document.getElementById("baseFileStatus");
const detailFileStatus = document.getElementById("detailFileStatus");

const selectRegionsBtn = document.getElementById("selectRegionsBtn");
const clearRegionsBtn = document.getElementById("clearRegionsBtn");
const applySelectiveBtn = document.getElementById("applySelectiveBtn");
const regionList = document.getElementById("regionList");
const regionOverlay = document.getElementById("regionOverlay");

const slider = document.getElementById("slider");
const sliderLabel = document.getElementById("sliderLabel");
const colorGroupSlider = document.getElementById("colorGroupSlider");
const colorGroupLabel = document.getElementById("colorGroupLabel");

const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");

const logicRadios = document.querySelectorAll("input[name='logic']");
const editColorBtn = document.getElementById("editColorBtn");
const dragColorBtn = document.getElementById("dragColorBtn");

const bakeOpaqueBtn = document.getElementById("bakeOpaqueBtn");

const colorPickerBtn = document.getElementById("colorPickerBtn");
const colorPickerPanel = document.getElementById("colorPickerPanel");
const colorPreviewBox = document.getElementById("colorPreviewBox");
const shapeTypeValue = document.getElementById("shapeTypeValue");
const shapeIndexValue = document.getElementById("shapeIndexValue");
const rgbValue = document.getElementById("rgbValue");
const rgbaValue = document.getElementById("rgbaValue");
const hexValue = document.getElementById("hexValue");
const alphaValue = document.getElementById("alphaValue");
const positionValue = document.getElementById("positionValue");
const scoreValue = document.getElementById("scoreValue");

// Color Matcher elements
const colorMatcherInput = document.getElementById("colorMatcherInput");
const matchResults = document.getElementById("matchResults");

// Unmix / Recipe elements
const maxColorsInput = document.getElementById("maxColorsInput");
const maxPartsInput = document.getElementById("maxPartsInput");
const getRecipeBtn = document.getElementById("getRecipeBtn");
const recipeResults = document.getElementById("recipeResults");

let isSelecting = false;
let startX = 0, startY = 0;
let currentRegion = null;

let isPickingColor = false;
let selectedShapeIndex = null;
let currentSelectedColor = null;

/* ==========================================================
   LOAD JSON
========================================================== */

baseFileInput.addEventListener("change", async e => {
    const file = e.target.files[0];
    if (!file) return;

    const text = await file.text();
    baseShapes = JSON.parse(text);

    currentShapes = [...baseShapes];
    groupedShapes = [...currentShapes];

    baseFileStatus.textContent = `‚úì Loaded (${baseShapes.length} shapes)`;

    updateRender();
});

detailFileInput.addEventListener("change", async e => {
    const file = e.target.files[0];
    if (!file) return;

    const text = await file.text();
    detailShapes = JSON.parse(text);
    detailFileStatus.textContent = `‚úì Loaded (${detailShapes.length} shapes)`;
});

/* ==========================================================
   REGION SELECTION
========================================================== */

selectRegionsBtn.addEventListener("click", () => {
    isSelecting = !isSelecting;
    selectRegionsBtn.classList.toggle("active", isSelecting);
    selectRegionsBtn.textContent = isSelecting ? "Stop Selecting" : "Select Regions for Detail";
    
    // Disable color picker when region selection is active
    if (isSelecting && isPickingColor) {
        isPickingColor = false;
        colorPickerBtn.classList.remove("active");
        colorPickerBtn.textContent = "Enable Color Picker";
        canvas.classList.remove("picking");
        colorPickerPanel.classList.remove("active");
        clearShapeHighlight();
    }
});

clearRegionsBtn.addEventListener("click", () => {
    regions = [];
    updateRegionUI();
    updateRender();
});

canvas.addEventListener("mousedown", e => {
    if (!isSelecting) return;

    const rect = canvas.getBoundingClientRect();
    startX = e.clientX - rect.left;
    startY = e.clientY - rect.top;

    currentRegion = { x: startX, y: startY, width: 0, height: 0 };
});

canvas.addEventListener("mousemove", e => {
    if (!isSelecting || !currentRegion) return;

    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;

    currentRegion.width = x - startX;
    currentRegion.height = y - startY;

    drawCanvas();
    drawRegionOverlay(currentRegion, true);
});

canvas.addEventListener("mouseup", e => {
    if (!isSelecting || !currentRegion) return;

    if (currentRegion.width < 0) {
        currentRegion.x += currentRegion.width;
        currentRegion.width = Math.abs(currentRegion.width);
    }
    if (currentRegion.height < 0) {
        currentRegion.y += currentRegion.height;
        currentRegion.height = Math.abs(currentRegion.height);
    }

    const imgRect = getImageRect();
    const scale = imgRect.scale;

    const region = {
        x: (currentRegion.x - imgRect.x) / scale,
        y: (currentRegion.y - imgRect.y) / scale,
        width: currentRegion.width / scale,
        height: currentRegion.height / scale
    };

    if (region.width > 5 && region.height > 5) regions.push(region);

    currentRegion = null;
    updateRegionUI();
    updateRender();
});

/* ==========================================================
   REGION UI
========================================================== */

function updateRegionUI() {
    regionOverlay.innerHTML = "";

    if (regions.length === 0) {
        regionList.style.display = "none";
        return;
    }

    regionList.style.display = "block";
    regionList.innerHTML = `<strong>Selected Regions (${regions.length}):</strong>`;

    const imgRect = getImageRect();
    const scale = imgRect.scale;

    regions.forEach((r, i) => {
        const box = document.createElement("div");
        box.className = "region-box";
        box.style.left = imgRect.x + r.x * scale + "px";
        box.style.top = imgRect.y + r.y * scale + "px";
        box.style.width = r.width * scale + "px";
        box.style.height = r.height * scale + "px";

        regionOverlay.appendChild(box);

        const item = document.createElement("div");
        item.className = "region-item";
        item.innerHTML = `
            Region ${i + 1}: ${Math.round(r.width)}√ó${Math.round(r.height)}
            <button onclick="removeRegion(${i})">Remove</button>
        `;
        regionList.appendChild(item);
    });
}

window.removeRegion = function(i) {
    regions.splice(i, 1);
    updateRegionUI();
    updateRender();
};

/* ==========================================================
   IMAGE SCALE HELPERS
========================================================== */

function getImageRect() {
    const bg = currentShapes.find(s => s.type === 0);
    let w = 600, h = 600;

    if (bg) {
        const [x1, y1, x2, y2] = bg.data;
        w = Math.abs(x2 - x1);
        h = Math.abs(y2 - y1);
    }

    const scale = Math.min(canvas.width / w, canvas.height / h);
    const x = (canvas.width - w * scale) / 2;
    const y = (canvas.height - h * scale) / 2;

    return { x, y, w, h, scale };
}

/* ==========================================================
   APPLY SELECTIVE RESOLUTION
========================================================== */

applySelectiveBtn.addEventListener("click", async () => {
    if (!baseShapes.length || !detailShapes.length) {
        alert("Load both base and detail JSON first.");
        return;
    }
    if (!regions.length) {
        alert("Select regions first.");
        return;
    }

    const res = await fetch(`${API_BASE}/selective_resolution`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
            base_shapes: baseShapes,
            detail_shapes: detailShapes,
            regions
        })
    });

    const data = await res.json();

    currentShapes = [...data.shapes];
    groupedShapes = [...currentShapes];
    colorTolerance = 0;
    colorGroupSlider.value = 0;

    alert("Selective resolution applied successfully!");

    updateRender();
});

/* ==========================================================
   BAKE OPAQUE ‚Äî PAGE 31 FIX
========================================================== */

bakeOpaqueBtn.addEventListener("click", async () => {
    if (!currentShapes.length) {
        alert("Load shapes first.");
        return;
    }

    // Render final image to canvas
    drawCanvas();

    const pngBlob = await new Promise(resolve => canvas.toBlob(resolve, "image/png"));

    const form = new FormData();
    form.append("file", pngBlob, "render.png");
    form.append(
        "request",
        new Blob(
            [JSON.stringify({ shapes: currentShapes, logic: "original", limit: null })],
            { type: "application/json" }
        )
    );

    const res = await fetch(`${API_BASE}/bake_opaque`, {
        method: "POST",
        body: form
    });

    const data = await res.json();

    currentShapes = [...data.shapes];
    groupedShapes = [...currentShapes];
    colorTolerance = 0;

    alert("Baked successfully! Shapes are now order-independent.");

    updateRender();
});

/* ==========================================================
   COLOR PICKER TOOL
========================================================== */

colorPickerBtn.addEventListener("click", () => {
    isPickingColor = !isPickingColor;
    colorPickerBtn.classList.toggle("active", isPickingColor);
    colorPickerBtn.textContent = isPickingColor ? "Disable Color Picker" : "Enable Color Picker";
    canvas.classList.toggle("picking", isPickingColor);
    
    // Disable region selection when color picking is active
    if (isPickingColor && isSelecting) {
        isSelecting = false;
        selectRegionsBtn.classList.remove("active");
        selectRegionsBtn.textContent = "Select Regions for Detail";
    }
    
    if (!isPickingColor) {
        colorPickerPanel.classList.remove("active");
        clearShapeHighlight();
    }
});

function getShapeTypeName(type) {
    const types = {
        0: "Background",
        1: "Circle",
        2: "Triangle",
        3: "Quad",
        4: "Ellipse"
    };
    return types[type] || `Type ${type}`;
}

function rgbToHex(r, g, b) {
    return "#" + [r, g, b].map(x => {
        const hex = Math.round(x).toString(16);
        return hex.length === 1 ? "0" + hex : hex;
    }).join("").toUpperCase();
}

function getShapeCenter(shape, imgRect) {
    if (shape.type === 0 && shape.data.length >= 4) {
        const [x1, y1, x2, y2] = shape.data;
        return { x: (x1 + x2) / 2, y: (y1 + y2) / 2 };
    }
    if (shape.type === 1 && shape.data.length >= 3) {
        return { x: shape.data[0], y: shape.data[1] };
    }
    if (shape.type === 2 && shape.data.length >= 6) {
        const [A, B, C, D, E, F] = shape.data;
        return { x: (A + C + E) / 3, y: (B + D + F) / 3 };
    }
    if (shape.type === 4 && shape.data.length >= 2) {
        return { x: shape.data[0], y: shape.data[1] };
    }
    return { x: imgRect.w / 2, y: imgRect.h / 2 };
}

function isPointInShape(x, y, shape, imgRect) {
    // Convert canvas coordinates to image coordinates
    const imgX = (x - imgRect.x) / imgRect.scale;
    const imgY = (y - imgRect.y) / imgRect.scale;
    
    if (shape.type === 0) {
        // Background - covers entire canvas
        return true;
    }
    
    if (shape.type === 1) {
        // Circle
        const [cx, cy, rad] = shape.data;
        const dist = Math.hypot(imgX - cx, imgY - cy);
        return dist <= rad;
    }
    
    if (shape.type === 2) {
        // Triangle - use barycentric coordinates
        const [A, B, C, D, E, F] = shape.data;
        return isPointInTriangle(imgX, imgY, A, B, C, D, E, F);
    }
    
    if (shape.type === 4) {
        // Ellipse
        const [cx, cy, rx, ry, ang = 0] = shape.data;
        const angleRad = (ang * Math.PI) / 180;
        const cos = Math.cos(-angleRad);
        const sin = Math.sin(-angleRad);
        const dx = imgX - cx;
        const dy = imgY - cy;
        const rotX = dx * cos - dy * sin;
        const rotY = dx * sin + dy * cos;
        return (rotX * rotX) / (rx * rx) + (rotY * rotY) / (ry * ry) <= 1;
    }
    
    return false;
}

function isPointInTriangle(px, py, x1, y1, x2, y2, x3, y3) {
    const area = 0.5 * (-y2 * x3 + y1 * (-x2 + x3) + x1 * (y2 - y3) + x2 * y3);
    const s = 1 / (2 * area) * (y1 * x3 - x1 * y3 + (y3 - y1) * px + (x1 - x3) * py);
    const t = 1 / (2 * area) * (x1 * y2 - y1 * x2 + (y1 - y2) * px + (x2 - x1) * py);
    return s >= 0 && t >= 0 && (1 - s - t) >= 0;
}

function findShapeAtPoint(x, y) {
    const imgRect = getImageRect();
    const working = groupedShapes.length ? groupedShapes : currentShapes;
    
    // Get currently displayed shapes based on slider
    const limit = parseInt(slider.value);
    const displayedShapes = limit > 0 ? working.slice(0, limit) : working;
    
    // Search from top (last rendered) to bottom (first rendered)
    for (let i = displayedShapes.length - 1; i >= 0; i--) {
        const shape = displayedShapes[i];
        if (isPointInShape(x, y, shape, imgRect)) {
            return { shape, index: i };
        }
    }
    return null;
}

function displayShapeInfo(shape, index) {
    const imgRect = getImageRect();
    const [r, g, b, a] = shape.color;
    
    // Set current selected color for matching
    currentSelectedColor = rgbToHex(r, g, b);
    updateMatchButtonState();
    
    colorPickerPanel.classList.add("active");
    colorPreviewBox.style.backgroundColor = `rgba(${r},${g},${b},${a/255})`;
    
    shapeTypeValue.textContent = getShapeTypeName(shape.type);
    shapeIndexValue.textContent = index;
    rgbValue.textContent = `${r}, ${g}, ${b}`;
    rgbaValue.textContent = `${r}, ${g}, ${b}, ${a}`;
    hexValue.textContent = rgbToHex(r, g, b);
    alphaValue.textContent = `${a} (${(a/255*100).toFixed(1)}%)`;
    
    const center = getShapeCenter(shape, imgRect);
    positionValue.textContent = `${center.x.toFixed(1)}, ${center.y.toFixed(1)}`;
    scoreValue.textContent = shape.score?.toFixed(4) || "-";
    
    highlightShape(shape, imgRect);
}

function highlightShape(shape, imgRect) {
    clearShapeHighlight();
    
    // Create SVG overlay for precise shape outline
    const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    svg.id = "shapeHighlight";
    svg.style.position = "absolute";
    svg.style.left = imgRect.x + "px";
    svg.style.top = imgRect.y + "px";
    svg.style.width = imgRect.w * imgRect.scale + "px";
    svg.style.height = imgRect.h * imgRect.scale + "px";
    svg.style.pointerEvents = "none";
    svg.style.overflow = "visible";
    
    let pathElement;
    const scale = imgRect.scale;
    
    if (shape.type === 0) {
        // Background - rectangle outline
        pathElement = document.createElementNS("http://www.w3.org/2000/svg", "rect");
        pathElement.setAttribute("x", "2");
        pathElement.setAttribute("y", "2");
        pathElement.setAttribute("width", imgRect.w * scale - 4);
        pathElement.setAttribute("height", imgRect.h * scale - 4);
    } else if (shape.type === 1) {
        // Circle
        const [cx, cy, rad] = shape.data;
        pathElement = document.createElementNS("http://www.w3.org/2000/svg", "circle");
        pathElement.setAttribute("cx", cx * scale);
        pathElement.setAttribute("cy", cy * scale);
        pathElement.setAttribute("r", rad * scale);
    } else if (shape.type === 2) {
        // Triangle
        const [A, B, C, D, E, F] = shape.data;
        pathElement = document.createElementNS("http://www.w3.org/2000/svg", "polygon");
        const points = `${A * scale},${B * scale} ${C * scale},${D * scale} ${E * scale},${F * scale}`;
        pathElement.setAttribute("points", points);
    } else if (shape.type === 4) {
        // Ellipse (with rotation support)
        const [cx, cy, rx, ry, ang = 0] = shape.data;
        pathElement = document.createElementNS("http://www.w3.org/2000/svg", "ellipse");
        pathElement.setAttribute("cx", cx * scale);
        pathElement.setAttribute("cy", cy * scale);
        pathElement.setAttribute("rx", rx * scale);
        pathElement.setAttribute("ry", ry * scale);
        if (ang !== 0) {
            pathElement.setAttribute("transform", `rotate(${ang} ${cx * scale} ${cy * scale})`);
        }
    } else {
        return;
    }
    
    // Style the outline
    pathElement.setAttribute("fill", "rgba(0, 188, 212, 0.15)");
    pathElement.setAttribute("stroke", "#00BCD4");
    pathElement.setAttribute("stroke-width", "3");
    pathElement.setAttribute("stroke-dasharray", "8,4");
    
    // Add animated dash effect
    const animate = document.createElementNS("http://www.w3.org/2000/svg", "animate");
    animate.setAttribute("attributeName", "stroke-dashoffset");
    animate.setAttribute("from", "0");
    animate.setAttribute("to", "24");
    animate.setAttribute("dur", "1s");
    animate.setAttribute("repeatCount", "indefinite");
    pathElement.appendChild(animate);
    
    svg.appendChild(pathElement);
    regionOverlay.appendChild(svg);
}

function clearShapeHighlight() {
    const existing = document.getElementById("shapeHighlight");
    if (existing) existing.remove();
}

canvas.addEventListener("click", e => {
    if (!isPickingColor) return;
    if (isSelecting) return;
    
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    
    const result = findShapeAtPoint(x, y);
    
    if (result) {
        selectedShapeIndex = result.index;
        displayShapeInfo(result.shape, result.index);
    } else {
        colorPickerPanel.classList.remove("active");
        clearShapeHighlight();
    }
});

/* ==========================================================
   PALETTE PRESET FUNCTIONALITY
========================================================== */

// Embedded palette data to avoid CORS issues with local files
let palettePresetsData = null;

// Load colors.json data
async function loadPalettePresets() {
    try {
        // Try to fetch colors.json if server is available
        const response = await fetch('colors.json');
        palettePresetsData = await response.json();
    } catch (error) {
        console.warn('Could not fetch colors.json, using embedded fallback');
        // Fallback: Load from embedded script tag or use default
        const colorsScript = document.getElementById('colorsData');
        if (colorsScript && colorsScript.textContent) {
            try {
                palettePresetsData = JSON.parse(colorsScript.textContent);
            } catch (e) {
                console.error('Error parsing embedded colors data:', e);
                return;
            }
        } else {
            console.error('No colors data available');
            return;
        }
    }
    
    if (!palettePresetsData) return;
    
    const select = document.getElementById('palettePresetSelect');
    
    // Clear existing options except the first one
    while (select.options.length > 1) {
        select.remove(1);
    }
    
    // Populate dropdown with palette names
    Object.keys(palettePresetsData).forEach(paletteName => {
        const option = document.createElement('option');
        option.value = paletteName;
        option.textContent = `${paletteName} (${palettePresetsData[paletteName].length} colors)`;
        select.appendChild(option);
    });
    
    console.log('Loaded palette presets:', Object.keys(palettePresetsData));
}

// Enable/disable load button based on selection
document.getElementById('palettePresetSelect').addEventListener('change', (e) => {
    document.getElementById('loadPaletteBtn').disabled = !e.target.value;
});

// Load selected palette into the color matcher input
document.getElementById('loadPaletteBtn').addEventListener('click', () => {
    const select = document.getElementById('palettePresetSelect');
    const selectedPalette = select.value;
    
    if (!selectedPalette || !palettePresetsData[selectedPalette]) {
        return;
    }
    
    const colorArray = palettePresetsData[selectedPalette];
    
    // Convert RGB arrays to hex format
    const hexColors = colorArray.map(rgb => {
        const r = Math.round(rgb[0]);
        const g = Math.round(rgb[1]);
        const b = Math.round(rgb[2]);
        return rgbToHex(r, g, b);
    });
    
    // Populate the color matcher input textarea
    const colorMatcherInput = document.getElementById('colorMatcherInput');
    colorMatcherInput.value = hexColors.join('\n');
    
    // Update match button state
    updateMatchButtonState();
    
    console.log(`Loaded ${hexColors.length} colors from "${selectedPalette}"`);
});

// Initialize palette presets on page load
loadPalettePresets();

/* ==========================================================
   COLOR MATCHER FUNCTIONALITY (via API)
========================================================== */

colorMatcherInput.addEventListener("input", updateMatchButtonState);

function updateMatchButtonState() {
    const hasColor = currentSelectedColor !== null;
    const hasPalette = colorMatcherInput.value.trim().length > 0;
    // Also update recipe button
    if (typeof updateRecipeButtonState === 'function') {
        updateRecipeButtonState();
    } else {
        getRecipeBtn.disabled = !(hasColor && hasPalette);
    }
}

function parsePaletteColors(input) {
    return input
        .split(/[\n,]+/)
        .map(c => c.trim())
        .filter(c => c.length > 0)
        .map(c => c.startsWith('#') ? c : '#' + c)
        .filter(c => /^#[0-9A-Fa-f]{3,6}$/i.test(c));
}

function getMatchClass(percentage) {
    if (percentage >= 70) return 'high';
    if (percentage >= 40) return 'medium';
    return 'low';
}

function renderMatchResults(data) {
    if (data.error && !data.has_matches) {
        let html = `<div class="match-error">‚ö†Ô∏è ${data.error}</div>`;
        
        // Still show results if we have them (just with low matches)
        if (data.matches && data.matches.length > 0) {
            html += `<div class="match-results-header" style="margin-top: 12px;">
                <span>All Comparisons</span>
                <span>${data.matches.length} colors</span>
            </div>`;
            html += data.matches.map((m, i) => renderMatchItem(m, i === 0)).join('');
        }
        
        matchResults.innerHTML = html;
        return;
    }
    
    if (!data.matches || data.matches.length === 0) {
        matchResults.innerHTML = `<div class="match-empty">No valid colors found in the palette</div>`;
        return;
    }
    
    let html = `<div class="match-results-header">
        <span>Match Results</span>
        <span>${data.matches.length} colors</span>
    </div>`;
    
    html += data.matches.map((m, i) => renderMatchItem(m, i === 0)).join('');
    
    matchResults.innerHTML = html;
}

function renderMatchItem(match, isBest) {
    const matchClass = getMatchClass(match.match_percentage);
    return `
        <div class="match-result-item ${isBest ? 'best-match' : ''}">
            <div class="match-color-swatch" style="background: ${match.hex}"></div>
            <div class="match-info">
                <div class="match-hex">
                    ${match.hex}
                    ${isBest ? '<span class="best-badge">Best</span>' : ''}
                </div>
                <div class="match-delta">ŒîE: ${match.delta_e.toFixed(2)}</div>
                <div class="match-progress-bar">
                    <div class="match-progress-fill ${matchClass}" style="width: ${match.match_percentage}%"></div>
                </div>
            </div>
            <div class="match-percentage">
                <div class="match-percentage-value ${matchClass}">${match.match_percentage.toFixed(1)}%</div>
                <div class="match-percentage-label">match</div>
            </div>
        </div>
    `;
}



/* ==========================================================
   UNMIX / GET RECIPE FUNCTIONALITY (via API)
========================================================== */

// Update recipe button state
function updateRecipeButtonState() {
    const hasColor = currentSelectedColor !== null;
    const hasPalette = colorMatcherInput.value.trim().length > 0;
    getRecipeBtn.disabled = !(hasColor && hasPalette);
}

// Also update recipe button when palette changes
colorMatcherInput.addEventListener("input", updateRecipeButtonState);

function getRecipeMatchClass(percentage) {
    if (percentage >= 70) return 'high';
    if (percentage >= 40) return 'medium';
    return 'low';
}

function formatMixMethod(method) {
    const methods = {
        'kubelka_munk': 'Kubelka-Munk (Paint)',
        'yn_km': 'Yule-Nielsen KM',
        'linear': 'Linear RGB (Light)',
        'exact': 'Exact Match'
    };
    return methods[method] || method;
}

function renderRecipeResults(data) {
    if (data.error) {
        recipeResults.innerHTML = `<div class="recipe-error">‚ö†Ô∏è ${data.error}</div>`;
        return;
    }
    
    if (!data.recipe || data.recipe.length === 0) {
        recipeResults.innerHTML = `<div class="recipe-empty">No recipe found for this color</div>`;
        return;
    }
    
    const matchClass = getRecipeMatchClass(data.match_percentage);
    
    let html = `
        <div class="recipe-header">
            <div class="recipe-header-left">
                <div class="recipe-target-swatch" style="background: ${data.target_color}" title="Target"></div>
                <div class="recipe-arrow">‚Üí</div>
                <div class="recipe-result-swatch" style="background: ${data.result_color}" title="Result"></div>
            </div>
            <div class="recipe-match-info">
                <div class="recipe-match-value ${matchClass}">${data.match_percentage}%</div>
                <div class="recipe-match-label">match</div>
                <div class="recipe-method">${formatMixMethod(data.mix_method)}</div>
            </div>
        </div>
        <div class="recipe-components">
    `;
    
    data.recipe.forEach(comp => {
        const displayName = comp.name || comp.hex;
        html += `
            <div class="recipe-component">
                <div class="recipe-component-swatch" style="background: ${comp.hex}"></div>
                <div class="recipe-component-info">
                    <div class="recipe-component-name" title="${displayName}">${displayName}</div>
                    <div class="recipe-component-hex">${comp.hex}</div>
                </div>
                <div class="recipe-component-amount">
                    <div class="recipe-component-parts">${comp.parts}</div>
                    <div class="recipe-component-parts-label">parts</div>
                    <div class="recipe-component-percent">${comp.percentage}%</div>
                </div>
            </div>
        `;
    });
    
    html += `</div>`;
    html += `<div class="recipe-total">Total: ${data.total_parts} parts ¬∑ ŒîE: ${data.delta_e}</div>`;
    
    recipeResults.innerHTML = html;
}

// Build palette with names for the unmix request
function buildPaletteWithNames(hexColors) {
    // Try to get names from the loaded palette preset
    const select = document.getElementById('palettePresetSelect');
    const selectedPalette = select.value;
    
    if (selectedPalette && palettePresetsData && palettePresetsData[selectedPalette]) {
        const colorArray = palettePresetsData[selectedPalette];
        const paletteMap = new Map();
        
        // Build map of hex -> name
        colorArray.forEach((rgb, idx) => {
            const r = Math.round(rgb[0]);
            const g = Math.round(rgb[1]);
            const b = Math.round(rgb[2]);
            const hex = rgbToHex(r, g, b).toUpperCase();
            paletteMap.set(hex, `${selectedPalette} #${idx + 1}`);
        });
        
        // Return palette with names where available
        return hexColors.map(hex => ({
            hex: hex,
            name: paletteMap.get(hex.toUpperCase()) || null
        }));
    }
    
    // No preset loaded, return without names
    return hexColors.map(hex => ({ hex: hex, name: null }));
}

getRecipeBtn.addEventListener("click", async () => {
    if (!currentSelectedColor) {
        alert("Please select a shape first using the color picker.");
        return;
    }
    
    const paletteColors = parsePaletteColors(colorMatcherInput.value);
    
    if (paletteColors.length === 0) {
        recipeResults.innerHTML = `<div class="recipe-error">‚ö†Ô∏è Please enter valid hex colors in the palette</div>`;
        return;
    }
    
    const maxColors = parseInt(maxColorsInput.value) || 3;
    const maxParts = parseInt(maxPartsInput.value) || 10;
    
    // Build palette with names
    const paletteWithNames = buildPaletteWithNames(paletteColors);
    
    // Show loading state
    recipeResults.innerHTML = `<div class="recipe-empty">‚è≥ Finding best recipe...</div>`;
    getRecipeBtn.disabled = true;
    
    try {
        const response = await fetch(`${API_BASE}/unmix`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
                target_color: currentSelectedColor,
                palette: paletteWithNames,
                max_colors: maxColors,
                max_parts: maxParts
            })
        });
        
        if (!response.ok) {
            throw new Error(`API error: ${response.status}`);
        }
        
        const data = await response.json();
        renderRecipeResults(data);
        
    } catch (error) {
        console.error("Unmix API error:", error);
        recipeResults.innerHTML = `<div class="recipe-error">‚ö†Ô∏è API Error: ${error.message}. Make sure the backend is running.</div>`;
    } finally {
        updateRecipeButtonState();
    }
});

/* ==========================================================
   LOGIC ORDERING ‚Äì CALL BACKEND
========================================================== */

logicRadios.forEach(r => r.addEventListener("change", updateRender));

slider.addEventListener("input", updateRender);

colorGroupSlider.addEventListener("input", () => {
    colorTolerance = parseInt(colorGroupSlider.value);
    applyColorGrouping();
    updateRender();
});

/* ==========================================================
   UPDATE RENDER
========================================================== */

async function updateRender() {
    if (!currentShapes.length) return;
    
    // Clear any shape highlight when re-rendering
    clearShapeHighlight();

    const working = groupedShapes.length ? groupedShapes : currentShapes;

    const logic = document.querySelector("input[name='logic']:checked").value;
    const limit = parseInt(slider.value);

    if (logic === "original") {
        slider.max = working.length;
        sliderLabel.textContent = `Shapes: ${limit} / ${working.length}`;
        drawCanvas(working.slice(0, limit || working.length));
        updateRegionUI();
        return;
    }

    const activeOrder =
        logic === "color_sequence" ? colorOrder :
        logic === "custom_sequence" ? customColorOrder : null;

    const res = await fetch(`${API_BASE}/order_shapes_from_json`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
            shapes: working,
            logic,
            limit,
            color_order: activeOrder
        })
    });

    const data = await res.json();

    slider.max = data.total_shapes;
    sliderLabel.textContent = `Shapes: ${limit} / ${data.total_shapes}`;

    drawCanvas(data.shapes);
    updateRegionUI();
}
/* ==========================================================
   DRAW CANVAS
========================================================== */
function drawCanvas(shapes = currentShapes) {
    ctx.fillStyle = "white";
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    if (!shapes.length) return;

    const img = getImageRect();
    const { x, y, scale } = img;

    const off = document.createElement("canvas");
    off.width = img.w;
    off.height = img.h;
    const o = off.getContext("2d");

    shapes.forEach(s => {
        const [r, g, b, a] = s.color;
        o.fillStyle = `rgba(${r},${g},${b},${a / 255})`;

        if (s.type === 0) {
            const [x1, y1, x2, y2] = s.data;
            o.fillRect(0, 0, img.w, img.h);
        }

        else if (s.type === 1) {
            const [cx, cy, rad] = s.data;
            o.beginPath();
            o.arc(cx, cy, rad, 0, Math.PI * 2);
            o.fill();
        }

        else if (s.type === 2) {
            const [A, B, C, D, E, F] = s.data;
            o.beginPath();
            o.moveTo(A, B);
            o.lineTo(C, D);
            o.lineTo(E, F);
            o.closePath();
            o.fill();
        }

        else if (s.type === 4) {
            const [cx, cy, rx, ry, ang] = s.data;
            o.save();
            o.translate(cx, cy);
            o.rotate((ang * Math.PI) / 180);
            o.beginPath();
            o.ellipse(0, 0, rx, ry, 0, 0, Math.PI * 2);
            o.fill();
            o.restore();
        }
    });

    ctx.drawImage(off, x, y, img.w * scale, img.h * scale);
}

/* ==========================================================
   COLOR GROUPING (TOLERANCE)
========================================================== */

function applyColorGrouping() {
    if (!currentShapes.length) return;

    const tol = colorTolerance * 2;

    if (tol === 0) {
        groupedShapes = [...currentShapes];
        updateColorGroupLabel();
        return;
    }

    const colorMap = new Map();

    currentShapes.forEach((s, idx) => {
        if (s.type === 0) return;
        const key = JSON.stringify(s.color);
        if (!colorMap.has(key)) colorMap.set(key, []);
        colorMap.get(key).push(idx);
    });

    const colorList = [...colorMap.keys()].map(k => JSON.parse(k));

    const groups = [];
    const used = new Set();

    colorList.forEach((c1, i) => {
        if (used.has(i)) return;

        const group = [c1];
        const indices = [...colorMap.get(JSON.stringify(c1))];
        used.add(i);

        colorList.forEach((c2, j) => {
            if (used.has(j)) return;
            const dist = Math.sqrt(
                (c1[0] - c2[0]) ** 2 +
                (c1[1] - c2[1]) ** 2 +
                (c1[2] - c2[2]) ** 2
            );
            if (dist <= tol) {
                used.add(j);
                group.push(c2);
                indices.push(...colorMap.get(JSON.stringify(c2)));
            }
        });

        const rep = findRepresentativeColor(group);
        groups.push({ rep, indices });
    });

    groupedShapes = currentShapes.map((s, idx) => {
        if (s.type === 0) return s;
        const g = groups.find(g => g.indices.includes(idx));
        if (!g) return s;
        return { ...s, color: g.rep };
    });

    updateColorGroupLabel();
}

function updateColorGroupLabel() {
    const unique = new Set();

    groupedShapes.forEach(s => {
        if (s.type !== 0) unique.add(JSON.stringify(s.color));
    });

    colorGroupLabel.textContent =
        `Tolerance: ${colorTolerance} (Unique colors: ${unique.size})`;
}

function findRepresentativeColor(colors) {
    let r = 0, g = 0, b = 0, a = 0;
    colors.forEach(c => {
        r += c[0];
        g += c[1];
        b += c[2];
        a += c[3];
    });
    const n = colors.length;
    return [Math.round(r / n), Math.round(g / n), Math.round(b / n), 255];
}

/* ==========================================================
   COLOR ORDER MODAL (EDIT JSON)
========================================================== */

editColorBtn.addEventListener("click", () => {
    if (!currentShapes.length) return alert("Load shapes first.");
    colorInput.value = JSON.stringify(colorOrder || [], null, 2);
    document.getElementById("colorModal").style.display = "block";
});

document.getElementById("cancelColorBtn").onclick = () =>
    (document.getElementById("colorModal").style.display = "none");

document.getElementById("saveColorBtn").onclick = () => {
    try {
        colorOrder = JSON.parse(colorInput.value);
        document.getElementById("colorModal").style.display = "none";
        updateRender();
    } catch {
        alert("Invalid JSON format.");
    }
};

/* ==========================================================
   DRAG & DROP COLOR ORDER
========================================================== */

dragColorBtn.addEventListener("click", () => {
    if (!currentShapes.length) return alert("Load shapes first.");

    populateColorPalette();
    document.getElementById("dragModal").style.display = "block";
});

document.getElementById("cancelDragBtn").onclick = () =>
    (document.getElementById("dragModal").style.display = "none");

document.getElementById("saveDragBtn").onclick = () => {
    const chips = [...document.getElementById("colorPalette").children];
    customColorOrder = chips.map(chip => JSON.parse(chip.dataset.color));
    document.getElementById("dragModal").style.display = "none";
    updateRender();
};

function populateColorPalette() {
    const palette = document.getElementById("colorPalette");
    palette.innerHTML = "";

    const freq = new Map();
    const working = groupedShapes.length ? groupedShapes : currentShapes;

    working.forEach(s => {
        if (s.type === 0) return;
        const k = JSON.stringify(s.color);
        freq.set(k, (freq.get(k) || 0) + 1);
    });

    const list = [...freq.entries()].map(([k, count]) => ({
        color: JSON.parse(k),
        count
    }));

    list.sort((a, b) => b.count - a.count);

    list.forEach((item, i) => {
        const chip = document.createElement("div");
        chip.className = "color-chip";
        chip.draggable = true;
        chip.dataset.color = JSON.stringify(item.color);

        chip.style.backgroundColor =
            `rgba(${item.color[0]},${item.color[1]},${item.color[2]},${item.color[3]/255})`;

        chip.innerHTML = `
            <div class="chip-number">#${i + 1}</div>
            <div class="rgb-value">${item.color.slice(0,3).join(", ")}</div>
            <div class="count">${item.count}√ó</div>
        `;

        chip.addEventListener("dragstart", () => chip.classList.add("dragging"));
        chip.addEventListener("dragend", () => chip.classList.remove("dragging"));
        chip.addEventListener("dragover", e => e.preventDefault());
        chip.addEventListener("drop", e => {
            e.preventDefault();
            const dragging = document.querySelector(".dragging");
            if (dragging && dragging !== chip) {
                const all = [...palette.children];
                const from = all.indexOf(dragging);
                const to = all.indexOf(chip);

                if (from < to) chip.after(dragging);
                else chip.before(dragging);
            }
        });

        palette.appendChild(chip);
    });
}

window.onclick = e => {
    if (e.target.classList.contains("modal")) e.target.style.display = "none";
};

/* ==========================================================
   END SCRIPT
========================================================== */
</script>

</body>
</html>