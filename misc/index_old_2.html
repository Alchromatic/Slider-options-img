<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Art-AI Renderer - Selective Resolution</title>

<style>
body { font-family: Arial, sans-serif; max-width: 900px; margin: 20px auto; padding: 0 20px; }
.section { margin: 20px 0; }
h3 { margin: 10px 0; font-size: 16px; }
input[type="file"] { margin: 10px 0; }
.radio-group label { display: block; margin: 5px 0; }
button { padding: 8px 16px; margin: 5px; cursor: pointer; }
button.active { background: #4CAF50; color: white; }
.slider-container { margin: 15px 0; }
#slider, #colorGroupSlider { width: 100%; }
canvas { border: 2px solid #ccc; margin-top: 10px; display: block; cursor: crosshair; }
canvas.drawing { cursor: crosshair; }
.info { color: #666; font-size: 14px; }
.modal { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 1000; }
.modal-content { background: white; margin: 10% auto; padding: 20px; width: 500px; border-radius: 8px; max-height: 80vh; overflow-y: auto; }
.modal-content h3 { margin-top: 0; }
.modal-content textarea { width: 100%; height: 150px; font-family: monospace; font-size: 12px; }
.modal-buttons { margin-top: 10px; text-align: right; }
.color-palette { display: flex; flex-wrap: wrap; gap: 8px; margin: 15px 0; }
.color-chip { width: 80px; height: 80px; border-radius: 4px; cursor: move; border: 2px solid #333; display: flex; flex-direction: column; align-items: center; justify-content: center; font-size: 9px; color: white; text-shadow: 1px 1px 2px black; position: relative; box-shadow: 0 2px 4px rgba(0,0,0,0.2); }
.color-chip.dragging { opacity: 0.5; }
.color-chip:hover { border-color: #000; transform: scale(1.05); box-shadow: 0 4px 8px rgba(0,0,0,0.3); }
.color-chip .count { font-size: 8px; font-weight: bold; margin-top: 2px; background: rgba(0,0,0,0.7); padding: 2px 4px; border-radius: 3px; }
.color-chip .chip-number { background: rgba(0,0,0,0.7); padding: 2px 4px; border-radius: 3px; font-size: 9px; }
.color-chip .rgb-value { font-size: 7px; background: rgba(0,0,0,0.7); padding: 2px 3px; border-radius: 2px; margin-top: 2px; font-family: monospace; }
.frequency-info { margin: 10px 0; padding: 10px; background: #f5f5f5; border-radius: 4px; font-size: 13px; }
.region-box { position: absolute; pointer-events: none; }
.region-svg { position: absolute; pointer-events: none; overflow: visible; }
.region-list { margin: 10px 0; padding: 10px; background: #f0f0f0; border-radius: 4px; }
.region-item { display: flex; justify-content: space-between; align-items: center; padding: 5px; margin: 3px 0; background: white; border-radius: 3px; }
.region-item button { padding: 4px 8px; font-size: 12px; }
.highlight { background: #fff3cd; padding: 5px; border-radius: 3px; }
/* Color Picker Styles */
.color-picker-panel { 
    margin: 15px 0; 
    padding: 15px; 
    background: #f8f9fa; 
    border-radius: 8px; 
    border: 2px solid #dee2e6;
    display: none;
}
.color-picker-panel.active { display: block; }
.color-picker-header { 
    display: flex; 
    justify-content: space-between; 
    align-items: center; 
    margin-bottom: 10px;
}
.color-picker-header h4 { margin: 0; font-size: 14px; }
.color-preview-box {
    width: 60px;
    height: 60px;
    border: 3px solid #333;
    border-radius: 8px;
    box-shadow: 0 2px 8px rgba(0,0,0,0.2);
}
.color-details {
    display: grid;
    grid-template-columns: repeat(2, 1fr);
    gap: 8px;
    margin-top: 10px;
}
.color-detail-item {
    background: white;
    padding: 8px 12px;
    border-radius: 4px;
    font-size: 13px;
    border: 1px solid #e0e0e0;
}
.color-detail-item label {
    font-weight: bold;
    color: #666;
    font-size: 11px;
    display: block;
    margin-bottom: 2px;
}
.color-detail-item span {
    font-family: monospace;
    font-size: 14px;
}
.shape-highlight {
    pointer-events: none;
}
canvas.picking { cursor: crosshair; }
#colorPickerBtn.active { background: #00BCD4; color: white; }

/* Color Matcher Styles */
.color-matcher-section {
    margin-top: 15px;
    padding-top: 15px;
    border-top: 1px dashed #dee2e6;
}
.color-matcher-section h5 {
    margin: 0 0 10px 0;
    font-size: 13px;
    color: #495057;
}
.color-matcher-input {
    width: 100%;
    height: 80px;
    font-family: monospace;
    font-size: 11px;
    padding: 8px;
    border: 1px solid #ced4da;
    border-radius: 4px;
    resize: vertical;
    margin-bottom: 8px;
}
.color-matcher-input:focus {
    outline: none;
    border-color: #00BCD4;
    box-shadow: 0 0 0 2px rgba(0, 188, 212, 0.15);
}
#matchColorsBtn {
    background: #673AB7;
    color: white;
    border: none;
    padding: 8px 16px;
    border-radius: 4px;
    cursor: pointer;
    font-size: 13px;
    width: 100%;
}
#matchColorsBtn:hover { background: #5E35B1; }
#matchColorsBtn:disabled { background: #ccc; cursor: not-allowed; }

.match-results {
    margin-top: 12px;
    max-height: 250px;
    overflow-y: auto;
}
.match-results-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 8px;
    font-size: 12px;
    color: #666;
}
.match-result-item {
    display: flex;
    align-items: center;
    gap: 10px;
    padding: 8px;
    background: white;
    border: 1px solid #e0e0e0;
    border-radius: 4px;
    margin-bottom: 6px;
    transition: border-color 0.2s;
}
.match-result-item:hover {
    border-color: #00BCD4;
}
.match-result-item.best-match {
    border: 2px solid #4CAF50;
    background: linear-gradient(135deg, rgba(76, 175, 80, 0.08) 0%, rgba(76, 175, 80, 0.02) 100%);
}
.match-color-swatch {
    width: 36px;
    height: 36px;
    border-radius: 4px;
    border: 1px solid #333;
    flex-shrink: 0;
}
.match-info {
    flex: 1;
    min-width: 0;
}
.match-hex {
    font-family: monospace;
    font-size: 12px;
    font-weight: 600;
}
.match-delta {
    font-size: 10px;
    color: #888;
}
.match-percentage {
    text-align: right;
}
.match-percentage-value {
    font-size: 18px;
    font-weight: bold;
}
.match-percentage-value.high { color: #4CAF50; }
.match-percentage-value.medium { color: #FF9800; }
.match-percentage-value.low { color: #f44336; }
.match-percentage-label {
    font-size: 9px;
    color: #888;
    text-transform: uppercase;
}
.best-badge {
    display: inline-block;
    background: #4CAF50;
    color: white;
    font-size: 9px;
    font-weight: bold;
    padding: 2px 6px;
    border-radius: 3px;
    margin-left: 6px;
    text-transform: uppercase;
}
.match-progress-bar {
    width: 100%;
    height: 4px;
    background: #e0e0e0;
    border-radius: 2px;
    margin-top: 4px;
    overflow: hidden;
}
.match-progress-fill {
    height: 100%;
    border-radius: 2px;
    transition: width 0.3s ease;
}
.match-progress-fill.high { background: #4CAF50; }
.match-progress-fill.medium { background: #FF9800; }
.match-progress-fill.low { background: #f44336; }
.match-error {
    background: #ffebee;
    border: 1px solid #ffcdd2;
    color: #c62828;
    padding: 10px;
    border-radius: 4px;
    font-size: 12px;
    text-align: center;
}
.match-empty {
    text-align: center;
    padding: 20px;
    color: #888;
    font-size: 12px;
}
.threshold-control {
    display: flex;
    align-items: center;
    gap: 8px;
    margin-bottom: 8px;
    font-size: 11px;
    color: #666;
}
.threshold-control input[type="range"] {
    flex: 1;
    height: 4px;
}
.threshold-control span {
    min-width: 35px;
    text-align: right;
    font-family: monospace;
}
/* Palette Preset Styles */
.palette-preset-section {
    margin: 15px 0;
    padding: 15px;
    background: #f8f9fa;
    border-radius: 8px;
    border: 2px solid #dee2e6;
}
.palette-preset-section h4 {
    margin: 0 0 10px 0;
    font-size: 14px;
    color: #495057;
}
.palette-preset-controls {
    display: flex;
    gap: 10px;
    align-items: center;
}
.palette-preset-controls select {
    flex: 1;
    padding: 8px 12px;
    border: 1px solid #ced4da;
    border-radius: 4px;
    font-size: 13px;
    background: white;
    cursor: pointer;
}
.palette-preset-controls select:focus {
    outline: none;
    border-color: #673AB7;
    box-shadow: 0 0 0 2px rgba(103, 58, 183, 0.15);
}
.palette-preset-controls button {
    background: #673AB7;
    color: white;
    border: none;
    padding: 8px 16px;
    border-radius: 4px;
    cursor: pointer;
    font-size: 13px;
}
.palette-preset-controls button:hover {
    background: #5E35B1;
}
.palette-preset-controls button:disabled {
    background: #ccc;
    cursor: not-allowed;
}


/* iPhone-style Image Adjustments */
.adjust-section {
    margin: 20px 0;
    padding: 0;
    background: #f2f2f7;
    border-radius: 12px;
    overflow: hidden;
}
.adjust-container {
    background: #fff;
    padding: 20px 0 0 0;
    position: relative;
}
/* Horizontal scrollable icons strip */
.adjust-icons-wrapper {
    position: relative;
    padding: 0 40px;
}
.adjust-icons-scroll {
    display: flex;
    overflow-x: auto;
    scroll-snap-type: x mandatory;
    -webkit-overflow-scrolling: touch;
    padding: 10px 0 15px 0;
    gap: 20px;
    scrollbar-width: none;
    -ms-overflow-style: none;
}
.adjust-icons-scroll::-webkit-scrollbar {
    display: none;
}
.adjust-icon-btn {
    flex: 0 0 auto;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 4px;
    background: none;
    border: none;
    cursor: pointer;
    scroll-snap-align: center;
    padding: 0;
    min-width: 70px;
}
.adjust-icon-circle {
    width: 58px;
    height: 58px;
    border-radius: 50%;
    border: 2px solid #d1d1d6;
    display: flex;
    align-items: center;
    justify-content: center;
    background: #fff;
    transition: all 0.2s;
    position: relative;
}
.adjust-icon-btn.active .adjust-icon-circle {
    border-color: #333;
    border-width: 2px;
}
.adjust-icon-btn.modified .adjust-icon-circle::after {
    content: '';
    position: absolute;
    bottom: -2px;
    left: 50%;
    transform: translateX(-50%);
    width: 6px;
    height: 6px;
    background: #ffd60a;
    border-radius: 50%;
}
.adjust-icon-circle svg {
    width: 28px;
    height: 28px;
    fill: none;
    stroke: #000;
    stroke-width: 1.5;
}
.adjust-icon-circle img {
    width: 32px;
    height: 32px;
}
/* Scroll arrows */
.adjust-scroll-arrow {
    position: absolute;
    top: 50%;
    transform: translateY(-60%);
    width: 32px;
    height: 58px;
    background: linear-gradient(to right, rgba(255,255,255,1), rgba(255,255,255,0));
    border: none;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    z-index: 10;
    font-size: 24px;
    color: #c7c7cc;
    transition: opacity 0.2s;
}
.adjust-scroll-arrow:hover {
    color: #8e8e93;
}
.adjust-scroll-arrow.left {
    left: 0;
    background: linear-gradient(to right, rgba(255,255,255,1), rgba(255,255,255,0));
    padding-left: 5px;
}
.adjust-scroll-arrow.right {
    right: 0;
    background: linear-gradient(to left, rgba(255,255,255,1), rgba(255,255,255,0));
    padding-right: 5px;
}
/* Ruler slider */
.adjust-ruler-container {
    padding: 0 20px 20px 20px;
}
.adjust-ruler {
    position: relative;
    height: 50px;
    display: flex;
    align-items: center;
    justify-content: center;
}
.adjust-ruler-ticks {
    display: flex;
    align-items: flex-end;
    justify-content: center;
    gap: 4px;
    height: 30px;
    width: 100%;
    max-width: 400px;
}
.adjust-ruler-tick {
    width: 1px;
    background: #d1d1d6;
    transition: background 0.2s;
}
.adjust-ruler-tick.small {
    height: 8px;
}
.adjust-ruler-tick.medium {
    height: 14px;
}
.adjust-ruler-tick.large {
    height: 20px;
    background: #8e8e93;
}
.adjust-ruler-tick.center {
    height: 28px;
    width: 2px;
    background: #000;
}
.adjust-ruler-tick.active {
    background: #000;
}
.adjust-slider-hidden {
    position: absolute;
    width: 100%;
    max-width: 400px;
    height: 50px;
    opacity: 0;
    cursor: pointer;
    z-index: 5;
}
.adjust-value-display {
    text-align: center;
    font-size: 13px;
    color: #8e8e93;
    margin-top: 5px;
    font-weight: 500;
    min-height: 18px;
}
/* Reset button */
.adjust-reset-btn {
    background: none;
    color: #007AFF;
    border: none;
    padding: 8px 16px;
    cursor: pointer;
    font-size: 14px;
    font-weight: 400;
    position: absolute;
    right: 15px;
    top: 15px;
}
.adjust-reset-btn:hover {
    text-decoration: underline;
}
/* Icon specific styling for special icons */
.adjust-icon-circle.auto-enhance {
    background: #c7c7cc;
    border-color: #c7c7cc;
}
.adjust-icon-circle.auto-enhance svg {
    stroke: #000;
}
.adjust-icon-circle.color-wheel {
    background: conic-gradient(red, yellow, lime, aqua, blue, magenta, red);
    border-color: transparent;
    overflow: hidden;
}
.adjust-icon-circle.color-wheel::before {
    content: '';
    position: absolute;
    width: 30px;
    height: 30px;
    background: #fff;
    border-radius: 50%;
}
.adjust-icon-circle.color-stripes {
    overflow: hidden;
    border-color: transparent;
    padding: 0;
}
.color-stripes-inner {
    width: 100%;
    height: 100%;
    display: flex;
}
.color-stripes-inner span {
    flex: 1;
    height: 100%;
}
/* Selected adjustment label */
.adjust-selected-label {
    text-align: center;
    font-size: 15px;
    font-weight: 600;
    color: #000;
    padding: 10px 0 5px 0;
    min-height: 25px;
}
/* Unmix / Recipe Styles */
.unmix-section {
    margin-top: 15px;
    padding-top: 15px;
    border-top: 2px solid #4CAF50;
    background: linear-gradient(135deg, rgba(76, 175, 80, 0.05) 0%, rgba(76, 175, 80, 0.02) 100%);
    padding: 15px;
    border-radius: 0 0 8px 8px;
    margin: 0 -15px -15px -15px;
}
.unmix-section h5 {
    margin: 0 0 12px 0;
    font-size: 14px;
    color: #2E7D32;
    display: flex;
    align-items: center;
    gap: 8px;
}
.unmix-section h5::before {
    content: "üé®";
}
.unmix-controls {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 10px;
    margin-bottom: 12px;
}
.unmix-control-item {
    display: flex;
    flex-direction: column;
    gap: 4px;
}
.unmix-control-item label {
    font-size: 11px;
    color: #666;
    font-weight: 600;
}
.unmix-control-item input[type="number"] {
    padding: 6px 10px;
    border: 1px solid #ced4da;
    border-radius: 4px;
    font-size: 13px;
    width: 100%;
    box-sizing: border-box;
}
.unmix-control-item input[type="number"]:focus {
    outline: none;
    border-color: #4CAF50;
    box-shadow: 0 0 0 2px rgba(76, 175, 80, 0.15);
}
#getRecipeBtn {
    background: #4CAF50;
    color: white;
    border: none;
    padding: 10px 16px;
    border-radius: 4px;
    cursor: pointer;
    font-size: 13px;
    font-weight: 600;
    width: 100%;
    transition: background 0.2s;
}
#getRecipeBtn:hover { background: #43A047; }
#getRecipeBtn:disabled { background: #ccc; cursor: not-allowed; }

.recipe-results {
    margin-top: 12px;
}
.recipe-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 10px;
    padding-bottom: 8px;
    border-bottom: 1px solid #e0e0e0;
}
.recipe-header-left {
    display: flex;
    align-items: center;
    gap: 10px;
}
.recipe-target-swatch {
    width: 40px;
    height: 40px;
    border-radius: 4px;
    border: 2px solid #333;
}
.recipe-result-swatch {
    width: 40px;
    height: 40px;
    border-radius: 4px;
    border: 2px solid #333;
}
.recipe-arrow {
    font-size: 20px;
    color: #666;
}
.recipe-match-info {
    text-align: right;
}
.recipe-match-value {
    font-size: 24px;
    font-weight: bold;
}
.recipe-match-value.high { color: #4CAF50; }
.recipe-match-value.medium { color: #FF9800; }
.recipe-match-value.low { color: #f44336; }
.recipe-match-label {
    font-size: 10px;
    color: #888;
}
.recipe-method {
    font-size: 10px;
    color: #666;
    background: #f0f0f0;
    padding: 2px 6px;
    border-radius: 3px;
    margin-top: 2px;
}
.recipe-components {
    display: flex;
    flex-direction: column;
    gap: 8px;
}
.recipe-component {
    display: flex;
    align-items: center;
    gap: 10px;
    padding: 10px;
    background: white;
    border: 1px solid #e0e0e0;
    border-radius: 6px;
    transition: border-color 0.2s;
}
.recipe-component:hover {
    border-color: #4CAF50;
}
.recipe-component-swatch {
    width: 44px;
    height: 44px;
    border-radius: 4px;
    border: 2px solid #333;
    flex-shrink: 0;
}
.recipe-component-info {
    flex: 1;
    min-width: 0;
}
.recipe-component-name {
    font-weight: 600;
    font-size: 13px;
    color: #333;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}
.recipe-component-hex {
    font-family: monospace;
    font-size: 11px;
    color: #666;
}
.recipe-component-amount {
    text-align: right;
    flex-shrink: 0;
}
.recipe-component-parts {
    font-size: 20px;
    font-weight: bold;
    color: #333;
}
.recipe-component-parts-label {
    font-size: 10px;
    color: #888;
}
.recipe-component-percent {
    font-size: 12px;
    color: #4CAF50;
    font-weight: 600;
}
.recipe-total {
    margin-top: 10px;
    padding-top: 10px;
    border-top: 1px dashed #ccc;
    font-size: 12px;
    color: #666;
    text-align: center;
}
.recipe-empty {
    text-align: center;
    padding: 20px;
    color: #888;
    font-size: 12px;
}
.recipe-error {
    background: #ffebee;
    border: 1px solid #ffcdd2;
    color: #c62828;
    padding: 10px;
    border-radius: 4px;
    font-size: 12px;
    text-align: center;
}

/* Shape Checkbox Styles */
.shape-checkbox {
    display: flex;
    align-items: center;
    gap: 4px;
    font-size: 11px;
    color: #333;
    cursor: pointer;
    padding: 4px 8px;
    background: white;
    border: 1px solid #ccc;
    border-radius: 4px;
    transition: all 0.2s;
}
.shape-checkbox:hover {
    border-color: #7c4dff;
}
.shape-checkbox input:checked + span {
    color: #7c4dff;
    font-weight: 600;
}
.shape-checkbox:has(input:checked) {
    border-color: #7c4dff;
    background: #f3e5f5;
}

/* Main Tabs Container */
.main-tabs {
    display: flex;
    gap: 0;
    margin-bottom: 0;
    border-bottom: 2px solid #dee2e6;
}
.main-tab-btn {
    padding: 12px 24px;
    background: #f0f0f0;
    border: none;
    border-bottom: 3px solid transparent;
    cursor: pointer;
    font-size: 14px;
    font-weight: 600;
    color: #666;
    transition: all 0.2s;
}
.main-tab-btn:hover {
    background: #e8e8e8;
    color: #333;
}
.main-tab-btn.active {
    background: white;
    color: #7c4dff;
    border-bottom-color: #7c4dff;
}
.main-tab-content {
    display: none;
    padding: 20px 0;
}
.main-tab-content.active {
    display: block;
}

/* Rendering Logic Icons Strip */
.rendering-icons-strip {
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
    padding: 15px;
    background: #f8f9fa;
    border-radius: 8px;
    margin-bottom: 15px;
}
.rendering-icon-btn {
    width: 48px;
    height: 48px;
    border: 2px solid #d1d1d6;
    border-radius: 8px;
    background: white;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.2s;
    position: relative;
}
.rendering-icon-btn:hover {
    border-color: #7c4dff;
    transform: scale(1.05);
}
.rendering-icon-btn.active {
    border-color: #7c4dff;
    background: #f3e5f5;
    box-shadow: 0 0 0 2px rgba(124, 77, 255, 0.2);
}
.rendering-icon-btn svg {
    width: 24px;
    height: 24px;
    stroke: #333;
    stroke-width: 1.5;
    fill: none;
}
.rendering-icon-btn.active svg {
    stroke: #7c4dff;
}
.rendering-icon-btn[title]::after {
    content: attr(title);
    position: absolute;
    bottom: -25px;
    left: 50%;
    transform: translateX(-50%);
    background: #333;
    color: white;
    padding: 2px 6px;
    border-radius: 3px;
    font-size: 10px;
    white-space: nowrap;
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.2s;
    z-index: 100;
}
.rendering-icon-btn:hover[title]::after {
    opacity: 1;
}

/* Selective Resolution Icon - Special styling */
#selectiveResolutionIcon {
    border-color: #2196F3;
    background: linear-gradient(135deg, #e3f2fd 0%, #fff 100%);
}
#selectiveResolutionIcon:hover {
    border-color: #1565C0;
    background: linear-gradient(135deg, #bbdefb 0%, #e3f2fd 100%);
}
#selectiveResolutionIcon.active {
    border-color: #1565C0;
    background: linear-gradient(135deg, #bbdefb 0%, #e3f2fd 100%);
    box-shadow: 0 0 0 2px rgba(33, 150, 243, 0.3);
}
#selectiveResolutionIcon svg {
    stroke: #2196F3;
}

/* Slider Container for Rendering */
.rendering-slider-container {
    margin: 15px 0;
    padding: 15px;
    background: #f8f9fa;
    border-radius: 8px;
}
.rendering-slider-container label {
    font-size: 12px;
    color: #666;
    font-weight: 600;
    display: block;
    margin-bottom: 8px;
}
.rendering-slider-container input[type="range"] {
    width: 100%;
}

/* Drag & Drop Inline Container */
.drag-drop-inline {
    margin-top: 15px;
    padding: 15px;
    background: #fff;
    border: 1px solid #dee2e6;
    border-radius: 8px;
    display: none;
}
.drag-drop-inline.active {
    display: block;
}
.drag-drop-inline h4 {
    margin: 0 0 10px 0;
    font-size: 13px;
    color: #495057;
}
.drag-drop-inline .color-palette {
    max-height: 200px;
    overflow-y: auto;
}

/* Sequence Filter Styles */
.sequence-filter-section {
    margin-top: 15px;
    padding: 15px;
    background: #fff3e0;
    border: 1px solid #ffcc80;
    border-radius: 8px;
}
.sequence-filter-section h4 {
    margin: 0 0 10px 0;
    font-size: 13px;
    color: #e65100;
}
.sequence-filter-chips {
    display: flex;
    flex-wrap: wrap;
    gap: 6px;
    max-height: 150px;
    overflow-y: auto;
}
.sequence-filter-chip {
    width: 36px;
    height: 36px;
    border-radius: 4px;
    border: 2px solid #ccc;
    cursor: pointer;
    transition: all 0.2s;
    position: relative;
}
.sequence-filter-chip:hover {
    transform: scale(1.1);
    border-color: #333;
}
.sequence-filter-chip.selected {
    border-color: #e65100;
    box-shadow: 0 0 0 3px rgba(230, 81, 0, 0.3);
}
.sequence-filter-chip.selected::after {
    content: '‚úì';
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    color: white;
    font-weight: bold;
    text-shadow: 0 0 3px black;
}
.sequence-filter-chip .chip-counter {
    position: absolute;
    bottom: -6px;
    right: -6px;
    background: #333;
    color: white;
    font-size: 9px;
    font-weight: bold;
    padding: 2px 4px;
    border-radius: 8px;
    min-width: 14px;
    text-align: center;
    line-height: 1;
    box-shadow: 0 1px 3px rgba(0,0,0,0.3);
}
.sequence-filter-actions {
    margin-top: 10px;
    display: flex;
    gap: 10px;
}
.sequence-filter-actions button {
    padding: 6px 12px;
    font-size: 12px;
}
#clearFilterBtn {
    background: #ff5722;
    color: white;
    border: none;
    border-radius: 4px;
    cursor: pointer;
}
#clearFilterBtn:hover {
    background: #e64a19;
}
.sort-btn {
    padding: 4px 10px;
    font-size: 11px;
    border: 1px solid #ccc;
    background: #fff;
    border-radius: 4px;
    cursor: pointer;
    transition: all 0.2s;
}
.sort-btn:hover {
    border-color: #e65100;
    background: #fff3e0;
}
.sort-btn.active {
    background: #e65100;
    color: white;
    border-color: #e65100;
}
.slider-mode-btn {
    padding: 4px 10px;
    font-size: 11px;
    border: 1px solid #ccc;
    background: #fff;
    border-radius: 4px;
    cursor: pointer;
    transition: all 0.2s;
}
.slider-mode-btn:hover {
    border-color: #1976d2;
    background: #e3f2fd;
}
.slider-mode-btn.active {
    background: #1976d2;
    color: white;
    border-color: #1976d2;
}

/* Shape Type Validation */
.shape-type-error {
    color: #c62828;
    font-size: 11px;
    margin-top: 4px;
    display: none;
}
.shape-type-error.visible {
    display: block;
}
</style>
<script type="application/json" id="colorsData">
{
    "Common Color Names & Values": [
        [255, 127, 80], [178, 34, 34], [34, 139, 34], [255, 215, 0], [124, 252, 0],
        [128, 0, 0], [25, 25, 112], [0, 0, 128], [128, 128, 0], [107, 142, 35],
        [205, 133, 63], [139, 69, 19], [46, 139, 87]
    ],
    "Artisan - Winsor & Newton": [
        [58, 22, 14], [50, 27, 15], [221, 63, 0], [171, 0, 5], [221, 63, 0],
        [229, 42, 0], [166, 0, 9], [255, 139, 0], [255, 194, 0], [255, 161, 0],
        [0, 97, 102], [0, 74, 91], [0, 39, 71], [21, 15, 17], [8, 8, 32],
        [27, 28, 28], [21, 21, 20], [239, 173, 0], [98, 4, 32], [74, 1, 16],
        [130, 0, 24], [28, 42, 10], [17, 12, 37], [0, 32, 24], [3, 26, 33],
        [15, 11, 11], [117, 70, 17], [37, 26, 20], [0, 53, 40], [187, 128, 18]
    ],
    "Artists Oil - Winsor & Newton": [
        [68, 2, 6], [255, 232, 0], [197, 0, 15], [82, 42, 31], [255, 222, 0],
        [204, 12, 22], [255, 164, 0], [255, 127, 15], [0, 41, 117], [46, 90, 76],
        [0, 99, 127], [78, 23, 80], [50, 61, 164], [168, 113, 37], [71, 74, 14],
        [144, 87, 0], [119, 85, 26], [33, 23, 57], [16, 15, 17], [26, 27, 27],
        [235, 215, 84], [39, 38, 39], [222, 156, 72], [47, 43, 32], [57, 95, 58],
        [84, 2, 17], [71, 16, 26], [68, 50, 73], [34, 24, 24], [18, 28, 41],
        [108, 8, 36], [144, 32, 40], [130, 83, 39], [64, 49, 35], [69, 53, 53],
        [213, 33, 22], [146, 75, 63], [38, 59, 47], [149, 66, 40], [233, 162, 0],
        [70, 21, 17], [62, 38, 126], [39, 27, 19], [127, 49, 29], [0, 62, 53],
        [0, 134, 84], [0, 50, 40], [0, 60, 33], [248, 65, 0], [129, 0, 24],
        [255, 204, 0], [255, 145, 0], [29, 23, 41], [151, 104, 47]
    ],
    "Createx Airbrush Colors": [
        [164, 129, 99], [130, 107, 92], [120, 90, 76], [100, 74, 66], [133, 94, 41],
        [119, 47, 47], [108, 45, 36], [61, 52, 50], [68, 57, 57], [55, 46, 59],
        [85, 43, 36], [36, 31, 42], [91, 55, 54], [78, 56, 47], [42, 36, 49],
        [71, 62, 62], [100, 79, 68], [53, 53, 63], [63, 58, 52], [114, 98, 98]
    ],
    "Sennelier": [
        [68, 47, 38], [50, 42, 33], [125, 80, 35], [95, 40, 20], [168, 110, 40],
        [235, 166, 51], [0, 90, 136], [36, 68, 131], [15, 12, 79], [22, 17, 54],
        [35, 41, 42], [56, 55, 68], [66, 35, 26], [251, 214, 0], [255, 210, 0],
        [255, 155, 0], [251, 223, 0], [255, 131, 0], [214, 159, 0], [230, 124, 0],
        [202, 20, 19], [163, 0, 28], [178, 0, 18], [242, 76, 0], [206, 14, 7],
        [131, 7, 23], [139, 16, 26], [78, 42, 43], [59, 29, 27], [25, 25, 24],
        [22, 20, 18], [74, 112, 66], [0, 46, 37], [34, 45, 48], [8, 76, 60],
        [0, 68, 59], [57, 20, 65], [28, 25, 41], [57, 57, 55], [73, 28, 39],
        [65, 30, 69]
    ],
    "System 3 Original Acrylic - Dal": [
        [51, 49, 50], [49, 49, 49], [43, 91, 192], [51, 48, 80], [46, 46, 60],
        [49, 45, 81], [123, 62, 51], [75, 60, 55], [67, 60, 55], [46, 62, 52],
        [38, 58, 58], [81, 117, 76], [42, 75, 49], [57, 51, 53], [138, 47, 68],
        [189, 45, 44], [159, 43, 44], [210, 45, 37], [238, 139, 0], [227, 71, 37],
        [241, 222, 0], [189, 137, 62], [163, 105, 59], [254, 208, 0]
    ],
    "Vallejo Acrylic Studio": [
        [246, 226, 0], [172, 23, 28], [143, 27, 37], [42, 41, 77], [39, 33, 78],
        [22, 47, 53], [194, 134, 33], [134, 55, 45], [48, 47, 47], [223, 132, 0],
        [43, 38, 39], [220, 58, 34], [37, 52, 40], [96, 81, 62], [82, 59, 51],
        [163, 109, 40], [131, 63, 45], [255, 187, 0], [125, 16, 61], [50, 97, 192],
        [114, 29, 30], [251, 205, 0], [148, 43, 32], [40, 39, 51]
    ]
}
</script>
</head>

<body>
<h2>Art-AI Renderer - Selective Resolution</h2>

<!-- Main Tabs Navigation -->
<div class="main-tabs">
    <button class="main-tab-btn active" data-tab="tab-addimage">Add Image</button>
    <button class="main-tab-btn" data-tab="tab-adjust">Adjust</button>
</div>

<!-- TAB 1: Add Image (Generate from Image) -->
<div id="tab-addimage" class="main-tab-content active">
<!-- ========================== GEOMETRIZE (Client-Side) ========================= -->
<div class="section" style="background: linear-gradient(135deg, #e3f2fd 0%, #f3e5f5 100%); padding: 20px; border-radius: 8px; border: 2px solid #7c4dff;">
    <h3 style="color: #512da8; margin-top: 0;">Generate from Image</h3>
    <div class="info" style="margin-bottom: 15px;">Upload an image to convert it into geometric shapes.</div>
    
    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-bottom: 15px;">
        <div>
            <label style="font-weight: bold; font-size: 12px; color: #666;">Image File:</label>
            <input type="file" id="geometrizeInput" accept="image/*" style="width: 100%; margin-top: 5px;">
        </div>
        <div>
            <label style="font-weight: bold; font-size: 12px; color: #666;">Number of Shapes:</label>
            <input type="number" id="geometrizeShapeCount" value="200" min="10" max="2000" style="width: 100%; padding: 8px; margin-top: 5px; border: 1px solid #ccc; border-radius: 4px;">
        </div>
    </div>
    
    <!-- Advanced Settings Panel -->
    <div style="background: #f0f4f8; border: 1px solid #d0d7de; border-radius: 6px; padding: 12px; margin: 12px 0;">
        <h4 style="margin: 0 0 10px 0; font-size: 13px; color: #495057;">Advanced Settings</h4>
        <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px;">
            <!-- Shape Types -->
            <div style="grid-column: span 2;">
                <label style="font-size: 11px; color: #666; font-weight: 600;">Shape Types (select multiple):</label>
                <div id="shapeTypeCheckboxes" style="display: flex; flex-wrap: wrap; gap: 8px; margin-top: 4px;">
                    <label class="shape-checkbox"><input type="checkbox" name="shapeType" value="0"> <span>Rectangle</span></label>
                    <label class="shape-checkbox"><input type="checkbox" name="shapeType" value="1"> <span>Rotated Rect</span></label>
                    <label class="shape-checkbox"><input type="checkbox" name="shapeType" value="2" checked> <span>Triangle</span></label>
                    <label class="shape-checkbox"><input type="checkbox" name="shapeType" value="3"> <span>Ellipse</span></label>
                    <label class="shape-checkbox"><input type="checkbox" name="shapeType" value="4"> <span>Rotated Ellipse</span></label>
                    <label class="shape-checkbox"><input type="checkbox" name="shapeType" value="5"> <span>Circle</span></label>
                    <label class="shape-checkbox"><input type="checkbox" name="shapeType" value="6"> <span>Line</span></label>
                    <label class="shape-checkbox"><input type="checkbox" name="shapeType" value="7"> <span>Bezier</span></label>
                </div>
                <div id="shapeTypeError" class="shape-type-error">Please select at least one shape type</div>
            </div>
            <!-- Alpha -->
            <div>
                <label style="font-size: 11px; color: #666; font-weight: 600;">Alpha (Opacity): <span id="alphaDisplayValue" style="font-family: monospace;">128</span></label>
                <input type="range" id="geometrizeAlpha" min="1" max="255" value="128" style="width: 100%;">
            </div>
            <!-- Candidates Per Step -->
            <div>
                <label style="font-size: 11px; color: #666; font-weight: 600;">Candidates Per Step: <span id="candidatesValue" style="font-family: monospace;">50</span></label>
                <input type="range" id="geometrizeCandidates" min="10" max="500" value="50" style="width: 100%;">
            </div>
            <!-- Mutations Per Step -->
            <div>
                <label style="font-size: 11px; color: #666; font-weight: 600;">Mutations Per Step: <span id="mutationsValue" style="font-family: monospace;">100</span></label>
                <input type="range" id="geometrizeMutations" min="10" max="500" value="100" style="width: 100%;">
            </div>
            <!-- Load Result As -->
            <div>
                <label style="font-size: 11px; color: #666; font-weight: 600;">Load Result As:</label>
                <div style="display: flex; gap: 15px; margin-top: 4px;">
                    <label style="display: flex; align-items: center; gap: 6px; cursor: pointer; font-size: 12px;">
                        <input type="radio" name="geometrizeTarget" value="base" checked>
                        <span>Base (Low-res)</span>
                    </label>
                    <label style="display: flex; align-items: center; gap: 6px; cursor: pointer; font-size: 12px;">
                        <input type="radio" name="geometrizeTarget" value="detail">
                        <span>Detail (High-res)</span>
                    </label>
                </div>
            </div>
        </div>
    </div>
    
    <button id="geometrizeBtn" style="background: #7c4dff; color: white; padding: 12px 24px; border: none; border-radius: 4px; cursor: pointer; font-size: 14px; font-weight: bold; width: 100%;">
        Generate Shapes
    </button>
    <button id="stopGeometrizeBtn" style="background: #f44336; color: white; padding: 10px 20px; border: none; border-radius: 4px; cursor: pointer; font-size: 13px; margin-top: 10px; width: 100%; display: none;">
        Stop Processing
    </button>
    
    <!-- Progress Bar -->
    <div id="progressContainer" style="margin-top: 10px; display: none;">
        <div style="width: 100%; height: 20px; background: #e0e0e0; border-radius: 10px; overflow: hidden;">
            <div id="progressFill" style="height: 100%; background: linear-gradient(90deg, #7c4dff, #b388ff); border-radius: 10px; transition: width 0.1s ease; width: 0%;"></div>
        </div>
        <div id="progressText" style="text-align: center; font-size: 12px; color: #666; margin-top: 5px;">Processing: 0 / 0 shapes</div>
    </div>
    
    <!-- Live Preview -->
    <canvas id="geometrizePreview" width="300" height="300" style="border: 1px solid #ccc; border-radius: 4px; margin-top: 10px; max-width: 100%; display: none;"></canvas>
    
    <button id="downloadJsonBtn" style="background: #4CAF50; color: white; padding: 10px 20px; border: none; border-radius: 4px; cursor: pointer; font-size: 13px; margin-top: 10px; width: 100%;" disabled>
        Download JSON
    </button>
    
    <!-- LINE DRAWING MODE -->
    <div style="margin-top: 15px; padding-top: 15px; border-top: 2px dashed #ff9800;">
        <h4 style="color: #e65100; margin: 0 0 10px 0; font-size: 14px;">üìù Line Drawing Mode</h4>
        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-bottom: 10px;">
            <div>
                <label style="font-size: 11px; color: #666;">Style:</label>
                <select id="lineDrawingStyle" style="width: 100%; padding: 6px; border: 1px solid #ccc; border-radius: 4px; font-size: 12px;">
                    <option value="sketch">Pencil Sketch</option>
                    <option value="detailed" selected>Detailed Sketch</option>
                    <option value="crosshatch">Cross-Hatch Style</option>
                    <option value="architectural">Architectural</option>
                </select>
            </div>
            <div>
                <label style="font-size: 11px; color: #666;">Detail: <span id="ldDetailVal">80</span>%</label>
                <input type="range" id="lineDrawingDetail" min="20" max="100" value="80" style="width: 100%;">
            </div>
        </div>
        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-bottom: 10px;">
            <div>
                <label style="font-size: 11px; color: #666;">Line Weight: <span id="ldWeightVal">2</span></label>
                <input type="range" id="lineDrawingWeight" min="1" max="4" value="2" style="width: 100%;">
            </div>
            <div style="display: flex; align-items: end;">
                <label style="font-size: 11px; color: #666; display: flex; align-items: center; gap: 5px;">
                    <input type="checkbox" id="lineDrawingGrid"> Show Grid Lines
                </label>
            </div>
        </div>
        <button id="generateLineDrawingBtn" style="background: linear-gradient(135deg, #ff9800, #f57c00); color: white; padding: 10px 20px; border: none; border-radius: 4px; cursor: pointer; font-size: 13px; font-weight: bold; width: 100%;">
            Generate Line Drawing
        </button>
        <button id="downloadLineDrawingBtn" style="background: #607D8B; color: white; padding: 8px 16px; border: none; border-radius: 4px; cursor: pointer; font-size: 12px; margin-top: 8px; width: 100%; display: none;">
            Download Line Drawing PNG
        </button>
    </div>
    
    <div id="geometrizeStatus" class="info" style="margin-top: 10px; text-align: center;"></div>
</div>

<!-- ========================== LOAD JSON ========================= -->
<div class="section">
    <h3>Load JSON Files</h3>

    <label>Base (Low-res):</label>
    <input type="file" id="baseFileInput" accept=".json">
    <span id="baseFileStatus" class="info"></span>
    
    <label>Detail (High-res):</label>
    <input type="file" id="detailFileInput" accept=".json">
    <span id="detailFileStatus" class="info"></span>
</div>

<!-- ====================== SELECTIVE RESOLUTION =================== -->
<div class="section highlight">
    <h3>Selective Resolution Tool</h3>
    <div class="info">Draw freehand on the canvas to select regions, then click the enhance icon (or button below) to add more detail to those areas.</div>

    <button id="selectRegionsBtn">Select Regions for Detail</button>
    <button id="clearRegionsBtn">Clear All Regions</button>
    <button id="applyEnhanceBtn" style="background: #4CAF50; color: white;" onclick="enhanceSelectedRegions()">Enhance Selected Regions</button>
    
    <div id="enhanceProgress" style="display: none; margin-top: 10px;">
        <div style="background: #e0e0e0; border-radius: 4px; overflow: hidden;">
            <div id="enhanceProgressFill" style="height: 20px; background: #4CAF50; width: 0%; transition: width 0.3s;"></div>
        </div>
        <div id="enhanceProgressText" style="font-size: 12px; color: #666; margin-top: 5px;">Generating detail shapes...</div>
    </div>

    <div class="region-list" id="regionList" style="display:none;"></div>
</div>
</div><!-- END TAB 1 -->

<!-- TAB 2: Adjust (Rendering Logic + Color Picker + Adjustments) -->
<div id="tab-adjust" class="main-tab-content">

<!-- ====================== RENDERING LOGIC (Icon-Based) ======================== -->
<div class="section">
    <h3>Rendering Logic</h3>
    <div class="info" style="margin-bottom: 10px;">Select a rendering order for shapes.</div>
    
    <!-- Icons Strip for Rendering Logic -->
    <div class="rendering-icons-strip">
        <button class="rendering-icon-btn active" data-logic="original" title="Original Order">
            <svg viewBox="0 0 24 24"><rect x="4" y="4" width="16" height="16" rx="2"/><line x1="8" y1="9" x2="16" y2="9"/><line x1="8" y1="12" x2="16" y2="12"/><line x1="8" y1="15" x2="16" y2="15"/></svg>
        </button>
        <button class="rendering-icon-btn" data-logic="exterior_to_center" title="Exterior ‚Üí Center">
            <svg viewBox="0 0 24 24"><circle cx="12" cy="12" r="9"/><circle cx="12" cy="12" r="5"/><circle cx="12" cy="12" r="2" fill="currentColor"/></svg>
        </button>
        <button class="rendering-icon-btn" data-logic="center_to_exterior" title="Center ‚Üí Exterior">
            <svg viewBox="0 0 24 24"><circle cx="12" cy="12" r="2" fill="currentColor"/><circle cx="12" cy="12" r="5"/><circle cx="12" cy="12" r="9"/></svg>
        </button>
        <button class="rendering-icon-btn" data-logic="top_to_bottom" title="Top ‚Üí Bottom">
            <svg viewBox="0 0 24 24"><line x1="12" y1="3" x2="12" y2="21"/><polyline points="6,15 12,21 18,15"/></svg>
        </button>
        <button class="rendering-icon-btn" data-logic="bottom_to_top" title="Bottom ‚Üí Top">
            <svg viewBox="0 0 24 24"><line x1="12" y1="21" x2="12" y2="3"/><polyline points="6,9 12,3 18,9"/></svg>
        </button>
        <button class="rendering-icon-btn" data-logic="color_sequence" title="Color Sequence">
            <svg viewBox="0 0 24 24"><rect x="3" y="3" width="6" height="6" fill="#ff6b6b" stroke="none"/><rect x="9" y="3" width="6" height="6" fill="#4ecdc4" stroke="none"/><rect x="15" y="3" width="6" height="6" fill="#45b7d1" stroke="none"/><rect x="3" y="9" width="18" height="12" rx="1"/></svg>
        </button>
        <button class="rendering-icon-btn" data-logic="light_to_dark" title="Light ‚Üí Dark">
            <svg viewBox="0 0 24 24"><rect x="3" y="3" width="18" height="18" rx="2"/><path d="M3 3 L21 21" stroke-width="2"/><rect x="3" y="3" width="9" height="18" fill="white" stroke="none"/></svg>
        </button>
        <button class="rendering-icon-btn" data-logic="dark_to_light" title="Dark ‚Üí Light">
            <svg viewBox="0 0 24 24"><rect x="3" y="3" width="18" height="18" rx="2" fill="#333"/><path d="M3 3 L21 21" stroke="#fff" stroke-width="2"/><rect x="12" y="3" width="9" height="18" fill="white" stroke="none"/></svg>
        </button>
        <button class="rendering-icon-btn" data-logic="frequency_by_color" title="Most ‚Üí Least Count">
            <svg viewBox="0 0 24 24"><rect x="3" y="14" width="4" height="7"/><rect x="8" y="10" width="4" height="11"/><rect x="13" y="6" width="4" height="15"/><rect x="18" y="3" width="4" height="18"/></svg>
        </button>
        <button class="rendering-icon-btn" data-logic="frequency_by_color_reverse" title="Least ‚Üí Most Count">
            <svg viewBox="0 0 24 24"><rect x="3" y="3" width="4" height="18"/><rect x="8" y="6" width="4" height="15"/><rect x="13" y="10" width="4" height="11"/><rect x="18" y="14" width="4" height="7"/></svg>
        </button>
        <button class="rendering-icon-btn" data-logic="custom_sequence" title="Custom Sequence (Drag Colors)">
            <svg viewBox="0 0 24 24"><rect x="3" y="4" width="7" height="7" rx="1"/><rect x="14" y="4" width="7" height="7" rx="1"/><rect x="3" y="13" width="7" height="7" rx="1"/><rect x="14" y="13" width="7" height="7" rx="1"/><path d="M10 7.5 L14 7.5" stroke-dasharray="2,1"/><path d="M10 16.5 L14 16.5" stroke-dasharray="2,1"/></svg>
        </button>
        <button class="rendering-icon-btn" id="selectiveResolutionIcon" title="Selective Resolution (Draw region to add detail)">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                <rect x="3" y="3" width="18" height="18" rx="2"/>
                <rect x="6" y="6" width="8" height="8" rx="1" stroke-dasharray="2,1"/>
                <circle cx="10" cy="10" r="2" fill="currentColor" stroke="none"/>
                <line x1="16" y1="8" x2="19" y2="8"/>
                <line x1="16" y1="12" x2="19" y2="12"/>
                <line x1="16" y1="16" x2="19" y2="16"/>
                <line x1="8" y1="16" x2="12" y2="16"/>
            </svg>
        </button>
    </div>
    
    <!-- Hidden radio buttons for logic (keep for JS compatibility) -->
    <div style="display: none;">
        <input type="radio" name="logic" value="original" checked>
        <input type="radio" name="logic" value="exterior_to_center">
        <input type="radio" name="logic" value="center_to_exterior">
        <input type="radio" name="logic" value="top_to_bottom">
        <input type="radio" name="logic" value="bottom_to_top">
        <input type="radio" name="logic" value="color_sequence">
        <input type="radio" name="logic" value="light_to_dark">
        <input type="radio" name="logic" value="dark_to_light">
        <input type="radio" name="logic" value="frequency_by_color">
        <input type="radio" name="logic" value="frequency_by_color_reverse">
        <input type="radio" name="logic" value="custom_sequence">
    </div>

    <!-- Progressive Render Slider (under icons when logic selected) -->
    <div class="rendering-slider-container">
        <label id="sliderLabel">Shapes: 0 / 0</label>
        <input type="range" id="slider" min="0" max="0" value="0">
    </div>
    
    <!-- Inline Drag & Drop (shown when custom_sequence is selected) -->
    <div id="dragDropInline" class="drag-drop-inline">
        <h4>Drag & Drop Color Order</h4>
        <div id="frequencyInfoInline" class="frequency-info"></div>
        <div id="colorPaletteInline" class="color-palette"></div>
        <button id="saveDragInlineBtn" style="background: #4CAF50; color: white; border: none; padding: 8px 16px; border-radius: 4px; cursor: pointer; margin-top: 10px;">Apply Order</button>
    </div>

    <button id="editColorBtn" style="margin-top: 10px;">Edit Color Sequence</button>
    <button id="dragColorBtn">Drag & Drop Color Order</button>

    <button id="bakeOpaqueBtn" style="background:#2196F3; color:white; margin-top:10px;">
        Bake Opaque (Fix Order Issues)
    </button>
    <div class="info">Makes shapes order-independent</div>
    
    <!-- Sequence Filter Section -->
    <div id="sequenceFilterSection" class="sequence-filter-section" style="display: none;">
        <h4>Sequence Filter (Click to show only selected color)</h4>
        <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 10px;">
            <span style="font-size: 12px; color: #666;">Sort:</span>
            <button id="sortDescBtn" class="sort-btn active" title="Most to Least">‚ñº Most</button>
            <button id="sortAscBtn" class="sort-btn" title="Least to Most">‚ñ≤ Least</button>
        </div>
        <div id="sequenceFilterChips" class="sequence-filter-chips"></div>
        <div class="sequence-filter-actions">
            <button id="clearFilterBtn">Clear Filter</button>
            <button id="showGroupedOnlyBtn" style="background: #9c27b0; color: white; border: none; border-radius: 4px; cursor: pointer;">Show Grouped Only (<span id="groupedColorCount">0</span>)</button>
        </div>
    </div>
</div>

<!-- ====================== COLOR PICKER ======================== -->
<div class="section">
    <h3>Color Picker</h3>
    <div class="info">Click on shapes in the canvas to inspect their color values.</div>
    <button id="colorPickerBtn">Enable Color Picker</button>
    
    <div id="colorPickerPanel" class="color-picker-panel">
        <div class="color-picker-header">
            <h4>Selected Shape</h4>
            <div id="colorPreviewBox" class="color-preview-box"></div>
        </div>
        <div class="color-details">
            <div class="color-detail-item">
                <label>Shape Type</label>
                <span id="shapeTypeValue">-</span>
            </div>
            <div class="color-detail-item">
                <label>Shape Index</label>
                <span id="shapeIndexValue">-</span>
            </div>
            <div class="color-detail-item">
                <label>RGB</label>
                <span id="rgbValue">-</span>
            </div>
            <div class="color-detail-item">
                <label>RGBA</label>
                <span id="rgbaValue">-</span>
            </div>
            <div class="color-detail-item">
                <label>HEX</label>
                <span id="hexValue">-</span>
            </div>
            <div class="color-detail-item">
                <label>Alpha</label>
                <span id="alphaValue">-</span>
            </div>
        </div>
        <div class="color-details" style="margin-top: 8px;">
            <div class="color-detail-item">
                <label>Position (center)</label>
                <span id="positionValue">-</span>
            </div>
            <div class="color-detail-item">
                <label>Score</label>
                <span id="scoreValue">-</span>
            </div>
        </div>
        
        <!-- Palette Preset Section -->
        <div class="palette-preset-section">
            <h4>Load Palette Preset</h4>
            <div class="palette-preset-controls">
                <select id="palettePresetSelect">
                    <option value="">-- Select a palette --</option>
                </select>
                <button id="loadPaletteBtn" disabled>Load</button>
            </div>
        </div>
        
        <!-- Color Matcher Section -->
        <div class="color-matcher-section">
            <h5>Match Against Palette</h5>
            <textarea id="colorMatcherInput" class="color-matcher-input" placeholder="Enter hex colors to compare against (one per line or comma-separated):
#FF5733
#3498DB
#2ECC71"></textarea>

            <div id="matchResults" class="match-results">
                <div class="match-empty">Select a shape and enter palette colors to compare</div>
            </div>
        </div>
        
        <!-- Unmix / Get Recipe Section -->
        <div class="unmix-section">
            <h5>Get Mix Recipe (Unmix)</h5>
            <p style="font-size: 11px; color: #666; margin: 0 0 12px 0;">
                Find which paints to mix (and in what proportions) to recreate the selected color.
            </p>
            <div class="unmix-controls">
                <div class="unmix-control-item">
                    <label>Max Colors in Recipe</label>
                    <input type="number" id="maxColorsInput" value="3" min="1" max="5">
                </div>
                <div class="unmix-control-item">
                    <label>Max Parts (Precision)</label>
                    <input type="number" id="maxPartsInput" value="10" min="2" max="20">
                </div>
            </div>
            <button id="getRecipeBtn" disabled>Get Mix Recipe</button>
            <div id="recipeResults" class="recipe-results">
                <div class="recipe-empty">Select a shape and load a palette to get a mixing recipe</div>
            </div>
        </div>
    </div>
</div>

<div class="section slider-container">
    <h3>Color Grouping (Compress Similar Colors)</h3>
    <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 8px;">
        <span style="font-size: 12px; color: #666;">Mode:</span>
        <button id="sliderModeNormal" class="slider-mode-btn active" title="Start with all colors, slide right to compress">All ‚Üí Few</button>
        <button id="sliderModeReversed" class="slider-mode-btn" title="Start compressed, slide right to expand">Few ‚Üí All</button>
    </div>
    <div class="info" id="colorGroupLabel">Tolerance: 0 (Unique colors: 0)</div>
    <input type="range" id="colorGroupSlider" min="0" max="100" value="0">
</div>
</div><!-- END TAB 2 -->

<!-- ========================== CANVAS ============================= -->
<div style="position: relative;">
    <canvas id="canvas" width="600" height="600"></canvas>
    <div id="regionOverlay" style="position:absolute; top:0; left:0; pointer-events:none;"></div>
</div>

<!-- ====================== IMAGE ADJUSTMENTS ======================== -->
<div class="section adjust-section">
    <div class="adjust-container">
        <button class="adjust-reset-btn" id="resetAdjustBtn">Reset</button>
        
        <!-- Selected adjustment label -->
        <div class="adjust-selected-label" id="adjustSelectedLabel"></div>
        
        <!-- Horizontal scrollable icons -->
        <div class="adjust-icons-wrapper">
            <button class="adjust-scroll-arrow left" id="scrollLeft">‚Äπ</button>
            <div class="adjust-icons-scroll" id="adjustIconsScroll">
                <!-- Exposure -->
                <button class="adjust-icon-btn" data-adjust="exposure" data-label="Exposure" title="Exposure">
                    <div class="adjust-icon-circle">
                        <svg viewBox="0 0 24 24"><rect x="4" y="4" width="16" height="16" rx="2" stroke-width="1.5"/><line x1="9" y1="12" x2="15" y2="12" stroke-width="2"/><line x1="12" y1="9" x2="12" y2="15" stroke-width="2"/></svg>
                    </div>
                </button>
                <!-- Brilliance -->
                <button class="adjust-icon-btn" data-adjust="brilliance" data-label="Brilliance" title="Brilliance">
                    <div class="adjust-icon-circle">
                        <svg viewBox="0 0 24 24"><circle cx="12" cy="12" r="4" fill="#000"/><line x1="12" y1="2" x2="12" y2="5"/><line x1="12" y1="19" x2="12" y2="22"/><line x1="2" y1="12" x2="5" y2="12"/><line x1="19" y1="12" x2="22" y2="12"/><line x1="4.93" y1="4.93" x2="7.05" y2="7.05"/><line x1="16.95" y1="16.95" x2="19.07" y2="19.07"/><line x1="4.93" y1="19.07" x2="7.05" y2="16.95"/><line x1="16.95" y1="7.05" x2="19.07" y2="4.93"/></svg>
                    </div>
                </button>
                <!-- Highlights -->
                <button class="adjust-icon-btn" data-adjust="highlights" data-label="Highlights" title="Highlights">
                    <div class="adjust-icon-circle">
                        <svg viewBox="0 0 24 24"><circle cx="12" cy="12" r="8" stroke-width="1.5"/><circle cx="12" cy="12" r="3" fill="#000"/></svg>
                    </div>
                </button>
                <!-- Shadows -->
                <button class="adjust-icon-btn" data-adjust="shadows" data-label="Shadows" title="Shadows">
                    <div class="adjust-icon-circle">
                        <svg viewBox="0 0 24 24"><circle cx="12" cy="12" r="8" stroke-width="1.5"/><path d="M12 4a8 8 0 0 0 0 16" fill="#000"/></svg>
                    </div>
                </button>
                <!-- Contrast -->
                <button class="adjust-icon-btn" data-adjust="contrast" data-label="Contrast" title="Contrast">
                    <div class="adjust-icon-circle">
                        <svg viewBox="0 0 24 24"><circle cx="12" cy="12" r="9" stroke-width="1.5"/><path d="M12 3a9 9 0 0 1 0 18" fill="#000"/></svg>
                    </div>
                </button>
                <!-- Brightness -->
                <button class="adjust-icon-btn" data-adjust="brightness" data-label="Brightness" title="Brightness">
                    <div class="adjust-icon-circle">
                        <svg viewBox="0 0 24 24"><circle cx="12" cy="12" r="5" stroke-width="1.5"/><g stroke-width="1.5"><line x1="12" y1="1" x2="12" y2="4"/><line x1="12" y1="20" x2="12" y2="23"/><line x1="1" y1="12" x2="4" y2="12"/><line x1="20" y1="12" x2="23" y2="12"/><line x1="4.22" y1="4.22" x2="6.34" y2="6.34"/><line x1="17.66" y1="17.66" x2="19.78" y2="19.78"/><line x1="4.22" y1="19.78" x2="6.34" y2="17.66"/><line x1="17.66" y1="6.34" x2="19.78" y2="4.22"/></g></svg>
                    </div>
                </button>
                <!-- Black Point -->
                <button class="adjust-icon-btn" data-adjust="blackpoint" data-label="Black Point" title="Black Point">
                    <div class="adjust-icon-circle">
                        <svg viewBox="0 0 24 24"><polygon points="4,20 12,4 20,20" fill="#000" stroke="none"/></svg>
                    </div>
                </button>
                <!-- Saturation -->
                <button class="adjust-icon-btn" data-adjust="saturation" data-label="Saturation" title="Saturation">
                    <div class="adjust-icon-circle color-wheel"></div>
                </button>
                <!-- Vibrance -->
                <button class="adjust-icon-btn" data-adjust="vibrance" data-label="Vibrance" title="Vibrance">
                    <div class="adjust-icon-circle color-stripes">
                        <div class="color-stripes-inner">
                            <span style="background:#ff0000"></span>
                            <span style="background:#ff8800"></span>
                            <span style="background:#ffff00"></span>
                            <span style="background:#00ff00"></span>
                            <span style="background:#00ffff"></span>
                            <span style="background:#0000ff"></span>
                            <span style="background:#ff00ff"></span>
                        </div>
                    </div>
                </button>
                <!-- Warmth -->
                <button class="adjust-icon-btn" data-adjust="warmth" data-label="Warmth" title="Warmth">
                    <div class="adjust-icon-circle">
                        <svg viewBox="0 0 24 24"><path d="M12 2v4M12 18v4M8 12a4 4 0 1 0 8 0c0-2-1.5-4-4-6-2.5 2-4 4-4 6z" stroke-width="1.5" stroke-linecap="round"/><circle cx="12" cy="12" r="2" fill="#000"/></svg>
                    </div>
                </button>
                <!-- Tint -->
                <button class="adjust-icon-btn" data-adjust="tint" data-label="Tint" title="Tint">
                    <div class="adjust-icon-circle">
                        <svg viewBox="0 0 24 24"><path d="M12 2c-4 4-6 7-6 10a6 6 0 0 0 12 0c0-3-2-6-6-10z" stroke-width="1.5" fill="none"/></svg>
                    </div>
                </button>
                <!-- Sharpness -->
                <button class="adjust-icon-btn" data-adjust="sharpness" data-label="Sharpness" title="Sharpness">
                    <div class="adjust-icon-circle">
                        <svg viewBox="0 0 24 24"><polygon points="4,20 20,20 12,4" stroke-width="1.5" fill="none"/></svg>
                    </div>
                </button>
                <!-- Definition -->
                <button class="adjust-icon-btn" data-adjust="definition" data-label="Definition" title="Definition">
                    <div class="adjust-icon-circle">
                        <svg viewBox="0 0 24 24"><polygon points="4,18 12,6 20,18" stroke-width="1.5" fill="none"/><line x1="7" y1="14" x2="17" y2="14" stroke-width="1.5"/></svg>
                    </div>
                </button>
                <!-- Noise Reduction -->
                <button class="adjust-icon-btn" data-adjust="noise" data-label="Noise Reduction" title="Noise Reduction">
                    <div class="adjust-icon-circle">
                        <svg viewBox="0 0 24 24"><circle cx="12" cy="12" r="9" stroke-width="1.5"/><circle cx="8" cy="10" r="1" fill="#000"/><circle cx="14" cy="8" r="1" fill="#000"/><circle cx="16" cy="14" r="1" fill="#000"/><circle cx="10" cy="15" r="1" fill="#000"/><circle cx="12" cy="12" r="1" fill="#000"/></svg>
                    </div>
                </button>
                <!-- Vignette -->
                <button class="adjust-icon-btn" data-adjust="vignette" data-label="Vignette" title="Vignette">
                    <div class="adjust-icon-circle">
                        <svg viewBox="0 0 24 24"><circle cx="12" cy="12" r="9" stroke-width="1.5"/><circle cx="12" cy="12" r="5" stroke-width="1.5" stroke-dasharray="2,2"/></svg>
                    </div>
                </button>
                <!-- B&W -->
                <button class="adjust-icon-btn" data-adjust="bw" data-label="Black & White" title="Black & White">
                    <div class="adjust-icon-circle">
                        <svg viewBox="0 0 24 24"><circle cx="12" cy="12" r="9" stroke-width="1.5" fill="none"/><path d="M12 3a9 9 0 0 1 0 18" fill="#000"/><g stroke-width="1.5" stroke="#fff"><line x1="15" y1="8" x2="15" y2="16"/><line x1="17" y1="8" x2="17" y2="16"/><line x1="19" y1="8" x2="19" y2="16"/></g><g stroke-width="1.5" stroke="#000"><line x1="5" y1="8" x2="5" y2="16"/><line x1="7" y1="8" x2="7" y2="16"/><line x1="9" y1="8" x2="9" y2="16"/></g></svg>
                    </div>
                </button>
            </div>
            <button class="adjust-scroll-arrow right" id="scrollRight">‚Ä∫</button>
        </div>
        
        <!-- Ruler slider -->
        <div class="adjust-ruler-container">
            <div class="adjust-ruler">
                <input type="range" class="adjust-slider-hidden" id="adjustSlider" min="-100" max="100" value="0" step="1">
                <div class="adjust-ruler-ticks" id="rulerTicks"></div>
            </div>
            <div class="adjust-value-display" id="adjustValueDisplay"></div>
        </div>
    </div>
    
    <!-- Hidden sliders for each adjustment (for data storage) -->
    <div style="display:none;">
        <input type="range" id="brilliance-slider" min="-100" max="100" value="0">
        <input type="range" id="exposure-slider" min="-100" max="100" value="0">
        <input type="range" id="highlights-slider" min="-100" max="100" value="0">
        <input type="range" id="shadows-slider" min="-100" max="100" value="0">
        <input type="range" id="brightness-slider" min="-100" max="100" value="0">
        <input type="range" id="contrast-slider" min="-100" max="100" value="0">
        <input type="range" id="saturation-slider" min="-100" max="100" value="0">
        <input type="range" id="vibrance-slider" min="-100" max="100" value="0">
        <input type="range" id="warmth-slider" min="-100" max="100" value="0">
        <input type="range" id="tint-slider" min="-100" max="100" value="0">
        <input type="range" id="bw-slider" min="0" max="100" value="0">
        <input type="range" id="neutrals-slider" min="-100" max="100" value="0">
        <input type="range" id="tone-slider" min="-100" max="100" value="0">
        <input type="range" id="grain-slider" min="0" max="100" value="0">
        <input type="range" id="blackpoint-slider" min="-100" max="100" value="0">
        <input type="range" id="sharpness-slider" min="0" max="100" value="0">
        <input type="range" id="definition-slider" min="-100" max="100" value="0">
        <input type="range" id="noise-slider" min="0" max="100" value="0">
        <input type="range" id="vignette-slider" min="-100" max="100" value="0">
    </div>
</div>

<!-- ========== MODALS (COLOR SEQUENCE + DRAG) ‚Äî UNCHANGED ========= -->
<div id="colorModal" class="modal">
    <div class="modal-content">
        <h3>Edit Color Sequence</h3>
        <textarea id="colorInput"></textarea>
        <div class="modal-buttons">
            <button id="cancelColorBtn">Cancel</button>
            <button id="saveColorBtn">Save</button>
        </div>
    </div>
</div>

<div id="dragModal" class="modal">
    <div class="modal-content">
        <h3>Drag & Drop Color Order</h3>
        <div id="frequencyInfo" class="frequency-info"></div>
        <div id="colorPalette" class="color-palette"></div>
        <div class="modal-buttons">
            <button id="cancelDragBtn">Cancel</button>
            <button id="saveDragBtn">Save Order</button>
        </div>
    </div>
</div>

<script>
//const API_BASE = "http://127.0.0.1:8000";
const API_BASE = "https://slider-options-img-production.up.railway.app";

let baseShapes = [];
let detailShapes = [];
let currentShapes = [];
let groupedShapes = [];
let regions = [];
let customColorOrder = null;
let colorOrder = null;
let colorTolerance = 0;
let selectedFilterColor = null; // For sequence filter
let showGroupedOnly = false; // Toggle for sequence filter to show grouped colors only
let sequenceFilterSortOrder = 'desc'; // 'desc' = most to least, 'asc' = least to most
let sliderModeReversed = false; // false = normal (0‚Üí100), true = reversed (100‚Üí0 displayed as 0‚Üí100)
let isSelectiveResolutionMode = false; // For selective resolution tool
let selectiveResolutionPath = []; // Current drawing path for selective resolution

const baseFileInput = document.getElementById("baseFileInput");
const detailFileInput = document.getElementById("detailFileInput");
const baseFileStatus = document.getElementById("baseFileStatus");
const detailFileStatus = document.getElementById("detailFileStatus");

const selectRegionsBtn = document.getElementById("selectRegionsBtn");
const clearRegionsBtn = document.getElementById("clearRegionsBtn");
const applyEnhanceBtn = document.getElementById("applyEnhanceBtn");
const regionList = document.getElementById("regionList");
const regionOverlay = document.getElementById("regionOverlay");

const slider = document.getElementById("slider");
const sliderLabel = document.getElementById("sliderLabel");
const colorGroupSlider = document.getElementById("colorGroupSlider");
const colorGroupLabel = document.getElementById("colorGroupLabel");

const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");

const logicRadios = document.querySelectorAll("input[name='logic']");
const editColorBtn = document.getElementById("editColorBtn");
const dragColorBtn = document.getElementById("dragColorBtn");

const bakeOpaqueBtn = document.getElementById("bakeOpaqueBtn");

/* ==========================================================
   MAIN TABS FUNCTIONALITY
========================================================== */
document.querySelectorAll('.main-tab-btn').forEach(btn => {
    btn.addEventListener('click', () => {
        const tabId = btn.dataset.tab;
        
        // Update buttons
        document.querySelectorAll('.main-tab-btn').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        
        // Update tab content
        document.querySelectorAll('.main-tab-content').forEach(content => {
            content.classList.remove('active');
        });
        document.getElementById(tabId).classList.add('active');
    });
});

/* ==========================================================
   RENDERING LOGIC ICONS FUNCTIONALITY
========================================================== */
document.querySelectorAll('.rendering-icon-btn').forEach(btn => {
    btn.addEventListener('click', () => {
        const logic = btn.dataset.logic;
        
        // Skip if this is the selective resolution icon (handled separately)
        if (btn.id === 'selectiveResolutionIcon') {
            return;
        }
        
        // Disable selective resolution mode if active
        if (isSelectiveResolutionMode) {
            isSelectiveResolutionMode = false;
            document.getElementById('selectiveResolutionIcon')?.classList.remove('active');
            canvas.style.cursor = 'crosshair';
        }
        
        // Update icon buttons
        document.querySelectorAll('.rendering-icon-btn:not(#selectiveResolutionIcon)').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        
        // Update hidden radio button
        const radio = document.querySelector(`input[name='logic'][value='${logic}']`);
        if (radio) {
            radio.checked = true;
            radio.dispatchEvent(new Event('change'));
        }
        
        // Show/hide inline drag & drop for custom_sequence
        const dragDropInline = document.getElementById('dragDropInline');
        if (logic === 'custom_sequence') {
            dragDropInline.classList.add('active');
            populateColorPaletteInline();
        } else {
            dragDropInline.classList.remove('active');
        }
        
        // Show sequence filter for color-based logics
        const filterSection = document.getElementById('sequenceFilterSection');
        if (['color_sequence', 'custom_sequence', 'light_to_dark', 'dark_to_light', 'frequency_by_color', 'frequency_by_color_reverse'].includes(logic)) {
            filterSection.style.display = 'block';
            populateSequenceFilterChips();
        } else {
            filterSection.style.display = 'none';
            selectedFilterColor = null;
        }
    });
});

/* ==========================================================
   SHAPE TYPE VALIDATION
========================================================== */
function validateShapeTypes() {
    const checkboxes = document.querySelectorAll('input[name="shapeType"]:checked');
    const errorEl = document.getElementById('shapeTypeError');
    
    if (checkboxes.length === 0) {
        errorEl.classList.add('visible');
        return false;
    } else {
        errorEl.classList.remove('visible');
        return true;
    }
}

// Add validation on checkbox change
document.querySelectorAll('input[name="shapeType"]').forEach(cb => {
    cb.addEventListener('change', validateShapeTypes);
});

/* ==========================================================
   INLINE DRAG & DROP FOR CUSTOM SEQUENCE
========================================================== */
function populateColorPaletteInline() {
    const palette = document.getElementById("colorPaletteInline");
    if (!palette) return;
    palette.innerHTML = "";

    const freq = new Map();
    const working = groupedShapes.length ? groupedShapes : currentShapes;

    if (!working.length) return;

    working.forEach(s => {
        if (s.type === 0) return;
        const k = JSON.stringify(s.color);
        freq.set(k, (freq.get(k) || 0) + 1);
    });

    const list = [...freq.entries()].map(([k, count]) => ({
        color: JSON.parse(k),
        count
    }));

    list.sort((a, b) => b.count - a.count);

    list.forEach((item, i) => {
        const chip = document.createElement("div");
        chip.className = "color-chip";
        chip.draggable = true;
        chip.dataset.color = JSON.stringify(item.color);
        chip.style.backgroundColor = `rgba(${item.color[0]},${item.color[1]},${item.color[2]},${item.color[3]/255})`;
        chip.innerHTML = `
            <div class="chip-number">#${i + 1}</div>
            <div class="rgb-value">${item.color.slice(0,3).join(", ")}</div>
            <div class="count">${item.count}√ó</div>
        `;

        chip.addEventListener("dragstart", () => chip.classList.add("dragging"));
        chip.addEventListener("dragend", () => chip.classList.remove("dragging"));
        chip.addEventListener("dragover", e => e.preventDefault());
        chip.addEventListener("drop", e => {
            e.preventDefault();
            const dragging = palette.querySelector(".dragging");
            if (dragging && dragging !== chip) {
                const all = [...palette.children];
                const from = all.indexOf(dragging);
                const to = all.indexOf(chip);
                if (from < to) chip.after(dragging);
                else chip.before(dragging);
            }
        });

        palette.appendChild(chip);
    });
}

// Save inline drag order
document.getElementById('saveDragInlineBtn')?.addEventListener('click', () => {
    const palette = document.getElementById("colorPaletteInline");
    const chips = [...palette.children];
    customColorOrder = chips.map(chip => JSON.parse(chip.dataset.color));
    updateRender();
});

/* ==========================================================
   SEQUENCE FILTER FUNCTIONALITY
========================================================== */
function populateSequenceFilterChips() {
    const container = document.getElementById('sequenceFilterChips');
    if (!container) return;
    container.innerHTML = '';

    const freq = new Map();
    // When showGroupedOnly is true, use groupedShapes; otherwise use currentShapes for all original colors
    const working = showGroupedOnly ? (groupedShapes.length ? groupedShapes : currentShapes) : currentShapes;

    if (!working.length) return;

    working.forEach(s => {
        if (s.type === 0) return;
        const k = JSON.stringify(s.color);
        freq.set(k, (freq.get(k) || 0) + 1);
    });

    const list = [...freq.entries()].map(([k, count]) => ({
        color: JSON.parse(k),
        count
    }));

    // Sort based on sequenceFilterSortOrder
    if (sequenceFilterSortOrder === 'desc') {
        list.sort((a, b) => b.count - a.count); // Most to least
    } else {
        list.sort((a, b) => a.count - b.count); // Least to most
    }

    list.forEach(item => {
        const chip = document.createElement('div');
        chip.className = 'sequence-filter-chip';
        chip.style.backgroundColor = `rgba(${item.color[0]},${item.color[1]},${item.color[2]},${item.color[3]/255})`;
        chip.dataset.color = JSON.stringify(item.color);
        chip.title = `RGB(${item.color.slice(0,3).join(', ')}) - ${item.count} shapes`;

        // Add counter badge
        const counter = document.createElement('span');
        counter.className = 'chip-counter';
        counter.textContent = item.count;
        chip.appendChild(counter);

        chip.addEventListener('click', () => {
            // Toggle selection
            if (chip.classList.contains('selected')) {
                chip.classList.remove('selected');
                selectedFilterColor = null;
            } else {
                container.querySelectorAll('.sequence-filter-chip').forEach(c => c.classList.remove('selected'));
                chip.classList.add('selected');
                selectedFilterColor = item.color;
            }
            updateRender();
        });

        container.appendChild(chip);
    });
    
    // Update the grouped color count
    updateGroupedColorCount();
}

// Clear filter button
document.getElementById('clearFilterBtn')?.addEventListener('click', () => {
    selectedFilterColor = null;
    document.querySelectorAll('.sequence-filter-chip').forEach(c => c.classList.remove('selected'));
    updateRender();
});

// Sort buttons for sequence filter
document.getElementById('sortDescBtn')?.addEventListener('click', () => {
    sequenceFilterSortOrder = 'desc';
    document.getElementById('sortDescBtn').classList.add('active');
    document.getElementById('sortAscBtn').classList.remove('active');
    populateSequenceFilterChips();
});

document.getElementById('sortAscBtn')?.addEventListener('click', () => {
    sequenceFilterSortOrder = 'asc';
    document.getElementById('sortAscBtn').classList.add('active');
    document.getElementById('sortDescBtn').classList.remove('active');
    populateSequenceFilterChips();
});

// Show Grouped Only button - filters to show only the grouped colors from the slider
document.getElementById('showGroupedOnlyBtn')?.addEventListener('click', () => {
    showGroupedOnly = !showGroupedOnly;
    const btn = document.getElementById('showGroupedOnlyBtn');
    if (showGroupedOnly) {
        btn.style.background = '#7b1fa2';
        btn.textContent = 'Show All Colors';
    } else {
        btn.style.background = '#9c27b0';
        updateGroupedColorCount(); // Restore original text
    }
    populateSequenceFilterChips();
});

// Update the grouped color count in the button
function updateGroupedColorCount() {
    const working = groupedShapes.length ? groupedShapes : currentShapes;
    const unique = new Set();
    working.forEach(s => {
        if (s.type !== 0) unique.add(JSON.stringify(s.color));
    });
    const countSpan = document.getElementById('groupedColorCount');
    if (countSpan) {
        countSpan.textContent = unique.size;
    }
    const btn = document.getElementById('showGroupedOnlyBtn');
    if (btn && !showGroupedOnly) {
        btn.innerHTML = `Show Grouped Only (<span id="groupedColorCount">${unique.size}</span>)`;
    }
}

const colorPickerBtn = document.getElementById("colorPickerBtn");
const colorPickerPanel = document.getElementById("colorPickerPanel");
const colorPreviewBox = document.getElementById("colorPreviewBox");
const shapeTypeValue = document.getElementById("shapeTypeValue");
const shapeIndexValue = document.getElementById("shapeIndexValue");
const rgbValue = document.getElementById("rgbValue");
const rgbaValue = document.getElementById("rgbaValue");
const hexValue = document.getElementById("hexValue");
const alphaValue = document.getElementById("alphaValue");
const positionValue = document.getElementById("positionValue");
const scoreValue = document.getElementById("scoreValue");

// Color Matcher elements
const colorMatcherInput = document.getElementById("colorMatcherInput");
const matchResults = document.getElementById("matchResults");

// Unmix / Recipe elements
const maxColorsInput = document.getElementById("maxColorsInput");
const maxPartsInput = document.getElementById("maxPartsInput");
const getRecipeBtn = document.getElementById("getRecipeBtn");
const recipeResults = document.getElementById("recipeResults");

let isSelecting = false;
let isDrawingPath = false;
let currentPath = [];
let currentRegion = null;

let isPickingColor = false;
let selectedShapeIndex = null;
let currentSelectedColor = null;

// Geometrize elements (Client-Side)
const geometrizeInput = document.getElementById("geometrizeInput");
const geometrizeShapeCount = document.getElementById("geometrizeShapeCount");
const geometrizeAlpha = document.getElementById("geometrizeAlpha");
const geometrizeCandidates = document.getElementById("geometrizeCandidates");
const geometrizeMutations = document.getElementById("geometrizeMutations");
const geometrizeBtn = document.getElementById("geometrizeBtn");
const stopGeometrizeBtn = document.getElementById("stopGeometrizeBtn");
const progressContainer = document.getElementById("progressContainer");
const progressFill = document.getElementById("progressFill");
const progressText = document.getElementById("progressText");
const geometrizePreview = document.getElementById("geometrizePreview");
const geometrizeStatus = document.getElementById("geometrizeStatus");
const downloadJsonBtn = document.getElementById("downloadJsonBtn");

// Geometrize state
let geometrizeWorker = null;
let isGeometrizing = false;
let generatedShapes = [];
let previewCtx = geometrizePreview.getContext("2d");


// ==================== IMAGE ADJUSTMENTS ====================
const adjustmentValues = {
    brilliance: 0,
    exposure: 0,
    highlights: 0,
    shadows: 0,
    brightness: 0,
    contrast: 0,
    saturation: 0,
    vibrance: 0,
    warmth: 0,
    tint: 0,
    bw: 0,
    neutrals: 0,
    tone: 0,
    grain: 0,
    blackpoint: 0,
    sharpness: 0,
    definition: 0,
    noise: 0,
    vignette: 0
};

// iPhone-style adjustment UI
const adjustIconsScroll = document.getElementById('adjustIconsScroll');
const adjustSlider = document.getElementById('adjustSlider');
const rulerTicks = document.getElementById('rulerTicks');
const adjustValueDisplay = document.getElementById('adjustValueDisplay');
let currentAdjustment = null;

// Generate ruler ticks
function generateRulerTicks() {
    if (!rulerTicks) return;
    rulerTicks.innerHTML = '';
    const totalTicks = 41; // -100 to 100, showing every 5
    for (let i = 0; i < totalTicks; i++) {
        const tick = document.createElement('div');
        tick.className = 'adjust-ruler-tick';
        if (i === 20) { // Center tick
            tick.classList.add('center');
        } else if (i % 10 === 0) { // Large tick every 50
            tick.classList.add('large');
        } else if (i % 2 === 0) { // Medium tick every 10
            tick.classList.add('medium');
        } else {
            tick.classList.add('small');
        }
        rulerTicks.appendChild(tick);
    }
}
generateRulerTicks();

// Update ruler tick highlights based on value
function updateRulerHighlight(value) {
    if (!rulerTicks) return;
    const ticks = rulerTicks.querySelectorAll('.adjust-ruler-tick');
    const centerIndex = 20;
    const ticksToHighlight = Math.round(Math.abs(value) / 5);
    
    ticks.forEach((tick, index) => {
        tick.classList.remove('active');
        if (value > 0) {
            if (index > centerIndex && index <= centerIndex + ticksToHighlight) {
                tick.classList.add('active');
            }
        } else if (value < 0) {
            if (index < centerIndex && index >= centerIndex - ticksToHighlight) {
                tick.classList.add('active');
            }
        }
    });
}

// Scroll arrows
const scrollLeftBtn = document.getElementById('scrollLeft');
const scrollRightBtn = document.getElementById('scrollRight');
if (scrollLeftBtn && adjustIconsScroll) {
    scrollLeftBtn.addEventListener('click', () => {
        adjustIconsScroll.scrollBy({ left: -200, behavior: 'smooth' });
    });
}
if (scrollRightBtn && adjustIconsScroll) {
    scrollRightBtn.addEventListener('click', () => {
        adjustIconsScroll.scrollBy({ left: 200, behavior: 'smooth' });
    });
}

// Selected label element
const adjustSelectedLabel = document.getElementById('adjustSelectedLabel');

// Icon buttons
document.querySelectorAll('.adjust-icon-btn').forEach(btn => {
    btn.addEventListener('click', () => {
        // Remove active from all
        document.querySelectorAll('.adjust-icon-btn').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        
        const adjustType = btn.dataset.adjust;
        const adjustLabel = btn.dataset.label || adjustType;
        currentAdjustment = adjustType;
        
        // Update the selected label
        if (adjustSelectedLabel) {
            adjustSelectedLabel.textContent = adjustLabel;
        }
        
        if (adjustSlider) adjustSlider.disabled = false;
        const slider = document.getElementById(`${adjustType}-slider`);
        if (slider) {
            const currentValue = parseInt(slider.value) || 0;
            if (adjustSlider) {
                adjustSlider.value = currentValue;
                adjustSlider.min = slider.min;
                adjustSlider.max = slider.max;
            }
            updateRulerHighlight(currentValue);
            if (adjustValueDisplay) adjustValueDisplay.textContent = currentValue !== 0 ? currentValue : '';
        }
    });
});

// Main slider interaction
if (adjustSlider) {
    adjustSlider.addEventListener('input', () => {
        if (!currentAdjustment) return;
        
        const value = parseInt(adjustSlider.value);
        const hiddenSlider = document.getElementById(`${currentAdjustment}-slider`);
        
        if (hiddenSlider) {
            hiddenSlider.value = value;
            adjustmentValues[currentAdjustment] = value;
        }
        
        // Update display
        if (adjustValueDisplay) adjustValueDisplay.textContent = value !== 0 ? value : '';
        updateRulerHighlight(value);
        
        // Mark icon as modified
        const activeBtn = document.querySelector(`.adjust-icon-btn[data-adjust="${currentAdjustment}"]`);
        if (activeBtn) {
            if (value !== 0) {
                activeBtn.classList.add('modified');
            } else {
                activeBtn.classList.remove('modified');
            }
        }
        
        applyAdjustments();
    });
}

// Initialize all adjustment sliders
const adjustmentSliders = [
    'brilliance', 'exposure', 'highlights', 'shadows', 'brightness', 'contrast',
    'saturation', 'vibrance', 'warmth', 'tint',
    'bw', 'neutrals', 'tone', 'grain',
    'blackpoint', 'sharpness', 'definition', 'noise', 'vignette'
];

// Apply all adjustments using CSS filters
function applyAdjustments() {
    const filters = [];
    
    // === EXPOSURE === (overall light multiplier)
    if (adjustmentValues.exposure !== 0) {
        const exp = 1 + (adjustmentValues.exposure / 100);
        filters.push(`brightness(${exp})`);
    }
    
    // === BRIGHTNESS === (adds light)
    if (adjustmentValues.brightness !== 0) {
        const bright = 1 + (adjustmentValues.brightness / 100);
        filters.push(`brightness(${bright})`);
    }
    
    // === BRILLIANCE === (mid-tone focused brightness)
    if (adjustmentValues.brilliance !== 0) {
        const brill = 1 + (adjustmentValues.brilliance / 120);
        filters.push(`brightness(${brill})`);
    }
    
    // === HIGHLIGHTS === (CSS can't target only highlights, so we use a combination)
    // Positive: increases overall brightness slightly
    // Negative: reduces brightness (recover highlights)
    if (adjustmentValues.highlights !== 0) {
        const hl = 1 + (adjustmentValues.highlights / 200);
        filters.push(`brightness(${hl})`);
        // Also adjust contrast to simulate highlight compression/expansion
        if (adjustmentValues.highlights < 0) {
            // Recovering highlights - reduce contrast slightly
            filters.push(`contrast(${1 + adjustmentValues.highlights / 400})`);
        }
    }
    
    // === SHADOWS === (lift or crush dark areas)
    // We simulate this with brightness + contrast combination
    if (adjustmentValues.shadows !== 0) {
        // Lifting shadows = add brightness + reduce contrast
        // Crushing shadows = reduce brightness + increase contrast
        const shadowBright = 1 + (adjustmentValues.shadows / 300);
        const shadowContrast = 1 - (adjustmentValues.shadows / 400);
        filters.push(`brightness(${shadowBright})`);
        filters.push(`contrast(${shadowContrast})`);
    }
    
    // === BLACK POINT === (set minimum black level)
    if (adjustmentValues.blackpoint !== 0) {
        if (adjustmentValues.blackpoint > 0) {
            // Lift blacks - add brightness, reduce contrast
            const bpBright = 1 + (adjustmentValues.blackpoint / 250);
            const bpContrast = 1 - (adjustmentValues.blackpoint / 300);
            filters.push(`brightness(${bpBright})`);
            filters.push(`contrast(${bpContrast})`);
        } else {
            // Crush blacks - increase contrast
            const bpContrast = 1 - (adjustmentValues.blackpoint / 200);
            filters.push(`contrast(${bpContrast})`);
        }
    }
    
    // === CONTRAST ===
    if (adjustmentValues.contrast !== 0) {
        const cont = 1 + (adjustmentValues.contrast / 100);
        filters.push(`contrast(${cont})`);
    }
    
    // === DEFINITION === (local contrast / clarity)
    if (adjustmentValues.definition !== 0) {
        const def = 1 + (adjustmentValues.definition / 100);
        filters.push(`contrast(${def})`);
    }
    
    // === SATURATION ===
    if (adjustmentValues.saturation !== 0) {
        const sat = 1 + (adjustmentValues.saturation / 100);
        filters.push(`saturate(${sat})`);
    }
    
    // === VIBRANCE === (gentler saturation)
    if (adjustmentValues.vibrance !== 0) {
        const vib = 1 + (adjustmentValues.vibrance / 150);
        filters.push(`saturate(${vib})`);
    }
    
    // === WARMTH === (color temperature)
    if (adjustmentValues.warmth !== 0) {
        if (adjustmentValues.warmth > 0) {
            // Warm: sepia effect
            const warmth = adjustmentValues.warmth / 100;
            filters.push(`sepia(${warmth * 0.4})`);
            filters.push(`saturate(${1 + warmth * 0.2})`);
        } else {
            // Cool: hue shift towards blue
            const cool = adjustmentValues.warmth;
            filters.push(`hue-rotate(${cool * 0.5}deg)`);
            filters.push(`saturate(${1 + Math.abs(cool) / 200})`);
        }
    }
    
    // === TINT === (green-magenta axis)
    if (adjustmentValues.tint !== 0) {
        const tint = adjustmentValues.tint;
        filters.push(`hue-rotate(${tint * 0.8}deg)`);
    }
    
    // === BLACK & WHITE ===
    if (adjustmentValues.bw > 0) {
        const bw = adjustmentValues.bw / 100;
        filters.push(`grayscale(${bw})`);
    }
    
    // === SHARPNESS === (simulated with contrast)
    if (adjustmentValues.sharpness > 0) {
        const sharp = 1 + (adjustmentValues.sharpness / 200);
        filters.push(`contrast(${sharp})`);
    }
    
    // === NOISE REDUCTION === (blur)
    if (adjustmentValues.noise > 0) {
        const blur = adjustmentValues.noise / 50;
        filters.push(`blur(${blur}px)`);
    }
    
    // Apply filters
    if (filters.length > 0) {
        canvas.style.filter = filters.join(' ');
    } else {
        canvas.style.filter = 'none';
    }
    
    console.log('Applied filters:', filters.join(' ')); // Debug
}

// Reset all adjustments
document.getElementById('resetAdjustBtn').addEventListener('click', () => {
    adjustmentSliders.forEach(name => {
        const slider = document.getElementById(`${name}-slider`);
        if (slider) {
            slider.value = 0;
            adjustmentValues[name] = 0;
        }
    });
    
    // Remove modified and active class from all icons
    document.querySelectorAll('.adjust-icon-btn').forEach(btn => {
        btn.classList.remove('modified');
        btn.classList.remove('active');
    });
    
    // Reset current slider and label
    currentAdjustment = null;
    if (adjustSlider) {
        adjustSlider.value = 0;
    }
    if (adjustValueDisplay) {
        adjustValueDisplay.textContent = '';
    }
    if (adjustSelectedLabel) {
        adjustSelectedLabel.textContent = '';
    }
    updateRulerHighlight(0);
    
    // Clear all filters
    canvas.style.filter = 'none';
});

// Update slider display values
const geometrizeAlphaEl = document.getElementById("geometrizeAlpha");
const geometrizeCandidatesEl = document.getElementById("geometrizeCandidates");
const geometrizeMutationsEl = document.getElementById("geometrizeMutations");

if (geometrizeAlphaEl) {
    geometrizeAlphaEl.addEventListener("input", () => {
        document.getElementById("alphaDisplayValue").textContent = geometrizeAlphaEl.value;
    });
}
if (geometrizeCandidatesEl) {
    geometrizeCandidatesEl.addEventListener("input", () => {
        document.getElementById("candidatesValue").textContent = geometrizeCandidatesEl.value;
    });
}
if (geometrizeMutationsEl) {
    geometrizeMutationsEl.addEventListener("input", () => {
        document.getElementById("mutationsValue").textContent = geometrizeMutationsEl.value;
    });
}

/* ==========================================================
   DOWNLOAD JSON
========================================================== */

downloadJsonBtn.addEventListener("click", () => {
    // Use generatedShapes if available (from generation), otherwise currentShapes (from upload)
    const shapesToDownload = (generatedShapes && generatedShapes.length > 0) ? generatedShapes : currentShapes;
    
    if (!shapesToDownload.length) {
        alert("No shapes to download. Generate or load shapes first.");
        return;
    }
    
    const json = JSON.stringify(shapesToDownload, null, 2);
    const blob = new Blob([json], { type: "application/json" });
    const url = URL.createObjectURL(blob);
    
    const a = document.createElement("a");
    a.href = url;
    a.download = `shapes_${shapesToDownload.length}.json`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
    
    console.log(`Downloaded ${shapesToDownload.length} shapes`);
});

/* ==========================================================
   GEOMETRIZE - Client-Side Shape Generation
========================================================== */

// Get selected shape types from checkboxes
function getSelectedShapeTypes() {
    const checkboxes = document.querySelectorAll('input[name="shapeType"]:checked');
    const types = Array.from(checkboxes).map(cb => parseInt(cb.value));
    return types.length > 0 ? types : [2]; // Default to triangle
}

// Convert image to bitmap data for worker
async function imageToBitmapData(imageFile) {
    return new Promise((resolve, reject) => {
        const img = new Image();
        img.onload = () => {
            // Store the full resolution image for enhance functionality
            const fullCanvas = document.createElement('canvas');
            fullCanvas.width = img.width;
            fullCanvas.height = img.height;
            const fullCtx = fullCanvas.getContext('2d');
            fullCtx.drawImage(img, 0, 0);
            window.sourceImageData = fullCanvas; // Store for selective enhancement
            
            // Resize if too large for performance
            let width = img.width;
            let height = img.height;
            const maxDim = 256;
            
            if (width > maxDim || height > maxDim) {
                const ratio = Math.min(maxDim / width, maxDim / height);
                width = Math.floor(width * ratio);
                height = Math.floor(height * ratio);
            }
            
            const canvas = document.createElement('canvas');
            canvas.width = width;
            canvas.height = height;
            const ctx = canvas.getContext('2d');
            ctx.drawImage(img, 0, 0, width, height);
            
            const imageData = ctx.getImageData(0, 0, width, height);
            const pixels = imageData.data;
            
            // Convert to format expected by geometrize (RGBA packed into 32-bit integers)
            const data = new Array(width * height);
            let rSum = 0, gSum = 0, bSum = 0;
            
            for (let i = 0; i < width * height; i++) {
                const r = pixels[i * 4];
                const g = pixels[i * 4 + 1];
                const b = pixels[i * 4 + 2];
                const a = pixels[i * 4 + 3];
                
                rSum += r;
                gSum += g;
                bSum += b;
                
                // Pack as RGBA (r in high bits)
                data[i] = ((r & 255) << 24) | ((g & 255) << 16) | ((b & 255) << 8) | (a & 255);
            }
            
            const avgR = Math.round(rSum / (width * height));
            const avgG = Math.round(gSum / (width * height));
            const avgB = Math.round(bSum / (width * height));
            
            resolve({
                width: width,
                height: height,
                data: data,
                originalWidth: img.width,
                originalHeight: img.height,
                avgColor: [avgR, avgG, avgB, 255]
            });
        };
        img.onerror = reject;
        img.src = URL.createObjectURL(imageFile);
    });
}

// Parse the JSON string returned by geometrize library and scale coordinates
function parseAndScaleShapes(jsonString, scaleX, scaleY) {
    // The library returns a JSON string like: "    {\n        \"type\":4,\n..."
    // We need to parse it as JSON array
    try {
        const fullJson = "[\n" + jsonString + "\n]";
        const shapes = JSON.parse(fullJson);
        
        return shapes.map(shape => {
            const type = shape.type;
            const data = shape.data;
            let scaledData;
            
            switch(type) {
                case 0: // Rectangle: [x1, y1, x2, y2]
                    scaledData = [
                        Math.round(data[0] * scaleX), Math.round(data[1] * scaleY),
                        Math.round(data[2] * scaleX), Math.round(data[3] * scaleY)
                    ];
                    break;
                case 1: // Rotated Rectangle: [x1, y1, x2, y2, angle]
                    scaledData = [
                        Math.round(data[0] * scaleX), Math.round(data[1] * scaleY),
                        Math.round(data[2] * scaleX), Math.round(data[3] * scaleY),
                        data[4] // angle stays same
                    ];
                    break;
                case 2: // Triangle: [x1, y1, x2, y2, x3, y3]
                    scaledData = [
                        Math.round(data[0] * scaleX), Math.round(data[1] * scaleY),
                        Math.round(data[2] * scaleX), Math.round(data[3] * scaleY),
                        Math.round(data[4] * scaleX), Math.round(data[5] * scaleY)
                    ];
                    break;
                case 3: // Ellipse: [cx, cy, rx, ry]
                    scaledData = [
                        Math.round(data[0] * scaleX), Math.round(data[1] * scaleY),
                        Math.round(data[2] * scaleX), Math.round(data[3] * scaleY)
                    ];
                    break;
                case 4: // Rotated Ellipse: [cx, cy, rx, ry, angle]
                    scaledData = [
                        Math.round(data[0] * scaleX), Math.round(data[1] * scaleY),
                        Math.round(data[2] * scaleX), Math.round(data[3] * scaleY),
                        data[4] // angle stays same
                    ];
                    break;
                case 5: // Circle: [cx, cy, r]
                    const avgScale = (scaleX + scaleY) / 2;
                    scaledData = [
                        Math.round(data[0] * scaleX), Math.round(data[1] * scaleY),
                        Math.round(data[2] * avgScale)
                    ];
                    break;
                case 6: // Line: [x1, y1, x2, y2]
                    scaledData = [
                        Math.round(data[0] * scaleX), Math.round(data[1] * scaleY),
                        Math.round(data[2] * scaleX), Math.round(data[3] * scaleY)
                    ];
                    break;
                case 7: // Quadratic Bezier: [x1, y1, cx, cy, x2, y2]
                    scaledData = [
                        Math.round(data[0] * scaleX), Math.round(data[1] * scaleY),
                        Math.round(data[2] * scaleX), Math.round(data[3] * scaleY),
                        Math.round(data[4] * scaleX), Math.round(data[5] * scaleY)
                    ];
                    break;
                default:
                    scaledData = data;
            }
            
            return { type: type, data: scaledData, color: shape.color, score: shape.score };
        });
    } catch (e) {
        console.error("Error parsing shapes:", e, jsonString);
        return [];
    }
}

// Stop processing
stopGeometrizeBtn.addEventListener("click", () => {
    if (geometrizeWorker) {
        geometrizeWorker.terminate();
        geometrizeWorker = null;
    }
    isGeometrizing = false;
    geometrizeBtn.disabled = false;
    stopGeometrizeBtn.style.display = "none";
    progressContainer.style.display = "none";
    geometrizeStatus.textContent = "Processing stopped.";
    geometrizeStatus.style.color = "#f44336";
});

// Main geometrize function
geometrizeBtn.addEventListener("click", async () => {
    const file = geometrizeInput.files[0];
    if (!file) {
        geometrizeStatus.textContent = "Please select an image file first.";
        geometrizeStatus.style.color = "#f44336";
        return;
    }
    
    // Validate shape types (multi-select validation)
    if (!validateShapeTypes()) {
        geometrizeStatus.textContent = "Please select at least one shape type.";
        geometrizeStatus.style.color = "#f44336";
        return;
    }
    
    const shapeCount = parseInt(geometrizeShapeCount.value) || 200;
    const alpha = parseInt(geometrizeAlpha.value) || 128;
    const candidatesPerStep = parseInt(geometrizeCandidates.value) || 50;
    const mutationsPerStep = parseInt(geometrizeMutations.value) || 100;
    const shapeTypes = getSelectedShapeTypes();
    const target = document.querySelector('input[name="geometrizeTarget"]:checked').value;
    
    geometrizeBtn.disabled = true;
    stopGeometrizeBtn.style.display = "block";
    progressContainer.style.display = "block";
    geometrizePreview.style.display = "block";
    geometrizeStatus.textContent = "Loading image...";
    geometrizeStatus.style.color = "#666";
    
    try {
        // Load and convert image
        const bitmapData = await imageToBitmapData(file);
        const { width, height, data, originalWidth, originalHeight, avgColor } = bitmapData;
        
        // Calculate scale factors
        const scaleX = originalWidth / width;
        const scaleY = originalHeight / height;
        
        // Setup preview canvas
        const previewScale = Math.min(300 / originalWidth, 300 / originalHeight);
        geometrizePreview.width = Math.floor(originalWidth * previewScale);
        geometrizePreview.height = Math.floor(originalHeight * previewScale);
        previewCtx.fillStyle = `rgb(${avgColor[0]},${avgColor[1]},${avgColor[2]})`;
        previewCtx.fillRect(0, 0, geometrizePreview.width, geometrizePreview.height);
        
        // Initialize shapes with background using average color
        generatedShapes = [{
            type: 0,
            data: [0, 0, originalWidth, originalHeight],
            color: avgColor,
            score: 0
        }];
        
        isGeometrizing = true;
        let currentStep = 0;
        
        geometrizeStatus.textContent = `Processing: 0 / ${shapeCount} shapes`;
        
        // Create worker with proper message handling
        // The library's onmessage handler loses 'this' context, so we need to patch it
        let geometrizeLibCode = document.getElementById('geometrize-lib').textContent;
        
        // Patch the library: replace the broken onmessage assignment with a working one
        // Original: onmessage = GeometrizeWorker.prototype.messageHandler;
        // This loses 'this' context. We need to create an instance and bind properly.
        geometrizeLibCode = geometrizeLibCode.replace(
            'onmessage = GeometrizeWorker.prototype.messageHandler;',
            `
            var _geometrizeWorkerInstance = new GeometrizeWorker();
            _geometrizeWorkerInstance.postMessage = function(msg) { self.postMessage(msg); };
            onmessage = function(e) { _geometrizeWorkerInstance.messageHandler(e); };
            `
        );
        
        const workerBlob = new Blob([geometrizeLibCode], { type: 'application/javascript' });
        geometrizeWorker = new Worker(URL.createObjectURL(workerBlob));
        
        // Process step by step
        await new Promise((resolve, reject) => {
            geometrizeWorker.onmessage = (e) => {
                const msg = e.data;
                
                if (msg.id === "did_set_target_image") {
                    // Start stepping
                    doStep();
                }
                else if (msg.id === "did_step") {
                    if (!isGeometrizing) {
                        resolve();
                        return;
                    }
                    
                    // Parse the JSON string and scale coordinates
                    if (msg.jsonData && msg.jsonData.length > 0) {
                        console.log("Raw jsonData:", msg.jsonData);
                        try {
                            const newShapes = parseAndScaleShapes(msg.jsonData, scaleX, scaleY);
                            console.log("Parsed shapes:", newShapes);
                            generatedShapes.push(...newShapes);
                        } catch(parseErr) {
                            console.error("Parse error:", parseErr);
                        }
                    } else {
                        console.log("Empty or missing jsonData");
                    }
                    
                    currentStep++;
                    
                    // Update progress
                    const progress = (currentStep / shapeCount) * 100;
                    progressFill.style.width = progress + "%";
                    progressText.textContent = `Processing: ${currentStep} / ${shapeCount} shapes`;
                    
                    // Update preview every 10 steps for performance
                    if (currentStep % 10 === 0 || currentStep >= shapeCount) {
                        drawPreview(generatedShapes, originalWidth, originalHeight);
                    }
                    
                    if (currentStep >= shapeCount) {
                        resolve();
                    } else {
                        doStep();
                    }
                }
            };
            
            geometrizeWorker.onerror = (err) => {
                console.error("Worker error:", err);
                reject(err);
            };
            
            function doStep() {
                geometrizeWorker.postMessage({
                    id: "should_step",
                    data: {
                        shapeTypes: shapeTypes,
                        alpha: alpha,
                        candidateShapesPerStep: candidatesPerStep,
                        shapeMutationsPerStep: mutationsPerStep
                    }
                });
            }
            
            // Send target image to worker
            geometrizeWorker.postMessage({
                id: "should_set_target_image",
                data: { width, height, data }
            });
        });
        
        // Processing complete
        if (geometrizeWorker) {
            geometrizeWorker.terminate();
            geometrizeWorker = null;
        }
        
        isGeometrizing = false;
        geometrizeBtn.disabled = false;
        stopGeometrizeBtn.style.display = "none";
        
        // Auto-load generated shapes
        if (target === "base") {
            baseShapes = [...generatedShapes];
            currentShapes = [...baseShapes];
            groupedShapes = [...currentShapes];
            
            window.sourceWidth = null;
            window.sourceHeight = null;
            
            baseFileStatus.textContent = `‚úì Loaded ${generatedShapes.length} shapes`;
            downloadJsonBtn.disabled = false;
            
            updateRender();
            
            // Enable color picker and show panel when shapes are generated
            isPickingColor = true;
            colorPickerBtn.classList.add("active");
            colorPickerBtn.textContent = "Disable Color Picker";
            canvas.classList.add("picking");
            colorPickerPanel.classList.add("active");
            
            geometrizeStatus.textContent = `‚úì Generated ${generatedShapes.length} shapes as Base (${originalWidth}x${originalHeight})`;
        } else {
            detailShapes = [...generatedShapes];
            detailFileStatus.textContent = `‚úì Loaded ${generatedShapes.length} shapes`;
            
            geometrizeStatus.textContent = `‚úì Generated ${generatedShapes.length} shapes as Detail (${originalWidth}x${originalHeight})`;
        }
        downloadJsonBtn.disabled = false;
        
        geometrizeStatus.style.color = "#4CAF50";
        
    } catch (err) {
        console.error("Geometrize error:", err);
        geometrizeStatus.textContent = `Error: ${err.message}`;
        geometrizeStatus.style.color = "#f44336";
        
        if (geometrizeWorker) {
            geometrizeWorker.terminate();
            geometrizeWorker = null;
        }
        isGeometrizing = false;
        geometrizeBtn.disabled = false;
        stopGeometrizeBtn.style.display = "none";
    }
});

// Draw preview of generated shapes
function drawPreview(shapes, srcWidth, srcHeight) {
    const scale = Math.min(geometrizePreview.width / srcWidth, geometrizePreview.height / srcHeight);
    
    previewCtx.fillStyle = "white";
    previewCtx.fillRect(0, 0, geometrizePreview.width, geometrizePreview.height);
    
    shapes.forEach(s => {
        const [r, g, b, a] = s.color;
        previewCtx.fillStyle = `rgba(${r},${g},${b},${a / 255})`;
        previewCtx.strokeStyle = `rgba(${r},${g},${b},${a / 255})`;
        
        if (s.type === 0) {
            // Rectangle
            const [x1, y1, x2, y2] = s.data;
            const rx = Math.min(x1, x2) * scale;
            const ry = Math.min(y1, y2) * scale;
            const rw = Math.abs(x2 - x1) * scale;
            const rh = Math.abs(y2 - y1) * scale;
            previewCtx.fillRect(rx, ry, rw, rh);
        }
        else if (s.type === 1) {
            // Rotated Rectangle
            const [x1, y1, x2, y2, angle] = s.data;
            const cx = ((x1 + x2) / 2) * scale;
            const cy = ((y1 + y2) / 2) * scale;
            const w = Math.abs(x2 - x1) * scale;
            const h = Math.abs(y2 - y1) * scale;
            
            previewCtx.save();
            previewCtx.translate(cx, cy);
            previewCtx.rotate((angle || 0) * Math.PI / 180);
            previewCtx.fillRect(-w / 2, -h / 2, w, h);
            previewCtx.restore();
        }
        else if (s.type === 2) {
            // Triangle
            const [A, B, C, D, E, F] = s.data;
            previewCtx.beginPath();
            previewCtx.moveTo(A * scale, B * scale);
            previewCtx.lineTo(C * scale, D * scale);
            previewCtx.lineTo(E * scale, F * scale);
            previewCtx.closePath();
            previewCtx.fill();
        }
        else if (s.type === 3) {
            // Ellipse
            const [cx, cy, rx, ry] = s.data;
            previewCtx.beginPath();
            previewCtx.ellipse(cx * scale, cy * scale, rx * scale, ry * scale, 0, 0, Math.PI * 2);
            previewCtx.fill();
        }
        else if (s.type === 4) {
            // Rotated Ellipse
            const [cx, cy, rx, ry, ang] = s.data;
            previewCtx.save();
            previewCtx.translate(cx * scale, cy * scale);
            previewCtx.rotate((ang || 0) * Math.PI / 180);
            previewCtx.beginPath();
            previewCtx.ellipse(0, 0, rx * scale, ry * scale, 0, 0, Math.PI * 2);
            previewCtx.fill();
            previewCtx.restore();
        }
        else if (s.type === 5) {
            // Circle
            const [cx, cy, rad] = s.data;
            previewCtx.beginPath();
            previewCtx.arc(cx * scale, cy * scale, rad * scale, 0, Math.PI * 2);
            previewCtx.fill();
        }
        else if (s.type === 6) {
            // Line
            const [x1, y1, x2, y2] = s.data;
            previewCtx.lineWidth = 1;
            previewCtx.beginPath();
            previewCtx.moveTo(x1 * scale, y1 * scale);
            previewCtx.lineTo(x2 * scale, y2 * scale);
            previewCtx.stroke();
        }
        else if (s.type === 7) {
            // Quadratic Bezier
            const [x1, y1, cx, cy, x2, y2] = s.data;
            previewCtx.lineWidth = 1;
            previewCtx.beginPath();
            previewCtx.moveTo(x1 * scale, y1 * scale);
            previewCtx.quadraticCurveTo(cx * scale, cy * scale, x2 * scale, y2 * scale);
            previewCtx.stroke();
        }
    });
}

/* ==========================================================
   LOAD JSON
========================================================== */

baseFileInput.addEventListener("change", async e => {
    const file = e.target.files[0];
    if (!file) return;

    const text = await file.text();
    baseShapes = JSON.parse(text);

    currentShapes = [...baseShapes];
    groupedShapes = [...currentShapes];
    
    // Clear stored dimensions so getImageRect uses background shape
    window.sourceWidth = null;
    window.sourceHeight = null;

    baseFileStatus.textContent = `Loaded (${baseShapes.length} shapes)`;
    downloadJsonBtn.disabled = false;

    updateRender();
    
    // Enable color picker and show panel when shapes are loaded
    isPickingColor = true;
    colorPickerBtn.classList.add("active");
    colorPickerBtn.textContent = "Disable Color Picker";
    canvas.classList.add("picking");
    colorPickerPanel.classList.add("active");
});

detailFileInput.addEventListener("change", async e => {
    const file = e.target.files[0];
    if (!file) return;

    const text = await file.text();
    detailShapes = JSON.parse(text);
    detailFileStatus.textContent = `Loaded (${detailShapes.length} shapes)`;
});

/* ==========================================================
   REGION SELECTION
========================================================== */

selectRegionsBtn.addEventListener("click", () => {
    isSelecting = !isSelecting;
    selectRegionsBtn.classList.toggle("active", isSelecting);
    selectRegionsBtn.textContent = isSelecting ? "Stop Selecting" : "Select Regions for Detail";
    
    // Disable color picker when region selection is active
    if (isSelecting && isPickingColor) {
        isPickingColor = false;
        colorPickerBtn.classList.remove("active");
        colorPickerBtn.textContent = "Enable Color Picker";
        canvas.classList.remove("picking");
        colorPickerPanel.classList.remove("active");
        clearShapeHighlight();
    }
    
    // Disable selective resolution mode when region selection is active
    if (isSelecting && isSelectiveResolutionMode) {
        isSelectiveResolutionMode = false;
        document.getElementById('selectiveResolutionIcon')?.classList.remove('active');
    }
});

clearRegionsBtn.addEventListener("click", () => {
    regions = [];
    updateRegionUI();
    updateRender();
});

// Draw region overlay on canvas during selection
// function drawRegionOverlay(region, isSelecting = false) {
//     if (!region) return;
//     
//     ctx.save();
//     ctx.strokeStyle = isSelecting ? "#7c4dff" : "#4CAF50";
//     ctx.lineWidth = 2;
//     ctx.setLineDash([5, 5]);
//     ctx.fillStyle = isSelecting ? "rgba(124, 77, 255, 0.1)" : "rgba(76, 175, 80, 0.1)";
//     
//     ctx.fillRect(region.x, region.y, region.width, region.height);
//     ctx.strokeRect(region.x, region.y, region.width, region.height);
//     
//     ctx.restore();
// }

canvas.addEventListener("mousedown", e => {
    if (!isSelecting || isSelectiveResolutionMode) return;

    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;

    isDrawingPath = true;
    currentPath = [{ x, y }];
});

canvas.addEventListener("mousemove", e => {
    if (!isSelecting || !isDrawingPath || isSelectiveResolutionMode) return;

    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;

    currentPath.push({ x, y });

    drawCanvas();
    drawCurrentPath();
});

canvas.addEventListener("mouseup", e => {
    if (!isSelecting || !isDrawingPath || isSelectiveResolutionMode) return;

    isDrawingPath = false;

    // Need at least 3 points to form a region
    if (currentPath.length < 3) {
        currentPath = [];
        return;
    }

    const imgRect = getImageRect();
    const scale = imgRect.scale;

    // Convert canvas coordinates to image coordinates
    const pathPoints = currentPath.map(p => ({
        x: (p.x - imgRect.x) / scale,
        y: (p.y - imgRect.y) / scale
    }));

    // Simplify path to reduce points (keeps every Nth point)
    const simplified = simplifyPath(pathPoints, 50);

    if (simplified.length >= 3) {
        regions.push({ type: 'polygon', points: simplified });
    }

    currentPath = [];
    updateRegionUI();
    updateRender();
});

// Handle mouse leaving canvas while drawing
canvas.addEventListener("mouseleave", e => {
    if (isDrawingPath && currentPath.length >= 3) {
        canvas.dispatchEvent(new MouseEvent('mouseup'));
    }
});

function drawCurrentPath() {
    if (currentPath.length < 2) return;

    ctx.save();
    ctx.strokeStyle = "#7c4dff";
    ctx.lineWidth = 3;
    ctx.lineCap = "round";
    ctx.lineJoin = "round";

    ctx.beginPath();
    ctx.moveTo(currentPath[0].x, currentPath[0].y);
    for (let i = 1; i < currentPath.length; i++) {
        ctx.lineTo(currentPath[i].x, currentPath[i].y);
    }
    ctx.stroke();
    ctx.restore();
}

function simplifyPath(points, maxPoints) {
    if (points.length <= maxPoints) return points;
    const step = Math.max(1, Math.floor(points.length / maxPoints));
    const result = [];
    for (let i = 0; i < points.length; i += step) {
        result.push(points[i]);
    }
    // Always include the last point
    if (result[result.length - 1] !== points[points.length - 1]) {
        result.push(points[points.length - 1]);
    }
    return result;
}

/* ==========================================================
   REGION UI
========================================================== */

function updateRegionUI() {
    regionOverlay.innerHTML = "";

    if (regions.length === 0) {
        regionList.style.display = "none";
        return;
    }

    regionList.style.display = "block";
    regionList.innerHTML = `<strong>Selected Regions (${regions.length}):</strong>`;

    const imgRect = getImageRect();
    const scale = imgRect.scale;

    regions.forEach((r, i) => {
        if (r.type === 'polygon' && r.points) {
            // Create SVG for freehand region
            const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
            svg.classList.add("region-svg");
            svg.style.left = "0px";
            svg.style.top = "0px";
            svg.style.width = canvas.width + "px";
            svg.style.height = canvas.height + "px";

            const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
            let d = `M ${imgRect.x + r.points[0].x * scale} ${imgRect.y + r.points[0].y * scale}`;
            for (let j = 1; j < r.points.length; j++) {
                d += ` L ${imgRect.x + r.points[j].x * scale} ${imgRect.y + r.points[j].y * scale}`;
            }
            path.setAttribute("d", d);
            path.setAttribute("fill", "none");
            path.setAttribute("stroke", "#FF5722");
            path.setAttribute("stroke-width", "3");
            path.setAttribute("stroke-linecap", "round");
            path.setAttribute("stroke-linejoin", "round");

            svg.appendChild(path);
            regionOverlay.appendChild(svg);

            // Calculate bounding box for display
            const xs = r.points.map(p => p.x);
            const ys = r.points.map(p => p.y);
            const width = Math.round(Math.max(...xs) - Math.min(...xs));
            const height = Math.round(Math.max(...ys) - Math.min(...ys));

            const item = document.createElement("div");
            item.className = "region-item";
            item.innerHTML = `
                Region ${i + 1}: ~${width}√ó${height} (${r.points.length} pts)
                <button onclick="removeRegion(${i})">Remove</button>
            `;
            regionList.appendChild(item);
        } else {
            // Legacy rectangle support
            const box = document.createElement("div");
            box.className = "region-box";
            box.style.left = imgRect.x + r.x * scale + "px";
            box.style.top = imgRect.y + r.y * scale + "px";
            box.style.width = r.width * scale + "px";
            box.style.height = r.height * scale + "px";
            box.style.border = "3px solid #FF5722";
            box.style.background = "rgba(255, 87, 34, 0.2)";

            regionOverlay.appendChild(box);

            const item = document.createElement("div");
            item.className = "region-item";
            item.innerHTML = `
                Region ${i + 1}: ${Math.round(r.width)}√ó${Math.round(r.height)}
                <button onclick="removeRegion(${i})">Remove</button>
            `;
            regionList.appendChild(item);
        }
    });
}

window.removeRegion = function(i) {
    regions.splice(i, 1);
    updateRegionUI();
    updateRender();
};

/* ==========================================================
   IMAGE SCALE HELPERS
========================================================== */

function getImageRect() {
    const bg = currentShapes.find(s => s.type === 0);
    let w = 600, h = 600;

    if (bg) {
        const [x1, y1, x2, y2] = bg.data;
        w = Math.abs(x2 - x1) || x2 || 600;
        h = Math.abs(y2 - y1) || y2 || 600;
    }
    
    // Use stored source dimensions if available (from geometrize)
    if (window.sourceWidth && window.sourceHeight) {
        w = window.sourceWidth;
        h = window.sourceHeight;
    }

    const scale = Math.min(canvas.width / w, canvas.height / h);
    const x = (canvas.width - w * scale) / 2;
    const y = (canvas.height - h * scale) / 2;

    return { x, y, w, h, scale };
}

/* ==========================================================
   ENHANCE SELECTED REGIONS (NEW SIMPLIFIED APPROACH)
========================================================== */

// Enhance multiplier - how many times more shapes to generate in selected regions
const ENHANCE_MULTIPLIER = 3; // Generate 3x more shapes in regions

// Make function global
window.enhanceSelectedRegions = async function() {
    console.log("=== ENHANCE STARTED (OPTIMIZED) ===");
    
    if (!currentShapes.length) {
        alert("Load shapes first.");
        return;
    }
    if (!regions.length) {
        alert("Select regions first by drawing on the canvas.");
        return;
    }
    
    // Get settings from UI - use reduced values for enhance mode (speed over perfect quality)
    const shapesPerRegion = Math.max(20, Math.round(currentShapes.length * 0.25 / regions.length));
    const alpha = parseInt(geometrizeAlpha.value) || 128;
    // Use lower candidates/mutations for enhance - regions are small so fewer iterations needed
    const candidatesPerStep = Math.min(parseInt(geometrizeCandidates.value) || 50, 30);
    const mutationsPerStep = Math.min(parseInt(geometrizeMutations.value) || 100, 50);
    const shapeTypes = getSelectedShapeTypes();
    
    const progressDiv = document.getElementById('enhanceProgress');
    const progressFill = document.getElementById('enhanceProgressFill');
    const progressText = document.getElementById('enhanceProgressText');
    
    progressDiv.style.display = 'block';
    progressFill.style.width = '0%';
    progressText.textContent = 'Preparing regions...';
    
    try {
        // Check if we have the original source image
        if (!window.sourceImageData) {
            alert("No source image available. Please generate shapes from an image first.");
            progressDiv.style.display = 'none';
            return;
        }
        
        const sourceCanvas = window.sourceImageData;
        const imgRect = getImageRect();
        
        // Prepare worker code once
        let geometrizeLibCode = document.getElementById('geometrize-lib').textContent;
        geometrizeLibCode = geometrizeLibCode.replace(
            'onmessage = GeometrizeWorker.prototype.messageHandler;',
            `
            var _geometrizeWorkerInstance = new GeometrizeWorker();
            _geometrizeWorkerInstance.postMessage = function(msg) { self.postMessage(msg); };
            onmessage = function(e) { _geometrizeWorkerInstance.messageHandler(e); };
            `
        );
        const workerBlob = new Blob([geometrizeLibCode], { type: 'application/javascript' });
        
        let totalShapesAdded = 0;
        const totalShapesTarget = shapesPerRegion * regions.length;
        
        // Process each region separately - this is the key optimization!
        for (let regionIdx = 0; regionIdx < regions.length; regionIdx++) {
            const region = regions[regionIdx];
            
            progressText.textContent = `Region ${regionIdx + 1}/${regions.length}: Preparing...`;
            
            // Region points are already in IMAGE coordinates (not canvas coordinates)
            // Calculate bounding box directly from region points
            let imgMinX = Infinity, imgMinY = Infinity, imgMaxX = -Infinity, imgMaxY = -Infinity;
            for (const pt of region.points) {
                imgMinX = Math.min(imgMinX, pt.x);
                imgMinY = Math.min(imgMinY, pt.y);
                imgMaxX = Math.max(imgMaxX, pt.x);
                imgMaxY = Math.max(imgMaxY, pt.y);
            }
            
            // Add some padding and clamp to source image bounds
            const padding = 5;
            imgMinX = Math.max(0, Math.floor(imgMinX - padding));
            imgMinY = Math.max(0, Math.floor(imgMinY - padding));
            imgMaxX = Math.min(sourceCanvas.width, Math.ceil(imgMaxX + padding));
            imgMaxY = Math.min(sourceCanvas.height, Math.ceil(imgMaxY + padding));
            
            const cropWidth = imgMaxX - imgMinX;
            const cropHeight = imgMaxY - imgMinY;
            
            if (cropWidth < 10 || cropHeight < 10) {
                console.log(`Region ${regionIdx} too small, skipping`);
                continue;
            }
            
            // Extract region from ORIGINAL SOURCE IMAGE (not the canvas!)
            const cropCanvas = document.createElement('canvas');
            cropCanvas.width = cropWidth;
            cropCanvas.height = cropHeight;
            const cropCtx = cropCanvas.getContext('2d');
            
            // Copy from the original source image
            cropCtx.drawImage(
                sourceCanvas, 
                imgMinX, imgMinY, cropWidth, cropHeight,
                0, 0, cropWidth, cropHeight
            );
            
            // Downscale for geometrize (use 256 for better detail)
            const maxDim = 256;
            let workWidth = cropWidth;
            let workHeight = cropHeight;
            
            if (workWidth > maxDim || workHeight > maxDim) {
                const ratio = Math.min(maxDim / workWidth, maxDim / workHeight);
                workWidth = Math.floor(workWidth * ratio);
                workHeight = Math.floor(workHeight * ratio);
            }
            
            const workCanvas = document.createElement('canvas');
            workCanvas.width = workWidth;
            workCanvas.height = workHeight;
            const workCtx = workCanvas.getContext('2d');
            workCtx.drawImage(cropCanvas, 0, 0, workWidth, workHeight);
            
            const imageData = workCtx.getImageData(0, 0, workWidth, workHeight);
            const pixels = imageData.data;
            
            // Convert to geometrize format
            const data = new Array(workWidth * workHeight);
            for (let i = 0; i < workWidth * workHeight; i++) {
                const r = pixels[i * 4];
                const g = pixels[i * 4 + 1];
                const b = pixels[i * 4 + 2];
                const a = pixels[i * 4 + 3];
                data[i] = ((r & 255) << 24) | ((g & 255) << 16) | ((b & 255) << 8) | (a & 255);
            }
            
            // Scale factors: from work coords to original image coords
            const scaleX = cropWidth / workWidth;
            const scaleY = cropHeight / workHeight;
            
            // Offset in original image coordinates
            const offsetX = imgMinX;
            const offsetY = imgMinY;
            
            // Run geometrize on this small region
            const worker = new Worker(URL.createObjectURL(workerBlob));
            let regionStep = 0;
            
            await new Promise((resolve, reject) => {
                worker.onmessage = (e) => {
                    const msg = e.data;
                    
                    if (msg.id === "did_set_target_image") {
                        doStep();
                    }
                    else if (msg.id === "did_step") {
                        if (msg.jsonData && msg.jsonData.length > 0) {
                            try {
                                // Parse and transform shapes
                                const fullJson = "[\n" + msg.jsonData + "\n]";
                                const shapes = JSON.parse(fullJson);
                                
                                for (const shape of shapes) {
                                    const transformedShape = transformRegionShape(
                                        shape, 
                                        scaleX, scaleY, 
                                        offsetX, offsetY
                                    );
                                    currentShapes.push(transformedShape);
                                }
                            } catch(parseErr) {
                                console.error("Parse error:", parseErr);
                            }
                        }
                        
                        regionStep++;
                        totalShapesAdded++;
                        
                        // Update progress bar only (lightweight)
                        const progress = (totalShapesAdded / totalShapesTarget) * 100;
                        progressFill.style.width = progress + "%";
                        
                        // Update text and canvas only every 10 shapes (like main generate)
                        if (regionStep % 10 === 0 || regionStep >= shapesPerRegion) {
                            progressText.textContent = `Region ${regionIdx + 1}/${regions.length}: ${regionStep}/${shapesPerRegion} shapes`;
                            slider.max = currentShapes.length;
                            slider.value = currentShapes.length;
                            sliderLabel.textContent = `Shapes: ${currentShapes.length} / ${currentShapes.length}`;
                        }
                        
                        if (regionStep >= shapesPerRegion) {
                            resolve();
                        } else {
                            doStep();
                        }
                    }
                };
                
                worker.onerror = (err) => {
                    console.error("Worker error:", err);
                    reject(err);
                };
                
                function doStep() {
                    worker.postMessage({
                        id: "should_step",
                        data: {
                            shapeTypes: shapeTypes,
                            alpha: alpha,
                            candidateShapesPerStep: candidatesPerStep,
                            shapeMutationsPerStep: mutationsPerStep
                        }
                    });
                }
                
                // Send the small cropped image to worker
                worker.postMessage({
                    id: "should_set_target_image",
                    data: { width: workWidth, height: workHeight, data }
                });
            });
            
            worker.terminate();
        }
        
        // Sync groupedShapes and draw canvas only once at the very end
        groupedShapes = [...currentShapes];
        drawCanvas();
        
        progressFill.style.width = '100%';
        progressText.textContent = `Done! Added ${totalShapesAdded} shapes. Total: ${currentShapes.length}`;
        
        setTimeout(() => {
            progressDiv.style.display = 'none';
        }, 2000);
        
        populateSequenceFilterChips();
        
    } catch (error) {
        console.error('Enhancement error:', error);
        alert('Error: ' + error.message);
        progressDiv.style.display = 'none';
    }
}

// Helper function to transform a shape from region coordinates to image coordinates
function transformRegionShape(shape, scaleX, scaleY, offsetX, offsetY) {
    const type = shape.type;
    const data = shape.data;
    let scaledData;
    
    switch(type) {
        case 0: // Rectangle: [x1, y1, x2, y2]
            scaledData = [
                Math.round(data[0] * scaleX + offsetX), Math.round(data[1] * scaleY + offsetY),
                Math.round(data[2] * scaleX + offsetX), Math.round(data[3] * scaleY + offsetY)
            ];
            break;
        case 1: // Rotated Rectangle: [x1, y1, x2, y2, angle]
            scaledData = [
                Math.round(data[0] * scaleX + offsetX), Math.round(data[1] * scaleY + offsetY),
                Math.round(data[2] * scaleX + offsetX), Math.round(data[3] * scaleY + offsetY),
                data[4]
            ];
            break;
        case 2: // Triangle: [x1, y1, x2, y2, x3, y3]
            scaledData = [
                Math.round(data[0] * scaleX + offsetX), Math.round(data[1] * scaleY + offsetY),
                Math.round(data[2] * scaleX + offsetX), Math.round(data[3] * scaleY + offsetY),
                Math.round(data[4] * scaleX + offsetX), Math.round(data[5] * scaleY + offsetY)
            ];
            break;
        case 3: // Ellipse: [cx, cy, rx, ry]
            scaledData = [
                Math.round(data[0] * scaleX + offsetX), Math.round(data[1] * scaleY + offsetY),
                Math.round(data[2] * scaleX), Math.round(data[3] * scaleY)
            ];
            break;
        case 4: // Rotated Ellipse: [cx, cy, rx, ry, angle]
            scaledData = [
                Math.round(data[0] * scaleX + offsetX), Math.round(data[1] * scaleY + offsetY),
                Math.round(data[2] * scaleX), Math.round(data[3] * scaleY),
                data[4]
            ];
            break;
        case 5: // Circle: [cx, cy, r]
            const avgScale = (scaleX + scaleY) / 2;
            scaledData = [
                Math.round(data[0] * scaleX + offsetX), Math.round(data[1] * scaleY + offsetY),
                Math.round(data[2] * avgScale)
            ];
            break;
        case 6: // Line: [x1, y1, x2, y2]
            scaledData = [
                Math.round(data[0] * scaleX + offsetX), Math.round(data[1] * scaleY + offsetY),
                Math.round(data[2] * scaleX + offsetX), Math.round(data[3] * scaleY + offsetY)
            ];
            break;
        case 7: // Quadratic Bezier: [x1, y1, cx, cy, x2, y2]
            scaledData = [
                Math.round(data[0] * scaleX + offsetX), Math.round(data[1] * scaleY + offsetY),
                Math.round(data[2] * scaleX + offsetX), Math.round(data[3] * scaleY + offsetY),
                Math.round(data[4] * scaleX + offsetX), Math.round(data[5] * scaleY + offsetY)
            ];
            break;
        default:
            scaledData = data.map((v, i) => i % 2 === 0 ? Math.round(v * scaleX + offsetX) : Math.round(v * scaleY + offsetY));
    }
    
    return {
        type: type,
        data: scaledData,
        color: shape.color,
        score: shape.score
    };
}

// Event listeners for enhance buttons
applyEnhanceBtn?.addEventListener("click", enhanceSelectedRegions);

/* ==========================================================
   SELECTIVE RESOLUTION TOOL
========================================================== */

const selectiveResolutionIcon = document.getElementById('selectiveResolutionIcon');

selectiveResolutionIcon?.addEventListener('click', () => {
    if (!currentShapes.length) {
        alert("Generate or load shapes first before using selective resolution.");
        return;
    }
    
    isSelectiveResolutionMode = !isSelectiveResolutionMode;
    selectiveResolutionIcon.classList.toggle('active', isSelectiveResolutionMode);
    
    if (isSelectiveResolutionMode) {
        canvas.style.cursor = 'crosshair';
        // Disable other modes
        isPickingColor = false;
        colorPickerBtn?.classList.remove('active');
        isSelecting = false;
        selectRegionsBtn?.classList.remove('active');
    } else {
        canvas.style.cursor = 'default';
    }
});

// Handle selective resolution drawing on canvas
let isDrawingSelectiveRegion = false;

canvas.addEventListener('mousedown', (e) => {
    if (!isSelectiveResolutionMode) return;
    
    isDrawingSelectiveRegion = true;
    selectiveResolutionPath = [{ x: e.offsetX, y: e.offsetY }];
});

canvas.addEventListener('mousemove', (e) => {
    if (!isSelectiveResolutionMode || !isDrawingSelectiveRegion) return;
    
    selectiveResolutionPath.push({ x: e.offsetX, y: e.offsetY });
    
    // Draw the path preview
    drawCanvas();
    drawSelectiveResolutionPath();
});

canvas.addEventListener('mouseup', async (e) => {
    if (!isSelectiveResolutionMode || !isDrawingSelectiveRegion) return;
    
    isDrawingSelectiveRegion = false;
    
    if (selectiveResolutionPath.length < 3) {
        selectiveResolutionPath = [];
        drawCanvas();
        return;
    }
    
    // Process the region automatically
    await processSelectiveResolution();
    
    selectiveResolutionPath = [];
    drawCanvas();
});

function drawSelectiveResolutionPath() {
    if (selectiveResolutionPath.length < 2) return;
    
    ctx.save();
    ctx.strokeStyle = "#2196F3";
    ctx.lineWidth = 2;
    ctx.setLineDash([5, 5]);
    ctx.lineCap = "round";
    ctx.lineJoin = "round";
    
    ctx.beginPath();
    ctx.moveTo(selectiveResolutionPath[0].x, selectiveResolutionPath[0].y);
    for (let i = 1; i < selectiveResolutionPath.length; i++) {
        ctx.lineTo(selectiveResolutionPath[i].x, selectiveResolutionPath[i].y);
    }
    ctx.closePath();
    ctx.stroke();
    
    // Fill with semi-transparent
    ctx.fillStyle = "rgba(33, 150, 243, 0.1)";
    ctx.fill();
    
    ctx.restore();
}

async function processSelectiveResolution() {
    // Check if we have the original source image
    if (!window.sourceImageData) {
        alert("No source image available. Please generate shapes from an image first.");
        return;
    }
    
    const imgRect = getImageRect();
    const sourceCanvas = window.sourceImageData;
    
    // Convert canvas coordinates to IMAGE coordinates (not canvas coordinates)
    // The drawn path is in canvas coordinates, we need to map to original image coordinates
    let minCanvasX = Infinity, minCanvasY = Infinity, maxCanvasX = -Infinity, maxCanvasY = -Infinity;
    for (const pt of selectiveResolutionPath) {
        minCanvasX = Math.min(minCanvasX, pt.x);
        minCanvasY = Math.min(minCanvasY, pt.y);
        maxCanvasX = Math.max(maxCanvasX, pt.x);
        maxCanvasY = Math.max(maxCanvasY, pt.y);
    }
    
    // Convert canvas bounding box to original image coordinates
    const padding = 5;
    let imgMinX = Math.max(0, Math.floor((minCanvasX - imgRect.x) / imgRect.scale - padding));
    let imgMinY = Math.max(0, Math.floor((minCanvasY - imgRect.y) / imgRect.scale - padding));
    let imgMaxX = Math.min(sourceCanvas.width, Math.ceil((maxCanvasX - imgRect.x) / imgRect.scale + padding));
    let imgMaxY = Math.min(sourceCanvas.height, Math.ceil((maxCanvasY - imgRect.y) / imgRect.scale + padding));
    
    const cropWidth = imgMaxX - imgMinX;
    const cropHeight = imgMaxY - imgMinY;
    
    if (cropWidth < 10 || cropHeight < 10) {
        return; // Region too small
    }
    
    // Show processing indicator
    const originalCursor = canvas.style.cursor;
    canvas.style.cursor = 'wait';
    selectiveResolutionIcon.disabled = true;
    
    try {
        // Fixed settings for automatic operation - no user input needed
        const shapesForRegion = 40; // Fixed number of shapes
        const alpha = 128;
        const candidatesPerStep = 30; // Fast settings
        const mutationsPerStep = 50;
        const shapeTypes = getSelectedShapeTypes();
        
        // Get worker code
        let geometrizeLibCode = document.getElementById('geometrize-lib').textContent;
        geometrizeLibCode = geometrizeLibCode.replace(
            'onmessage = GeometrizeWorker.prototype.messageHandler;',
            `
            var _geometrizeWorkerInstance = new GeometrizeWorker();
            _geometrizeWorkerInstance.postMessage = function(msg) { self.postMessage(msg); };
            onmessage = function(e) { _geometrizeWorkerInstance.messageHandler(e); };
            `
        );
        const workerBlob = new Blob([geometrizeLibCode], { type: 'application/javascript' });
        
        // Extract region from ORIGINAL SOURCE IMAGE (not the canvas!)
        const cropCanvas = document.createElement('canvas');
        cropCanvas.width = cropWidth;
        cropCanvas.height = cropHeight;
        const cropCtx = cropCanvas.getContext('2d');
        
        // Draw from the original source image
        cropCtx.drawImage(sourceCanvas, imgMinX, imgMinY, cropWidth, cropHeight, 0, 0, cropWidth, cropHeight);
        
        // Downscale for geometrize (use higher resolution for better detail - 256 instead of 128)
        const maxDim = 256;
        let workWidth = cropWidth;
        let workHeight = cropHeight;
        
        if (workWidth > maxDim || workHeight > maxDim) {
            const ratio = Math.min(maxDim / workWidth, maxDim / workHeight);
            workWidth = Math.floor(workWidth * ratio);
            workHeight = Math.floor(workHeight * ratio);
        }
        
        const workCanvas = document.createElement('canvas');
        workCanvas.width = workWidth;
        workCanvas.height = workHeight;
        const workCtx = workCanvas.getContext('2d');
        workCtx.drawImage(cropCanvas, 0, 0, workWidth, workHeight);
        
        const imageData = workCtx.getImageData(0, 0, workWidth, workHeight);
        const pixels = imageData.data;
        
        // Convert to geometrize format
        const data = new Array(workWidth * workHeight);
        for (let i = 0; i < workWidth * workHeight; i++) {
            const r = pixels[i * 4];
            const g = pixels[i * 4 + 1];
            const b = pixels[i * 4 + 2];
            const a = pixels[i * 4 + 3];
            data[i] = ((r & 255) << 24) | ((g & 255) << 16) | ((b & 255) << 8) | (a & 255);
        }
        
        // Scale factors - from work coordinates to original image coordinates
        const scaleX = cropWidth / workWidth;
        const scaleY = cropHeight / workHeight;
        // Offset in original image coordinates
        const offsetX = imgMinX;
        const offsetY = imgMinY;
        
        // Run geometrize
        const worker = new Worker(URL.createObjectURL(workerBlob));
        let stepCount = 0;
        
        await new Promise((resolve, reject) => {
            worker.onmessage = (e) => {
                const msg = e.data;
                
                if (msg.id === "did_set_target_image") {
                    doStep();
                }
                else if (msg.id === "did_step") {
                    if (msg.jsonData && msg.jsonData.length > 0) {
                        try {
                            const fullJson = "[\n" + msg.jsonData + "\n]";
                            const shapes = JSON.parse(fullJson);
                            
                            for (const shape of shapes) {
                                const transformedShape = transformRegionShape(
                                    shape, scaleX, scaleY, offsetX, offsetY
                                );
                                currentShapes.push(transformedShape);
                            }
                        } catch(e) {
                            console.error("Parse error:", e);
                        }
                    }
                    
                    stepCount++;
                    
                    if (stepCount >= shapesForRegion) {
                        resolve();
                    } else {
                        doStep();
                    }
                }
            };
            
            worker.onerror = reject;
            
            function doStep() {
                worker.postMessage({
                    id: "should_step",
                    data: {
                        shapeTypes: shapeTypes,
                        alpha: alpha,
                        candidateShapesPerStep: candidatesPerStep,
                        shapeMutationsPerStep: mutationsPerStep
                    }
                });
            }
            
            worker.postMessage({
                id: "should_set_target_image",
                data: { width: workWidth, height: workHeight, data }
            });
        });
        
        worker.terminate();
        
        // Update UI
        groupedShapes = [...currentShapes];
        slider.max = currentShapes.length;
        slider.value = currentShapes.length;
        sliderLabel.textContent = `Shapes: ${currentShapes.length} / ${currentShapes.length}`;
        
        drawCanvas();
        populateSequenceFilterChips();
        
    } catch (error) {
        console.error('Selective resolution error:', error);
    } finally {
        canvas.style.cursor = originalCursor;
        selectiveResolutionIcon.disabled = false;
    }
}

/* ==========================================================
   BAKE OPAQUE ‚Äî PAGE 31 FIX
========================================================== */

bakeOpaqueBtn.addEventListener("click", async () => {
    if (!currentShapes.length) {
        alert("Load shapes first.");
        return;
    }

    // Render final image to canvas
    drawCanvas();

    const pngBlob = await new Promise(resolve => canvas.toBlob(resolve, "image/png"));

    const form = new FormData();
    form.append("file", pngBlob, "render.png");
    form.append(
        "request",
        new Blob(
            [JSON.stringify({ shapes: currentShapes, logic: "original", limit: null })],
            { type: "application/json" }
        )
    );

    const res = await fetch(`${API_BASE}/bake_opaque`, {
        method: "POST",
        body: form
    });

    const data = await res.json();

    currentShapes = [...data.shapes];
    groupedShapes = [...currentShapes];
    colorTolerance = 0;

    alert("Baked successfully! Shapes are now order-independent.");

    updateRender();
});

/* ==========================================================
   COLOR PICKER TOOL
========================================================== */

colorPickerBtn.addEventListener("click", () => {
    isPickingColor = !isPickingColor;
    colorPickerBtn.classList.toggle("active", isPickingColor);
    colorPickerBtn.textContent = isPickingColor ? "Disable Color Picker" : "Enable Color Picker";
    canvas.classList.toggle("picking", isPickingColor);
    
    // Disable region selection when color picking is active
    if (isPickingColor && isSelecting) {
        isSelecting = false;
        selectRegionsBtn.classList.remove("active");
        selectRegionsBtn.textContent = "Select Regions for Detail";
    }
    
    if (!isPickingColor) {
        colorPickerPanel.classList.remove("active");
        clearShapeHighlight();
    }
});

function getShapeTypeName(type) {
    const types = {
        0: "Background",
        1: "Circle",
        2: "Triangle",
        3: "Quad",
        4: "Ellipse"
    };
    return types[type] || `Type ${type}`;
}

function rgbToHex(r, g, b) {
    return "#" + [r, g, b].map(x => {
        const hex = Math.round(x).toString(16);
        return hex.length === 1 ? "0" + hex : hex;
    }).join("").toUpperCase();
}

function getShapeCenter(shape, imgRect) {
    if (shape.type === 0 && shape.data.length >= 4) {
        const [x1, y1, x2, y2] = shape.data;
        return { x: (x1 + x2) / 2, y: (y1 + y2) / 2 };
    }
    if (shape.type === 1 && shape.data.length >= 3) {
        return { x: shape.data[0], y: shape.data[1] };
    }
    if (shape.type === 2 && shape.data.length >= 6) {
        const [A, B, C, D, E, F] = shape.data;
        return { x: (A + C + E) / 3, y: (B + D + F) / 3 };
    }
    if (shape.type === 4 && shape.data.length >= 2) {
        return { x: shape.data[0], y: shape.data[1] };
    }
    return { x: imgRect.w / 2, y: imgRect.h / 2 };
}

function isPointInShape(x, y, shape, imgRect) {
    // Convert canvas coordinates to image coordinates
    const imgX = (x - imgRect.x) / imgRect.scale;
    const imgY = (y - imgRect.y) / imgRect.scale;
    
    if (shape.type === 0) {
        // Background - covers entire canvas
        return true;
    }
    
    if (shape.type === 1) {
        // Circle
        const [cx, cy, rad] = shape.data;
        const dist = Math.hypot(imgX - cx, imgY - cy);
        return dist <= rad;
    }
    
    if (shape.type === 2) {
        // Triangle - use barycentric coordinates
        const [A, B, C, D, E, F] = shape.data;
        return isPointInTriangle(imgX, imgY, A, B, C, D, E, F);
    }
    
    if (shape.type === 4) {
        // Ellipse
        const [cx, cy, rx, ry, ang = 0] = shape.data;
        const angleRad = (ang * Math.PI) / 180;
        const cos = Math.cos(-angleRad);
        const sin = Math.sin(-angleRad);
        const dx = imgX - cx;
        const dy = imgY - cy;
        const rotX = dx * cos - dy * sin;
        const rotY = dx * sin + dy * cos;
        return (rotX * rotX) / (rx * rx) + (rotY * rotY) / (ry * ry) <= 1;
    }
    
    return false;
}

function isPointInTriangle(px, py, x1, y1, x2, y2, x3, y3) {
    const area = 0.5 * (-y2 * x3 + y1 * (-x2 + x3) + x1 * (y2 - y3) + x2 * y3);
    const s = 1 / (2 * area) * (y1 * x3 - x1 * y3 + (y3 - y1) * px + (x1 - x3) * py);
    const t = 1 / (2 * area) * (x1 * y2 - y1 * x2 + (y1 - y2) * px + (x2 - x1) * py);
    return s >= 0 && t >= 0 && (1 - s - t) >= 0;
}

function findShapeAtPoint(x, y) {
    const imgRect = getImageRect();
    const working = groupedShapes.length ? groupedShapes : currentShapes;
    
    // Get currently displayed shapes based on slider
    const limit = parseInt(slider.value);
    const displayedShapes = limit > 0 ? working.slice(0, limit) : working;
    
    // Search from top (last rendered) to bottom (first rendered)
    for (let i = displayedShapes.length - 1; i >= 0; i--) {
        const shape = displayedShapes[i];
        if (isPointInShape(x, y, shape, imgRect)) {
            return { shape, index: i };
        }
    }
    return null;
}

function displayShapeInfo(shape, index) {
    const imgRect = getImageRect();
    const [r, g, b, a] = shape.color;
    
    // Set current selected color for matching
    currentSelectedColor = rgbToHex(r, g, b);
    updateMatchButtonState();
    
    colorPickerPanel.classList.add("active");
    colorPreviewBox.style.backgroundColor = `rgba(${r},${g},${b},${a/255})`;
    
    shapeTypeValue.textContent = getShapeTypeName(shape.type);
    shapeIndexValue.textContent = index;
    rgbValue.textContent = `${r}, ${g}, ${b}`;
    rgbaValue.textContent = `${r}, ${g}, ${b}, ${a}`;
    hexValue.textContent = rgbToHex(r, g, b);
    alphaValue.textContent = `${a} (${(a/255*100).toFixed(1)}%)`;
    
    const center = getShapeCenter(shape, imgRect);
    positionValue.textContent = `${center.x.toFixed(1)}, ${center.y.toFixed(1)}`;
    scoreValue.textContent = shape.score?.toFixed(4) || "-";
    
    highlightShape(shape, imgRect);
}

function highlightShape(shape, imgRect) {
    clearShapeHighlight();
    
    // Create SVG overlay for precise shape outline
    const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    svg.id = "shapeHighlight";
    svg.style.position = "absolute";
    svg.style.left = imgRect.x + "px";
    svg.style.top = imgRect.y + "px";
    svg.style.width = imgRect.w * imgRect.scale + "px";
    svg.style.height = imgRect.h * imgRect.scale + "px";
    svg.style.pointerEvents = "none";
    svg.style.overflow = "visible";
    
    let pathElement;
    const scale = imgRect.scale;
    
    if (shape.type === 0) {
        // Background - rectangle outline
        pathElement = document.createElementNS("http://www.w3.org/2000/svg", "rect");
        pathElement.setAttribute("x", "2");
        pathElement.setAttribute("y", "2");
        pathElement.setAttribute("width", imgRect.w * scale - 4);
        pathElement.setAttribute("height", imgRect.h * scale - 4);
    } else if (shape.type === 1) {
        // Circle
        const [cx, cy, rad] = shape.data;
        pathElement = document.createElementNS("http://www.w3.org/2000/svg", "circle");
        pathElement.setAttribute("cx", cx * scale);
        pathElement.setAttribute("cy", cy * scale);
        pathElement.setAttribute("r", rad * scale);
    } else if (shape.type === 2) {
        // Triangle
        const [A, B, C, D, E, F] = shape.data;
        pathElement = document.createElementNS("http://www.w3.org/2000/svg", "polygon");
        const points = `${A * scale},${B * scale} ${C * scale},${D * scale} ${E * scale},${F * scale}`;
        pathElement.setAttribute("points", points);
    } else if (shape.type === 4) {
        // Ellipse (with rotation support)
        const [cx, cy, rx, ry, ang = 0] = shape.data;
        pathElement = document.createElementNS("http://www.w3.org/2000/svg", "ellipse");
        pathElement.setAttribute("cx", cx * scale);
        pathElement.setAttribute("cy", cy * scale);
        pathElement.setAttribute("rx", rx * scale);
        pathElement.setAttribute("ry", ry * scale);
        if (ang !== 0) {
            pathElement.setAttribute("transform", `rotate(${ang} ${cx * scale} ${cy * scale})`);
        }
    } else {
        return;
    }
    
    // Style the outline
    pathElement.setAttribute("fill", "rgba(0, 188, 212, 0.15)");
    pathElement.setAttribute("stroke", "#00BCD4");
    pathElement.setAttribute("stroke-width", "3");
    pathElement.setAttribute("stroke-dasharray", "8,4");
    
    // Add animated dash effect
    const animate = document.createElementNS("http://www.w3.org/2000/svg", "animate");
    animate.setAttribute("attributeName", "stroke-dashoffset");
    animate.setAttribute("from", "0");
    animate.setAttribute("to", "24");
    animate.setAttribute("dur", "1s");
    animate.setAttribute("repeatCount", "indefinite");
    pathElement.appendChild(animate);
    
    svg.appendChild(pathElement);
    regionOverlay.appendChild(svg);
}

function clearShapeHighlight() {
    const existing = document.getElementById("shapeHighlight");
    if (existing) existing.remove();
}

canvas.addEventListener("click", e => {
    if (!isPickingColor) return;
    if (isSelecting) return;
    
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    
    const result = findShapeAtPoint(x, y);
    
    if (result) {
        selectedShapeIndex = result.index;
        displayShapeInfo(result.shape, result.index);
    } else {
        colorPickerPanel.classList.remove("active");
        clearShapeHighlight();
    }
});

/* ==========================================================
   PALETTE PRESET FUNCTIONALITY
========================================================== */

// Embedded palette data to avoid CORS issues with local files
let palettePresetsData = null;

// Load colors.json data
async function loadPalettePresets() {
    try {
        // Try to fetch colors.json if server is available
        const response = await fetch('colors.json');
        palettePresetsData = await response.json();
    } catch (error) {
        console.warn('Could not fetch colors.json, using embedded fallback');
        // Fallback: Load from embedded script tag or use default
        const colorsScript = document.getElementById('colorsData');
        if (colorsScript && colorsScript.textContent) {
            try {
                palettePresetsData = JSON.parse(colorsScript.textContent);
            } catch (e) {
                console.error('Error parsing embedded colors data:', e);
                return;
            }
        } else {
            console.error('No colors data available');
            return;
        }
    }
    
    if (!palettePresetsData) return;
    
    const select = document.getElementById('palettePresetSelect');
    
    // Clear existing options except the first one
    while (select.options.length > 1) {
        select.remove(1);
    }
    
    // Populate dropdown with palette names
    Object.keys(palettePresetsData).forEach(paletteName => {
        const option = document.createElement('option');
        option.value = paletteName;
        option.textContent = `${paletteName} (${palettePresetsData[paletteName].length} colors)`;
        select.appendChild(option);
    });
    
    console.log('Loaded palette presets:', Object.keys(palettePresetsData));
}

// Enable/disable load button based on selection
document.getElementById('palettePresetSelect').addEventListener('change', (e) => {
    document.getElementById('loadPaletteBtn').disabled = !e.target.value;
});

// Load selected palette into the color matcher input
document.getElementById('loadPaletteBtn').addEventListener('click', () => {
    const select = document.getElementById('palettePresetSelect');
    const selectedPalette = select.value;
    
    if (!selectedPalette || !palettePresetsData[selectedPalette]) {
        return;
    }
    
    const colorArray = palettePresetsData[selectedPalette];
    
    // Convert RGB arrays to hex format
    const hexColors = colorArray.map(rgb => {
        const r = Math.round(rgb[0]);
        const g = Math.round(rgb[1]);
        const b = Math.round(rgb[2]);
        return rgbToHex(r, g, b);
    });
    
    // Populate the color matcher input textarea
    const colorMatcherInput = document.getElementById('colorMatcherInput');
    colorMatcherInput.value = hexColors.join('\n');
    
    // Update match button state
    updateMatchButtonState();
    
    console.log(`Loaded ${hexColors.length} colors from "${selectedPalette}"`);
});

// Initialize palette presets on page load
loadPalettePresets();

/* ==========================================================
   COLOR MATCHER FUNCTIONALITY (via API)
========================================================== */

colorMatcherInput.addEventListener("input", updateMatchButtonState);

function updateMatchButtonState() {
    const hasColor = currentSelectedColor !== null;
    const hasPalette = colorMatcherInput.value.trim().length > 0;
    // Also update recipe button
    if (typeof updateRecipeButtonState === 'function') {
        updateRecipeButtonState();
    } else {
        getRecipeBtn.disabled = !(hasColor && hasPalette);
    }
}

function parsePaletteColors(input) {
    return input
        .split(/[\n,]+/)
        .map(c => c.trim())
        .filter(c => c.length > 0)
        .map(c => c.startsWith('#') ? c : '#' + c)
        .filter(c => /^#[0-9A-Fa-f]{3,6}$/i.test(c));
}

function getMatchClass(percentage) {
    if (percentage >= 70) return 'high';
    if (percentage >= 40) return 'medium';
    return 'low';
}

function renderMatchResults(data) {
    if (data.error && !data.has_matches) {
        let html = `<div class="match-error">‚ö†Ô∏è ${data.error}</div>`;
        
        // Still show results if we have them (just with low matches)
        if (data.matches && data.matches.length > 0) {
            html += `<div class="match-results-header" style="margin-top: 12px;">
                <span>All Comparisons</span>
                <span>${data.matches.length} colors</span>
            </div>`;
            html += data.matches.map((m, i) => renderMatchItem(m, i === 0)).join('');
        }
        
        matchResults.innerHTML = html;
        return;
    }
    
    if (!data.matches || data.matches.length === 0) {
        matchResults.innerHTML = `<div class="match-empty">No valid colors found in the palette</div>`;
        return;
    }
    
    let html = `<div class="match-results-header">
        <span>Match Results</span>
        <span>${data.matches.length} colors</span>
    </div>`;
    
    html += data.matches.map((m, i) => renderMatchItem(m, i === 0)).join('');
    
    matchResults.innerHTML = html;
}

function renderMatchItem(match, isBest) {
    const matchClass = getMatchClass(match.match_percentage);
    return `
        <div class="match-result-item ${isBest ? 'best-match' : ''}">
            <div class="match-color-swatch" style="background: ${match.hex}"></div>
            <div class="match-info">
                <div class="match-hex">
                    ${match.hex}
                    ${isBest ? '<span class="best-badge">Best</span>' : ''}
                </div>
                <div class="match-delta">ŒîE: ${match.delta_e.toFixed(2)}</div>
                <div class="match-progress-bar">
                    <div class="match-progress-fill ${matchClass}" style="width: ${match.match_percentage}%"></div>
                </div>
            </div>
            <div class="match-percentage">
                <div class="match-percentage-value ${matchClass}">${match.match_percentage.toFixed(1)}%</div>
                <div class="match-percentage-label">match</div>
            </div>
        </div>
    `;
}



/* ==========================================================
   UNMIX / GET RECIPE FUNCTIONALITY (via API)
========================================================== */

// Update recipe button state
function updateRecipeButtonState() {
    const hasColor = currentSelectedColor !== null;
    const hasPalette = colorMatcherInput.value.trim().length > 0;
    getRecipeBtn.disabled = !(hasColor && hasPalette);
}

// Also update recipe button when palette changes
colorMatcherInput.addEventListener("input", updateRecipeButtonState);

function getRecipeMatchClass(percentage) {
    if (percentage >= 70) return 'high';
    if (percentage >= 40) return 'medium';
    return 'low';
}

function formatMixMethod(method) {
    const methods = {
        'kubelka_munk': 'Kubelka-Munk (Paint)',
        'yn_km': 'Yule-Nielsen KM',
        'linear': 'Linear RGB (Light)',
        'exact': 'Exact Match'
    };
    return methods[method] || method;
}

function renderRecipeResults(data) {
    if (data.error) {
        recipeResults.innerHTML = `<div class="recipe-error">‚ö†Ô∏è ${data.error}</div>`;
        return;
    }
    
    if (!data.recipe || data.recipe.length === 0) {
        recipeResults.innerHTML = `<div class="recipe-empty">No recipe found for this color</div>`;
        return;
    }
    
    const matchClass = getRecipeMatchClass(data.match_percentage);
    
    let html = `
        <div class="recipe-header">
            <div class="recipe-header-left">
                <div class="recipe-target-swatch" style="background: ${data.target_color}" title="Target"></div>
                <div class="recipe-arrow">‚Üí</div>
                <div class="recipe-result-swatch" style="background: ${data.result_color}" title="Result"></div>
            </div>
            <div class="recipe-match-info">
                <div class="recipe-match-value ${matchClass}">${data.match_percentage}%</div>
                <div class="recipe-match-label">match</div>
                <div class="recipe-method">${formatMixMethod(data.mix_method)}</div>
            </div>
        </div>
        <div class="recipe-components">
    `;
    
    data.recipe.forEach(comp => {
        const displayName = comp.name || comp.hex;
        html += `
            <div class="recipe-component">
                <div class="recipe-component-swatch" style="background: ${comp.hex}"></div>
                <div class="recipe-component-info">
                    <div class="recipe-component-name" title="${displayName}">${displayName}</div>
                    <div class="recipe-component-hex">${comp.hex}</div>
                </div>
                <div class="recipe-component-amount">
                    <div class="recipe-component-parts">${comp.parts}</div>
                    <div class="recipe-component-parts-label">parts</div>
                    <div class="recipe-component-percent">${comp.percentage}%</div>
                </div>
            </div>
        `;
    });
    
    html += `</div>`;
    html += `<div class="recipe-total">Total: ${data.total_parts} parts ¬∑ ŒîE: ${data.delta_e}</div>`;
    
    recipeResults.innerHTML = html;
}

// Build palette with names for the unmix request
function buildPaletteWithNames(hexColors) {
    // Try to get names from the loaded palette preset
    const select = document.getElementById('palettePresetSelect');
    const selectedPalette = select.value;
    
    if (selectedPalette && palettePresetsData && palettePresetsData[selectedPalette]) {
        const colorArray = palettePresetsData[selectedPalette];
        const paletteMap = new Map();
        
        // Build map of hex -> name
        colorArray.forEach((rgb, idx) => {
            const r = Math.round(rgb[0]);
            const g = Math.round(rgb[1]);
            const b = Math.round(rgb[2]);
            const hex = rgbToHex(r, g, b).toUpperCase();
            paletteMap.set(hex, `${selectedPalette} #${idx + 1}`);
        });
        
        // Return palette with names where available
        return hexColors.map(hex => ({
            hex: hex,
            name: paletteMap.get(hex.toUpperCase()) || null
        }));
    }
    
    // No preset loaded, return without names
    return hexColors.map(hex => ({ hex: hex, name: null }));
}

getRecipeBtn.addEventListener("click", async () => {
    if (!currentSelectedColor) {
        alert("Please select a shape first using the color picker.");
        return;
    }
    
    const paletteColors = parsePaletteColors(colorMatcherInput.value);
    
    if (paletteColors.length === 0) {
        recipeResults.innerHTML = `<div class="recipe-error">‚ö†Ô∏è Please enter valid hex colors in the palette</div>`;
        return;
    }
    
    const maxColors = parseInt(maxColorsInput.value) || 3;
    const maxParts = parseInt(maxPartsInput.value) || 10;
    
    // Build palette with names
    const paletteWithNames = buildPaletteWithNames(paletteColors);
    
    // Show loading state
    recipeResults.innerHTML = `<div class="recipe-empty">‚è≥ Finding best recipe...</div>`;
    getRecipeBtn.disabled = true;
    
    try {
        const response = await fetch(`${API_BASE}/unmix`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
                target_color: currentSelectedColor,
                palette: paletteWithNames,
                max_colors: maxColors,
                max_parts: maxParts
            })
        });
        
        if (!response.ok) {
            throw new Error(`API error: ${response.status}`);
        }
        
        const data = await response.json();
        renderRecipeResults(data);
        
    } catch (error) {
        console.error("Unmix API error:", error);
        recipeResults.innerHTML = `<div class="recipe-error">‚ö†Ô∏è API Error: ${error.message}. Make sure the backend is running.</div>`;
    } finally {
        updateRecipeButtonState();
    }
});

/* ==========================================================
   LOGIC ORDERING ‚Äì CALL BACKEND
========================================================== */

logicRadios.forEach(r => r.addEventListener("change", updateRender));

slider.addEventListener("input", updateRender);

colorGroupSlider.addEventListener("input", () => {
    const sliderValue = parseInt(colorGroupSlider.value);
    // In reversed mode, invert the value (100 - sliderValue)
    colorTolerance = sliderModeReversed ? (100 - sliderValue) : sliderValue;
    applyColorGrouping();
    updateRender();
    // Update sequence filter chips and grouped color count when tolerance changes
    populateSequenceFilterChips();
});

// Slider mode toggle buttons
document.getElementById('sliderModeNormal')?.addEventListener('click', () => {
    if (!sliderModeReversed) return; // Already in normal mode
    sliderModeReversed = false;
    document.getElementById('sliderModeNormal').classList.add('active');
    document.getElementById('sliderModeReversed').classList.remove('active');
    // Reset to starting position: left = all colors (tolerance 0)
    colorGroupSlider.value = 0;
    colorTolerance = 0;
    applyColorGrouping();
    updateRender();
    populateSequenceFilterChips();
});

document.getElementById('sliderModeReversed')?.addEventListener('click', () => {
    if (sliderModeReversed) return; // Already in reversed mode
    sliderModeReversed = true;
    document.getElementById('sliderModeReversed').classList.add('active');
    document.getElementById('sliderModeNormal').classList.remove('active');
    // Reset to starting position: left = few colors (tolerance 100)
    colorGroupSlider.value = 0;
    colorTolerance = 100;
    applyColorGrouping();
    updateRender();
    populateSequenceFilterChips();
});

/* ==========================================================
   UPDATE RENDER
========================================================== */

async function updateRender() {
    if (!currentShapes.length) return;
    
    // Clear any shape highlight when re-rendering
    clearShapeHighlight();

    let working = groupedShapes.length ? groupedShapes : currentShapes;
    
    // Apply sequence filter if a color is selected
    if (selectedFilterColor) {
        working = working.filter(s => {
            if (s.type === 0) return true; // Keep background
            const [r, g, b, a] = s.color;
            const [fr, fg, fb, fa] = selectedFilterColor;
            return r === fr && g === fg && b === fb && a === fa;
        });
    }

    const logic = document.querySelector("input[name='logic']:checked").value;
    const limit = parseInt(slider.value);

    if (logic === "original") {
        slider.max = working.length;
        sliderLabel.textContent = `Shapes: ${limit} / ${working.length}`;
        drawCanvas(working.slice(0, limit || working.length));
        updateRegionUI();
        return;
    }

    const activeOrder =
        logic === "color_sequence" ? colorOrder :
        logic === "custom_sequence" ? customColorOrder : null;

    const res = await fetch(`${API_BASE}/order_shapes_from_json`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
            shapes: working,
            logic,
            limit,
            color_order: activeOrder
        })
    });

    const data = await res.json();

    slider.max = data.total_shapes;
    sliderLabel.textContent = `Shapes: ${limit} / ${data.total_shapes}`;

    drawCanvas(data.shapes);
    updateRegionUI();
}
/* ==========================================================
   DRAW CANVAS
========================================================== */
function drawCanvas(shapes = currentShapes) {
    ctx.fillStyle = "white";
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    if (!shapes.length) return;

    const img = getImageRect();
    const { x, y, scale } = img;

    const off = document.createElement("canvas");
    off.width = img.w;
    off.height = img.h;
    const o = off.getContext("2d");

    shapes.forEach(s => {
        const [r, g, b, a] = s.color;
        o.fillStyle = `rgba(${r},${g},${b},${a / 255})`;
        o.strokeStyle = `rgba(${r},${g},${b},${a / 255})`;

        if (s.type === 0) {
            // Rectangle: [x1, y1, x2, y2]
            const [x1, y1, x2, y2] = s.data;
            const rx = Math.min(x1, x2);
            const ry = Math.min(y1, y2);
            const rw = Math.abs(x2 - x1);
            const rh = Math.abs(y2 - y1);
            o.fillRect(rx, ry, rw, rh);
        }

        else if (s.type === 1) {
            // Rotated Rectangle: [x1, y1, x2, y2, angle]
            const [x1, y1, x2, y2, angle] = s.data;
            const cx = (x1 + x2) / 2;
            const cy = (y1 + y2) / 2;
            const w = Math.abs(x2 - x1);
            const h = Math.abs(y2 - y1);
            
            o.save();
            o.translate(cx, cy);
            o.rotate((angle || 0) * Math.PI / 180);
            o.fillRect(-w / 2, -h / 2, w, h);
            o.restore();
        }

        else if (s.type === 2) {
            // Triangle: [x1, y1, x2, y2, x3, y3]
            const [A, B, C, D, E, F] = s.data;
            o.beginPath();
            o.moveTo(A, B);
            o.lineTo(C, D);
            o.lineTo(E, F);
            o.closePath();
            o.fill();
        }

        else if (s.type === 3) {
            // Ellipse (non-rotated): [cx, cy, rx, ry]
            const [cx, cy, rx, ry] = s.data;
            o.beginPath();
            o.ellipse(cx, cy, rx, ry, 0, 0, Math.PI * 2);
            o.fill();
        }

        else if (s.type === 4) {
            // Rotated Ellipse: [cx, cy, rx, ry, angle]
            const [cx, cy, rx, ry, ang] = s.data;
            o.save();
            o.translate(cx, cy);
            o.rotate((ang || 0) * Math.PI / 180);
            o.beginPath();
            o.ellipse(0, 0, rx, ry, 0, 0, Math.PI * 2);
            o.fill();
            o.restore();
        }

        else if (s.type === 5) {
            // Circle: [cx, cy, r]
            const [cx, cy, rad] = s.data;
            o.beginPath();
            o.arc(cx, cy, rad, 0, Math.PI * 2);
            o.fill();
        }

        else if (s.type === 6) {
            // Line: [x1, y1, x2, y2]
            const [x1, y1, x2, y2] = s.data;
            o.lineWidth = 1;
            o.beginPath();
            o.moveTo(x1, y1);
            o.lineTo(x2, y2);
            o.stroke();
        }

        else if (s.type === 7) {
            // Quadratic Bezier: [x1, y1, cx, cy, x2, y2]
            const [x1, y1, cx, cy, x2, y2] = s.data;
            o.lineWidth = 1;
            o.beginPath();
            o.moveTo(x1, y1);
            o.quadraticCurveTo(cx, cy, x2, y2);
            o.stroke();
        }
    });

    ctx.drawImage(off, x, y, img.w * scale, img.h * scale);
}

/* ==========================================================
   COLOR GROUPING (TOLERANCE)
========================================================== */

function applyColorGrouping() {
    if (!currentShapes.length) return;

    const tol = colorTolerance * 2;

    if (tol === 0) {
        groupedShapes = [...currentShapes];
        updateColorGroupLabel();
        return;
    }

    const colorMap = new Map();

    currentShapes.forEach((s, idx) => {
        if (s.type === 0) return;
        const key = JSON.stringify(s.color);
        if (!colorMap.has(key)) colorMap.set(key, []);
        colorMap.get(key).push(idx);
    });

    const colorList = [...colorMap.keys()].map(k => JSON.parse(k));

    const groups = [];
    const used = new Set();

    colorList.forEach((c1, i) => {
        if (used.has(i)) return;

        const group = [c1];
        const indices = [...colorMap.get(JSON.stringify(c1))];
        used.add(i);

        colorList.forEach((c2, j) => {
            if (used.has(j)) return;
            const dist = Math.sqrt(
                (c1[0] - c2[0]) ** 2 +
                (c1[1] - c2[1]) ** 2 +
                (c1[2] - c2[2]) ** 2
            );
            if (dist <= tol) {
                used.add(j);
                group.push(c2);
                indices.push(...colorMap.get(JSON.stringify(c2)));
            }
        });

        const rep = findRepresentativeColor(group);
        groups.push({ rep, indices });
    });

    groupedShapes = currentShapes.map((s, idx) => {
        if (s.type === 0) return s;
        const g = groups.find(g => g.indices.includes(idx));
        if (!g) return s;
        return { ...s, color: g.rep };
    });

    updateColorGroupLabel();
}

function updateColorGroupLabel() {
    const unique = new Set();

    groupedShapes.forEach(s => {
        if (s.type !== 0) unique.add(JSON.stringify(s.color));
    });

    colorGroupLabel.textContent =
        `Tolerance: ${colorTolerance} (Unique colors: ${unique.size})`;
}

function findRepresentativeColor(colors) {
    let r = 0, g = 0, b = 0, a = 0;
    colors.forEach(c => {
        r += c[0];
        g += c[1];
        b += c[2];
        a += c[3];
    });
    const n = colors.length;
    return [Math.round(r / n), Math.round(g / n), Math.round(b / n), 255];
}

/* ==========================================================
   COLOR ORDER MODAL (EDIT JSON)
========================================================== */

editColorBtn.addEventListener("click", () => {
    if (!currentShapes.length) return alert("Load shapes first.");
    colorInput.value = JSON.stringify(colorOrder || [], null, 2);
    document.getElementById("colorModal").style.display = "block";
});

document.getElementById("cancelColorBtn").onclick = () =>
    (document.getElementById("colorModal").style.display = "none");

document.getElementById("saveColorBtn").onclick = () => {
    try {
        colorOrder = JSON.parse(colorInput.value);
        document.getElementById("colorModal").style.display = "none";
        updateRender();
    } catch {
        alert("Invalid JSON format.");
    }
};

/* ==========================================================
   DRAG & DROP COLOR ORDER
========================================================== */

dragColorBtn.addEventListener("click", () => {
    if (!currentShapes.length) return alert("Load shapes first.");

    populateColorPalette();
    document.getElementById("dragModal").style.display = "block";
});

document.getElementById("cancelDragBtn").onclick = () =>
    (document.getElementById("dragModal").style.display = "none");

document.getElementById("saveDragBtn").onclick = () => {
    const chips = [...document.getElementById("colorPalette").children];
    customColorOrder = chips.map(chip => JSON.parse(chip.dataset.color));
    document.getElementById("dragModal").style.display = "none";
    updateRender();
};

function populateColorPalette() {
    const palette = document.getElementById("colorPalette");
    palette.innerHTML = "";

    const freq = new Map();
    const working = groupedShapes.length ? groupedShapes : currentShapes;

    working.forEach(s => {
        if (s.type === 0) return;
        const k = JSON.stringify(s.color);
        freq.set(k, (freq.get(k) || 0) + 1);
    });

    const list = [...freq.entries()].map(([k, count]) => ({
        color: JSON.parse(k),
        count
    }));

    list.sort((a, b) => b.count - a.count);

    list.forEach((item, i) => {
        const chip = document.createElement("div");
        chip.className = "color-chip";
        chip.draggable = true;
        chip.dataset.color = JSON.stringify(item.color);

        chip.style.backgroundColor =
            `rgba(${item.color[0]},${item.color[1]},${item.color[2]},${item.color[3]/255})`;

        chip.innerHTML = `
            <div class="chip-number">#${i + 1}</div>
            <div class="rgb-value">${item.color.slice(0,3).join(", ")}</div>
            <div class="count">${item.count}√ó</div>
        `;

        chip.addEventListener("dragstart", () => chip.classList.add("dragging"));
        chip.addEventListener("dragend", () => chip.classList.remove("dragging"));
        chip.addEventListener("dragover", e => e.preventDefault());
        chip.addEventListener("drop", e => {
            e.preventDefault();
            const dragging = document.querySelector(".dragging");
            if (dragging && dragging !== chip) {
                const all = [...palette.children];
                const from = all.indexOf(dragging);
                const to = all.indexOf(chip);

                if (from < to) chip.after(dragging);
                else chip.before(dragging);
            }
        });

        palette.appendChild(chip);
    });
}

window.onclick = e => {
    if (e.target.classList.contains("modal")) e.target.style.display = "none";
};

/* ==========================================================
   END SCRIPT
========================================================== */
</script>

<!-- Embedded Geometrize Library -->
<script type="text/javascript" id="geometrize-lib">
(function ($hx_exports, $global) { "use strict";
$hx_exports["geometrize"] = $hx_exports["geometrize"] || {};
$hx_exports["geometrize"]["bitmap"] = $hx_exports["geometrize"]["bitmap"] || {};
;$hx_exports["geometrize"]["exporter"] = $hx_exports["geometrize"]["exporter"] || {};
;$hx_exports["geometrize"]["runner"] = $hx_exports["geometrize"]["runner"] || {};
;$hx_exports["geometrize"]["shape"] = $hx_exports["geometrize"]["shape"] || {};
function $extend(from, fields) {
    var proto = Object.create(from);
    for (var name in fields) proto[name] = fields[name];
    if( fields.toString !== Object.prototype.toString ) proto.toString = fields.toString;
    return proto;
}
var GeometrizeWorker = function() { };
GeometrizeWorker.prototype = {
    messageHandler: function(event) {
        if(event == null || event.data == null) {
            return;
        }
        var message = event.data;
        switch(message.id) {
        case "should_set_target_image":
            var target = message.data;
            this.runner = new geometrize_runner_ImageRunner(target,geometrize_Util.getAverageImageColor(target));
            this.postMessage({ id : "did_set_target_image"});
            break;
        case "should_step":
            var options = message.data;
            var results = this.runner.step(options);
            var svgData = geometrize_exporter_SvgExporter.exportShapes(results);
            var jsonData = geometrize_exporter_ShapeJsonExporter.exportShapes(results);
            this.postMessage({ id : "did_step", svgData : svgData, jsonData : jsonData});
            break;
        }
    }
    ,postMessage: function(message) {
    }
};
var Std = function() { };
Std.random = function(x) {
    if(x <= 0) {
        return 0;
    } else {
        return Math.floor(Math.random() * x);
    }
};
var StringTools = function() { };
StringTools.replace = function(s,sub,by) {
    return s.split(sub).join(by);
};
var UInt = {};
UInt.toFloat = function(this1) {
    var int = this1;
    if(int < 0) {
        return 4294967296.0 + int;
    } else {
        return int + 0.0;
    }
};
var geometrize_ArraySet = {};
geometrize_ArraySet.create = function(array) {
    if(array == null) {
        var this1 = [];
        return this1;
    }
    return geometrize_ArraySet.toSet(array);
};
geometrize_ArraySet.add = function(this1,element) {
    if(element == null) {
        throw haxe_Exception.thrown("FAIL: element != null");
    }
    if(geometrize_ArraySet.contains(this1,element)) {
        return false;
    }
    this1.push(element);
    return true;
};
geometrize_ArraySet.contains = function(this1,element) {
    var _g = 0;
    while(_g < this1.length) {
        var i = this1[_g];
        ++_g;
        if(i == element) {
            return true;
        }
    }
    return false;
};
geometrize_ArraySet.toArray = function(this1) {
    return this1.slice();
};
geometrize_ArraySet.toSet = function(array) {
    var this1 = [];
    var set = this1;
    var _g = 0;
    while(_g < array.length) {
        var v = array[_g];
        ++_g;
        geometrize_ArraySet.add(set,v);
    }
    return set;
};
var geometrize_Core = function() { };
geometrize_Core.computeColor = function(target,current,lines,alpha) {
    if(target == null) {
        throw haxe_Exception.thrown("FAIL: target != null");
    }
    if(current == null) {
        throw haxe_Exception.thrown("FAIL: current != null");
    }
    if(lines == null) {
        throw haxe_Exception.thrown("FAIL: lines != null");
    }
    if(alpha < 0) {
        throw haxe_Exception.thrown("FAIL: alpha >= 0");
    }
    var totalRed = 0;
    var totalGreen = 0;
    var totalBlue = 0;
    var count = 0;
    var f = 65535 / alpha;
    var a = f | 0;
    var _g = 0;
    while(_g < lines.length) {
        var line = lines[_g];
        ++_g;
        var y = line.y;
        var _g1 = line.x1;
        var _g2 = line.x2 + 1;
        while(_g1 < _g2) {
            var x = _g1++;
            var t = target.data[target.width * y + x];
            var c = current.data[current.width * y + x];
            totalRed += ((t >> 24 & 255) - (c >> 24 & 255)) * a + (c >> 24 & 255) * 257;
            totalGreen += ((t >> 16 & 255) - (c >> 16 & 255)) * a + (c >> 16 & 255) * 257;
            totalBlue += ((t >> 8 & 255) - (c >> 8 & 255)) * a + (c >> 8 & 255) * 257;
            ++count;
        }
    }
    if(count == 0) {
        return 0;
    }
    var value = (totalRed / count | 0) >> 8;
    var r = value < 0 ? 0 : value > 255 ? 255 : value;
    var value = (totalGreen / count | 0) >> 8;
    var g = value < 0 ? 0 : value > 255 ? 255 : value;
    var value = (totalBlue / count | 0) >> 8;
    var b = value < 0 ? 0 : value > 255 ? 255 : value;
    return ((r < 0 ? 0 : r > 255 ? 255 : r) << 24) + ((g < 0 ? 0 : g > 255 ? 255 : g) << 16) + ((b < 0 ? 0 : b > 255 ? 255 : b) << 8) + (alpha < 0 ? 0 : alpha > 255 ? 255 : alpha);
};
geometrize_Core.differenceFull = function(first,second) {
    if(first == null) {
        throw haxe_Exception.thrown("FAIL: first != null");
    }
    if(second == null) {
        throw haxe_Exception.thrown("FAIL: second != null");
    }
    if(first.width == 0) {
        throw haxe_Exception.thrown("FAIL: first.width != 0");
    }
    if(first.height == 0) {
        throw haxe_Exception.thrown("FAIL: first.height != 0");
    }
    if(second.width == 0) {
        throw haxe_Exception.thrown("FAIL: second.width != 0");
    }
    if(second.height == 0) {
        throw haxe_Exception.thrown("FAIL: second.height != 0");
    }
    var actual = first.width;
    var expected = second.width;
    if(actual != expected) {
        throw haxe_Exception.thrown("FAIL: values are not equal (expected: " + expected + ", actual: " + actual + ")");
    }
    var actual = first.height;
    var expected = second.height;
    if(actual != expected) {
        throw haxe_Exception.thrown("FAIL: values are not equal (expected: " + expected + ", actual: " + actual + ")");
    }
    var total = 0;
    var width = first.width;
    var height = first.height;
    var _g = 0;
    var _g1 = height;
    while(_g < _g1) {
        var y = _g++;
        var _g2 = 0;
        var _g3 = width;
        while(_g2 < _g3) {
            var x = _g2++;
            var f = first.data[first.width * y + x];
            var s = second.data[second.width * y + x];
            var dr = (f >> 24 & 255) - (s >> 24 & 255);
            var dg = (f >> 16 & 255) - (s >> 16 & 255);
            var db = (f >> 8 & 255) - (s >> 8 & 255);
            var da = (f & 255) - (s & 255);
            total += dr * dr + dg * dg + db * db + da * da;
        }
    }
    var result = Math.sqrt(total / (width * height * 4.0)) / 255;
    if(!isFinite(result)) {
        throw haxe_Exception.thrown("FAIL: Math.isFinite(result)");
    }
    return result;
};
geometrize_Core.differencePartial = function(target,before,after,score,lines) {
    if(target == null) {
        throw haxe_Exception.thrown("FAIL: target != null");
    }
    if(before == null) {
        throw haxe_Exception.thrown("FAIL: before != null");
    }
    if(after == null) {
        throw haxe_Exception.thrown("FAIL: after != null");
    }
    if(lines == null) {
        throw haxe_Exception.thrown("FAIL: lines != null");
    }
    if(lines.length == 0) {
        throw haxe_Exception.thrown("FAIL: lines.length != 0");
    }
    var width = target.width;
    var height = target.height;
    var rgbaCount = width * height * 4;
    var total = Math.pow(score * 255,2) * rgbaCount;
    var _g = 0;
    while(_g < lines.length) {
        var line = lines[_g];
        ++_g;
        var y = line.y;
        var _g1 = line.x1;
        var _g2 = line.x2 + 1;
        while(_g1 < _g2) {
            var x = _g1++;
            var t = target.data[target.width * y + x];
            var b = before.data[before.width * y + x];
            var a = after.data[after.width * y + x];
            var dtbr = (t >> 24 & 255) - (b >> 24 & 255);
            var dtbg = (t >> 16 & 255) - (b >> 16 & 255);
            var dtbb = (t >> 8 & 255) - (b >> 8 & 255);
            var dtba = (t & 255) - (b & 255);
            var dtar = (t >> 24 & 255) - (a >> 24 & 255);
            var dtag = (t >> 16 & 255) - (a >> 16 & 255);
            var dtab = (t >> 8 & 255) - (a >> 8 & 255);
            var dtaa = (t & 255) - (a & 255);
            total -= dtbr * dtbr + dtbg * dtbg + dtbb * dtbb + dtba * dtba;
            total += dtar * dtar + dtag * dtag + dtab * dtab + dtaa * dtaa;
        }
    }
    var result = Math.sqrt(total / rgbaCount) / 255;
    if(!isFinite(result)) {
        throw haxe_Exception.thrown("FAIL: Math.isFinite(result)");
    }
    return result;
};
geometrize_Core.bestRandomState = function(shapes,alpha,n,target,current,buffer,lastScore) {
    var bestEnergy = 0;
    var bestState = null;
    var _g = 0;
    var _g1 = n;
    while(_g < _g1) {
        var i = _g++;
        var state = new geometrize_State(geometrize_shape_ShapeFactory.randomShapeOf(shapes,current.width,current.height),alpha,target,current,buffer);
        var energy = state.energy(lastScore);
        if(i == 0 || energy < bestEnergy) {
            bestEnergy = energy;
            bestState = state;
        }
    }
    return bestState;
};
geometrize_Core.bestHillClimbState = function(shapes,alpha,n,age,target,current,buffer,lastScore) {
    var state = geometrize_Core.bestRandomState(shapes,alpha,n,target,current,buffer,lastScore);
    state = geometrize_Core.hillClimb(state,age,lastScore);
    return state;
};
geometrize_Core.hillClimb = function(state,maxAge,lastScore) {
    if(state == null) {
        throw haxe_Exception.thrown("FAIL: state != null");
    }
    if(maxAge < 0) {
        throw haxe_Exception.thrown("FAIL: maxAge >= 0");
    }
    var state1 = state.clone();
    var bestState = state1.clone();
    var bestEnergy = state1.energy(lastScore);
    var age = 0;
    while(age < maxAge) {
        var undo = state1.mutate();
        var energy = state1.energy(lastScore);
        if(energy >= bestEnergy) {
            state1 = undo;
        } else {
            bestEnergy = energy;
            bestState = state1.clone();
            age = -1;
        }
        ++age;
    }
    return bestState;
};
geometrize_Core.energy = function(shape,alpha,target,current,buffer,score) {
    if(shape == null) {
        throw haxe_Exception.thrown("FAIL: shape != null");
    }
    if(target == null) {
        throw haxe_Exception.thrown("FAIL: target != null");
    }
    if(current == null) {
        throw haxe_Exception.thrown("FAIL: current != null");
    }
    if(buffer == null) {
        throw haxe_Exception.thrown("FAIL: buffer != null");
    }
    var lines = shape.rasterize();
    if(lines == null) {
        throw haxe_Exception.thrown("FAIL: lines != null");
    }
    if(lines.length == 0) {
        throw haxe_Exception.thrown("FAIL: lines.length != 0");
    }
    var color = geometrize_Core.computeColor(target,current,lines,alpha);
    geometrize_rasterizer_Rasterizer.copyLines(buffer,current,lines);
    geometrize_rasterizer_Rasterizer.drawLines(buffer,color,lines);
    return geometrize_Core.differencePartial(target,current,buffer,score,lines);
};
var geometrize_Model = function(target,backgroundColor) {
    if(target == null) {
        throw haxe_Exception.thrown("FAIL: target != null");
    }
    this.width = target.width;
    this.height = target.height;
    this.target = target;
    var w = target.width;
    var h = target.height;
    var bitmap = new geometrize_bitmap_Bitmap();
    bitmap.width = w;
    bitmap.height = h;
    var this1 = new Array(w * h);
    bitmap.data = this1;
    var i = 0;
    while(i < bitmap.data.length) {
        bitmap.data[i] = backgroundColor;
        ++i;
    }
    this.current = bitmap;
    var w = target.width;
    var h = target.height;
    var bitmap = new geometrize_bitmap_Bitmap();
    bitmap.width = w;
    bitmap.height = h;
    var this1 = new Array(w * h);
    bitmap.data = this1;
    var i = 0;
    while(i < bitmap.data.length) {
        bitmap.data[i] = backgroundColor;
        ++i;
    }
    this.buffer = bitmap;
    this.score = geometrize_Core.differenceFull(target,this.current);
};
geometrize_Model.prototype = {
    step: function(shapeTypes,alpha,n,age) {
        var state = geometrize_Core.bestHillClimbState(shapeTypes,alpha,n,age,this.target,this.current,this.buffer,this.score);
        var results = [this.addShape(state.shape,state.alpha)];
        return results;
    }
    ,addShape: function(shape,alpha) {
        if(shape == null) {
            throw haxe_Exception.thrown("FAIL: shape != null");
        }
        var _this = this.current;
        var bitmap = new geometrize_bitmap_Bitmap();
        bitmap.width = _this.width;
        bitmap.height = _this.height;
        var this1 = new Array(_this.data.length);
        bitmap.data = this1;
        var _g = 0;
        var _g1 = _this.data.length;
        while(_g < _g1) {
            var i = _g++;
            bitmap.data[i] = _this.data[i];
        }
        var before = bitmap;
        var lines = shape.rasterize();
        var color = geometrize_Core.computeColor(this.target,this.current,lines,alpha);
        geometrize_rasterizer_Rasterizer.drawLines(this.current,color,lines);
        this.score = geometrize_Core.differencePartial(this.target,before,this.current,this.score,lines);
        var result = { score : this.score, color : color, shape : shape};
        return result;
    }
};
var geometrize_State = function(shape,alpha,target,current,buffer) {
    if(shape == null) {
        throw haxe_Exception.thrown("FAIL: shape != null");
    }
    this.shape = shape;
    this.alpha = alpha;
    this.score = -1;
    this.target = target;
    this.current = current;
    this.buffer = buffer;
};
geometrize_State.prototype = {
    energy: function(lastScore) {
        if(this.score < 0) {
            this.score = geometrize_Core.energy(this.shape,this.alpha,this.target,this.current,this.buffer,lastScore);
        }
        return this.score;
    }
    ,mutate: function() {
        var oldState = this.clone();
        this.shape.mutate();
        return oldState;
    }
    ,clone: function() {
        return new geometrize_State(this.shape.clone(),this.alpha,this.target,this.current,this.buffer);
    }
};
var geometrize_Util = function() { };
geometrize_Util.getAverageImageColor = function(image,alpha) {
    if(alpha == null) {
        alpha = 255;
    }
    if(image == null) {
        throw haxe_Exception.thrown("FAIL: image != null");
    }
    var totalRed = 0;
    var totalGreen = 0;
    var totalBlue = 0;
    var _g = 0;
    var _g1 = image.width;
    while(_g < _g1) {
        var x = _g++;
        var _g2 = 0;
        var _g3 = image.height;
        while(_g2 < _g3) {
            var y = _g2++;
            var pixel = image.data[image.width * y + x];
            totalRed += pixel >> 24 & 255;
            totalGreen += pixel >> 16 & 255;
            totalBlue += pixel >> 8 & 255;
        }
    }
    var size = image.width * image.height;
    var red = totalRed / size | 0;
    var green = totalGreen / size | 0;
    var blue = totalBlue / size | 0;
    return ((red < 0 ? 0 : red > 255 ? 255 : red) << 24) + ((green < 0 ? 0 : green > 255 ? 255 : green) << 16) + ((blue < 0 ? 0 : blue > 255 ? 255 : blue) << 8) + (alpha < 0 ? 0 : alpha > 255 ? 255 : alpha);
};
var geometrize_bitmap_Bitmap = $hx_exports["geometrize"]["bitmap"]["Bitmap"] = function() {
};
geometrize_bitmap_Bitmap.create = function(w,h,color) {
    var bitmap = new geometrize_bitmap_Bitmap();
    bitmap.width = w;
    bitmap.height = h;
    var this1 = new Array(w * h);
    bitmap.data = this1;
    var i = 0;
    while(i < bitmap.data.length) {
        bitmap.data[i] = color;
        ++i;
    }
    return bitmap;
};
geometrize_bitmap_Bitmap.createFromBytes = function(w,h,bytes) {
    var bitmap = new geometrize_bitmap_Bitmap();
    if(bytes == null) {
        throw haxe_Exception.thrown("FAIL: bytes != null");
    }
    var actual = bytes.length;
    var expected = w * h * 4;
    if(actual != expected) {
        throw haxe_Exception.thrown("FAIL: values are not equal (expected: " + expected + ", actual: " + actual + ")");
    }
    bitmap.width = w;
    bitmap.height = h;
    var this1 = new Array(bytes.length / 4 | 0);
    bitmap.data = this1;
    var i = 0;
    var x = 0;
    while(i < bytes.length) {
        var red = bytes.b[i];
        var green = bytes.b[i + 1];
        var blue = bytes.b[i + 2];
        var alpha = bytes.b[i + 3];
        bitmap.data[x] = ((red < 0 ? 0 : red > 255 ? 255 : red) << 24) + ((green < 0 ? 0 : green > 255 ? 255 : green) << 16) + ((blue < 0 ? 0 : blue > 255 ? 255 : blue) << 8) + (alpha < 0 ? 0 : alpha > 255 ? 255 : alpha);
        i += 4;
        ++x;
    }
    return bitmap;
};
geometrize_bitmap_Bitmap.createFromByteArray = function(w,h,bytes) {
    var data = new haxe_io_Bytes(new ArrayBuffer(bytes.length));
    var i = 0;
    while(i < bytes.length) {
        data.b[i] = bytes[i];
        ++i;
    }
    var bitmap = new geometrize_bitmap_Bitmap();
    if(data == null) {
        throw haxe_Exception.thrown("FAIL: bytes != null");
    }
    var actual = data.length;
    var expected = w * h * 4;
    if(actual != expected) {
        throw haxe_Exception.thrown("FAIL: values are not equal (expected: " + expected + ", actual: " + actual + ")");
    }
    bitmap.width = w;
    bitmap.height = h;
    var this1 = new Array(data.length / 4 | 0);
    bitmap.data = this1;
    var i = 0;
    var x = 0;
    while(i < data.length) {
        var red = data.b[i];
        var green = data.b[i + 1];
        var blue = data.b[i + 2];
        var alpha = data.b[i + 3];
        bitmap.data[x] = ((red < 0 ? 0 : red > 255 ? 255 : red) << 24) + ((green < 0 ? 0 : green > 255 ? 255 : green) << 16) + ((blue < 0 ? 0 : blue > 255 ? 255 : blue) << 8) + (alpha < 0 ? 0 : alpha > 255 ? 255 : alpha);
        i += 4;
        ++x;
    }
    return bitmap;
};
geometrize_bitmap_Bitmap.prototype = {
    getPixel: function(x,y) {
        return this.data[this.width * y + x];
    }
    ,setPixel: function(x,y,color) {
        this.data[this.width * y + x] = color;
    }
    ,clone: function() {
        var bitmap = new geometrize_bitmap_Bitmap();
        bitmap.width = this.width;
        bitmap.height = this.height;
        var this1 = new Array(this.data.length);
        bitmap.data = this1;
        var _g = 0;
        var _g1 = this.data.length;
        while(_g < _g1) {
            var i = _g++;
            bitmap.data[i] = this.data[i];
        }
        return bitmap;
    }
    ,fill: function(color) {
        var idx = 0;
        while(idx < this.data.length) {
            this.data[idx] = color >> 24 & 255;
            this.data[idx + 1] = color >> 16 & 255;
            this.data[idx + 2] = color >> 8 & 255;
            this.data[idx + 3] = color & 255;
            idx += 4;
        }
    }
    ,getBytes: function() {
        var bytes = new haxe_io_Bytes(new ArrayBuffer(this.data.length * 4));
        var i = 0;
        while(i < this.data.length) {
            var idx = i * 4;
            bytes.b[idx] = this.data[i] >> 24 & 255;
            bytes.b[idx + 1] = this.data[i] >> 16 & 255;
            bytes.b[idx + 2] = this.data[i] >> 8 & 255;
            bytes.b[idx + 3] = this.data[i] & 255;
            ++i;
        }
        return bytes;
    }
};
var geometrize_exporter_ShapeJsonExporter = $hx_exports["geometrize"]["exporter"]["ShapeJsonExporter"] = function() { };
geometrize_exporter_ShapeJsonExporter.export = function(shapes) {
    return "[\n" + geometrize_exporter_ShapeJsonExporter.exportShapes(shapes) + "\n]";
};
geometrize_exporter_ShapeJsonExporter.exportShapes = function(shapes) {
    var results = "";
    var _g = 0;
    var _g1 = shapes.length;
    while(_g < _g1) {
        var i = _g++;
        results += geometrize_exporter_ShapeJsonExporter.exportShape(shapes[i]);
        if(i != shapes.length - 1) {
            results += ",\n";
        }
    }
    return results;
};
geometrize_exporter_ShapeJsonExporter.exportShape = function(shape) {
    var result = "    {\n";
    var type = shape.shape.getType();
    var data = shape.shape.getRawShapeData();
    var color = shape.color;
    var score = shape.score;
    result += "        \"type\":" + type + ",\n";
    result += "        \"data\":" + "[";
    var _g = 0;
    var _g1 = data.length;
    while(_g < _g1) {
        var item = _g++;
        result += data[item];
        if(item <= data.length - 2) {
            result += ",";
        }
    }
    result += "],\n";
    result += "        \"color\":" + "[";
    result += (color >> 24 & 255) + ",";
    result += (color >> 16 & 255) + ",";
    result += (color >> 8 & 255) + ",";
    result += color & 255;
    result += "],\n";
    result += "        \"score\":" + score + "\n";
    result += "    }";
    return result;
};
var geometrize_exporter_SvgExporter = $hx_exports["geometrize"]["exporter"]["SvgExporter"] = function() { };
geometrize_exporter_SvgExporter.export = function(shapes,width,height) {
    var results = geometrize_exporter_SvgExporter.getSvgPrelude();
    results += geometrize_exporter_SvgExporter.getSvgNodeOpen(width,height);
    results += geometrize_exporter_SvgExporter.exportShapes(shapes);
    results += geometrize_exporter_SvgExporter.getSvgNodeClose();
    return results;
};
geometrize_exporter_SvgExporter.exportShapes = function(shapes) {
    var results = "";
    var _g = 0;
    var _g1 = shapes.length;
    while(_g < _g1) {
        var i = _g++;
        results += geometrize_exporter_SvgExporter.exportShape(shapes[i]);
        if(i != shapes.length - 1) {
            results += "\n";
        }
    }
    return results;
};
geometrize_exporter_SvgExporter.exportShape = function(shape) {
    return StringTools.replace(shape.shape.getSvgShapeData(),geometrize_exporter_SvgExporter.SVG_STYLE_HOOK,geometrize_exporter_SvgExporter.stylesForShape(shape));
};
geometrize_exporter_SvgExporter.getSvgPrelude = function() {
    return "<?xml version=\"1.0\" standalone=\"no\"?>\n";
};
geometrize_exporter_SvgExporter.getSvgNodeOpen = function(width,height) {
    return "<svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.2\" baseProfile=\"tiny\" width=\"" + width + "\" height=\"" + height + "\">\n";
};
geometrize_exporter_SvgExporter.getSvgNodeClose = function() {
    return "</svg>";
};
geometrize_exporter_SvgExporter.stylesForShape = function(shape) {
    switch(shape.shape.getType()) {
    case 6:case 7:
        return geometrize_exporter_SvgExporter.strokeForColor(shape.color) + " stroke-width=\"1\" fill=\"none\" " + geometrize_exporter_SvgExporter.strokeOpacityForAlpha(shape.color & 255);
    default:
        return geometrize_exporter_SvgExporter.fillForColor(shape.color) + " " + geometrize_exporter_SvgExporter.fillOpacityForAlpha(shape.color & 255);
    }
};
geometrize_exporter_SvgExporter.rgbForColor = function(color) {
    return "rgb(" + (color >> 24 & 255) + "," + (color >> 16 & 255) + "," + (color >> 8 & 255) + ")";
};
geometrize_exporter_SvgExporter.strokeForColor = function(color) {
    return "stroke=\"" + geometrize_exporter_SvgExporter.rgbForColor(color) + "\"";
};
geometrize_exporter_SvgExporter.fillForColor = function(color) {
    return "fill=\"" + geometrize_exporter_SvgExporter.rgbForColor(color) + "\"";
};
geometrize_exporter_SvgExporter.fillOpacityForAlpha = function(alpha) {
    return "fill-opacity=\"" + alpha / 255.0 + "\"";
};
geometrize_exporter_SvgExporter.strokeOpacityForAlpha = function(alpha) {
    return "stroke-opacity=\"" + alpha / 255.0 + "\"";
};
var geometrize_rasterizer_Rasterizer = function() { };
geometrize_rasterizer_Rasterizer.drawLines = function(image,c,lines) {
    if(image == null) {
        throw haxe_Exception.thrown("FAIL: image != null");
    }
    if(lines == null) {
        throw haxe_Exception.thrown("FAIL: lines != null");
    }
    var sr = c >> 24 & 255;
    sr |= sr << 8;
    sr *= c & 255;
    sr = sr / 255 | 0;
    var sg = c >> 16 & 255;
    sg |= sg << 8;
    sg *= c & 255;
    sg = sg / 255 | 0;
    var sb = c >> 8 & 255;
    sb |= sb << 8;
    sb *= c & 255;
    sb = sb / 255 | 0;
    var sa = c & 255;
    sa |= sa << 8;
    var _g = 0;
    while(_g < lines.length) {
        var line = lines[_g];
        ++_g;
        var y = line.y;
        var ma = 65535;
        var m = 65535;
        var as = (m - sa * (ma / m)) * 257;
        var a = as | 0;
        var _g1 = line.x1;
        var _g2 = line.x2 + 1;
        while(_g1 < _g2) {
            var x = _g1++;
            var d = image.data[image.width * y + x];
            var dr = d >> 24 & 255;
            var dg = d >> 16 & 255;
            var db = d >> 8 & 255;
            var da = d & 255;
            var r = (UInt.toFloat(dr * a + sr * ma) / UInt.toFloat(m) | 0) >> 8;
            var g = (UInt.toFloat(dg * a + sg * ma) / UInt.toFloat(m) | 0) >> 8;
            var b = (UInt.toFloat(db * a + sb * ma) / UInt.toFloat(m) | 0) >> 8;
            var a1 = (UInt.toFloat(da * a + sa * ma) / UInt.toFloat(m) | 0) >> 8;
            image.data[image.width * y + x] = ((r < 0 ? 0 : r > 255 ? 255 : r) << 24) + ((g < 0 ? 0 : g > 255 ? 255 : g) << 16) + ((b < 0 ? 0 : b > 255 ? 255 : b) << 8) + (a1 < 0 ? 0 : a1 > 255 ? 255 : a1);
        }
    }
};
geometrize_rasterizer_Rasterizer.copyLines = function(destination,source,lines) {
    if(destination == null) {
        throw haxe_Exception.thrown("FAIL: destination != null");
    }
    if(source == null) {
        throw haxe_Exception.thrown("FAIL: source != null");
    }
    if(lines == null) {
        throw haxe_Exception.thrown("FAIL: lines != null");
    }
    var _g = 0;
    while(_g < lines.length) {
        var line = lines[_g];
        ++_g;
        var y = line.y;
        var _g1 = line.x1;
        var _g2 = line.x2 + 1;
        while(_g1 < _g2) {
            var x = _g1++;
            destination.data[destination.width * y + x] = source.data[source.width * y + x];
        }
    }
};
geometrize_rasterizer_Rasterizer.bresenham = function(x1,y1,x2,y2) {
    var dx = x2 - x1;
    var ix = (dx > 0 ? 1 : 0) - (dx < 0 ? 1 : 0);
    dx = (dx < 0 ? -dx : dx) << 1;
    var dy = y2 - y1;
    var iy = (dy > 0 ? 1 : 0) - (dy < 0 ? 1 : 0);
    dy = (dy < 0 ? -dy : dy) << 1;
    var points = [];
    points.push({ x : x1, y : y1});
    if(dx >= dy) {
        var error = dy - (dx >> 1);
        while(x1 != x2) {
            if(error >= 0 && (error != 0 || ix > 0)) {
                error -= dx;
                y1 += iy;
            }
            error += dy;
            x1 += ix;
            points.push({ x : x1, y : y1});
        }
    } else {
        var error = dx - (dy >> 1);
        while(y1 != y2) {
            if(error >= 0 && (error != 0 || iy > 0)) {
                error -= dy;
                x1 += ix;
            }
            error += dx;
            y1 += iy;
            points.push({ x : x1, y : y1});
        }
    }
    return points;
};
geometrize_rasterizer_Rasterizer.scanlinesForPolygon = function(points) {
    var lines = [];
    var edges = [];
    var _g = 0;
    var _g1 = points.length;
    while(_g < _g1) {
        var i = _g++;
        var p1 = points[i];
        var p2 = i == points.length - 1 ? points[0] : points[i + 1];
        var p1p2 = geometrize_rasterizer_Rasterizer.bresenham(p1.x,p1.y,p2.x,p2.y);
        edges = edges.concat(p1p2);
    }
    var yToXs = new haxe_ds_IntMap();
    var _g = 0;
    while(_g < edges.length) {
        var point = edges[_g];
        ++_g;
        var s = yToXs.h[point.y];
        if(s != null) {
            geometrize_ArraySet.add(s,point.x);
        } else {
            s = geometrize_ArraySet.create();
            geometrize_ArraySet.add(s,point.x);
            yToXs.h[point.y] = s;
        }
    }
    var key = yToXs.keys();
    while(key.hasNext()) {
        var key1 = key.next();
        var a = geometrize_ArraySet.toArray(yToXs.h[key1]);
        var minMaxElements;
        if(a == null || a.length == 0) {
            minMaxElements = { x : 0, y : 0};
        } else {
            var min = a[0];
            var max = a[0];
            var _g = 0;
            while(_g < a.length) {
                var value = a[_g];
                ++_g;
                if(min > value) {
                    min = value;
                }
                if(max < value) {
                    max = value;
                }
            }
            minMaxElements = { x : min, y : max};
        }
        lines.push(new geometrize_rasterizer_Scanline(key1,minMaxElements.x,minMaxElements.y));
    }
    return lines;
};
var geometrize_rasterizer_Scanline = function(y,x1,x2) {
    this.y = y;
    this.x1 = x1;
    this.x2 = x2;
};
geometrize_rasterizer_Scanline.trim = function(scanlines,w,h) {
    if(scanlines == null) {
        throw haxe_Exception.thrown("FAIL: scanlines != null");
    }
    var w1 = w;
    var h1 = h;
    var f = function(line) {
        if(line.y < 0 || line.y >= h1 || line.x1 >= w1 || line.x2 < 0) {
            return false;
        } else {
            var value = line.x1;
            var max = w1 - 1;
            if(0 > max) {
                throw haxe_Exception.thrown("FAIL: min <= max");
            }
            line.x1 = value < 0 ? 0 : value > max ? max : value;
            var value = line.x2;
            var max = w1 - 1;
            if(0 > max) {
                throw haxe_Exception.thrown("FAIL: min <= max");
            }
            line.x2 = value < 0 ? 0 : value > max ? max : value;
            return line.x1 <= line.x2;
        }
    };
    var _g = [];
    var _g1 = 0;
    var _g2 = scanlines;
    while(_g1 < _g2.length) {
        var v = _g2[_g1];
        ++_g1;
        if(f(v)) {
            _g.push(v);
        }
    }
    return _g;
};
var geometrize_runner_ImageRunner = $hx_exports["geometrize"]["runner"]["ImageRunner"] = function(inputImage,backgroundColor) {
    this.model = null;
    this.model = new geometrize_Model(inputImage,backgroundColor);
};
geometrize_runner_ImageRunner.prototype = {
    step: function(options) {
        var finalOptions_shapeTypes = options.shapeTypes != null && options.shapeTypes.length != 0 ? options.shapeTypes : geometrize_runner_Default.options.shapeTypes;
        var finalOptions_alpha = options.alpha != null ? options.alpha : geometrize_runner_Default.options.alpha;
        var finalOptions_candidateShapesPerStep = options.candidateShapesPerStep != null ? options.candidateShapesPerStep : geometrize_runner_Default.options.candidateShapesPerStep;
        var finalOptions_shapeMutationsPerStep = options.shapeMutationsPerStep != null ? options.shapeMutationsPerStep : geometrize_runner_Default.options.shapeMutationsPerStep;
        return this.model.step(finalOptions_shapeTypes,finalOptions_alpha,finalOptions_candidateShapesPerStep,finalOptions_shapeMutationsPerStep);
    }
    ,getImageData: function() {
        if(this.model == null) {
            throw haxe_Exception.thrown("FAIL: model != null");
        }
        return this.model.current;
    }
};
var geometrize_runner_Default = function() { };
var geometrize_shape_Ellipse = function(xBound,yBound) {
    this.x = Std.random(xBound);
    this.y = Std.random(yBound);
    this.rx = Std.random(32) + 1;
    this.ry = Std.random(32) + 1;
    this.xBound = xBound;
    this.yBound = yBound;
};
geometrize_shape_Ellipse.prototype = {
    rasterize: function() {
        var lines = [];
        var aspect = this.rx / this.ry;
        var w = this.xBound;
        var h = this.yBound;
        var _g = 0;
        var _g1 = this.ry;
        while(_g < _g1) {
            var dy = _g++;
            var y1 = this.y - dy;
            var y2 = this.y + dy;
            if((y1 < 0 || y1 >= h) && (y2 < 0 || y2 >= h)) {
                continue;
            }
            var s = Math.sqrt(this.ry * this.ry - dy * dy) * aspect | 0;
            var x1 = this.x - s;
            var x2 = this.x + s;
            if(x1 < 0) {
                x1 = 0;
            }
            if(x2 >= w) {
                x2 = w - 1;
            }
            if(y1 >= 0 && y1 < h) {
                lines.push(new geometrize_rasterizer_Scanline(y1,x1,x2));
            }
            if(y2 >= 0 && y2 < h && dy > 0) {
                lines.push(new geometrize_rasterizer_Scanline(y2,x1,x2));
            }
        }
        return lines;
    }
    ,mutate: function() {
        var r = Std.random(3);
        switch(r) {
        case 0:
            var value = this.x + (-16 + Math.floor(33 * Math.random()));
            var max = this.xBound - 1;
            if(0 > max) {
                throw haxe_Exception.thrown("FAIL: min <= max");
            }
            this.x = value < 0 ? 0 : value > max ? max : value;
            var value = this.y + (-16 + Math.floor(33 * Math.random()));
            var max = this.yBound - 1;
            if(0 > max) {
                throw haxe_Exception.thrown("FAIL: min <= max");
            }
            this.y = value < 0 ? 0 : value > max ? max : value;
            break;
        case 1:
            var value = this.rx + (-16 + Math.floor(33 * Math.random()));
            var max = this.xBound - 1;
            if(1 > max) {
                throw haxe_Exception.thrown("FAIL: min <= max");
            }
            this.rx = value < 1 ? 1 : value > max ? max : value;
            break;
        case 2:
            var value = this.ry + (-16 + Math.floor(33 * Math.random()));
            var max = this.xBound - 1;
            if(1 > max) {
                throw haxe_Exception.thrown("FAIL: min <= max");
            }
            this.ry = value < 1 ? 1 : value > max ? max : value;
            break;
        }
    }
    ,clone: function() {
        var ellipse = new geometrize_shape_Ellipse(this.xBound,this.yBound);
        ellipse.x = this.x;
        ellipse.y = this.y;
        ellipse.rx = this.rx;
        ellipse.ry = this.ry;
        return ellipse;
    }
    ,getType: function() {
        return 3;
    }
    ,getRawShapeData: function() {
        return [this.x,this.y,this.rx,this.ry];
    }
    ,getSvgShapeData: function() {
        return "<ellipse cx=\"" + this.x + "\" cy=\"" + this.y + "\" rx=\"" + this.rx + "\" ry=\"" + this.ry + "\" " + geometrize_exporter_SvgExporter.SVG_STYLE_HOOK + " />";
    }
};
var geometrize_shape_Circle = function(xBound,yBound) {
    geometrize_shape_Ellipse.call(this,xBound,yBound);
    this.rx = Std.random(32) + 1;
    this.ry = this.rx;
};
geometrize_shape_Circle.__super__ = geometrize_shape_Ellipse;
geometrize_shape_Circle.prototype = $extend(geometrize_shape_Ellipse.prototype,{
    mutate: function() {
        var r = Std.random(2);
        switch(r) {
        case 0:
            var value = this.x + (-16 + Math.floor(33 * Math.random()));
            var max = this.xBound - 1;
            if(0 > max) {
                throw haxe_Exception.thrown("FAIL: min <= max");
            }
            this.x = value < 0 ? 0 : value > max ? max : value;
            var value = this.y + (-16 + Math.floor(33 * Math.random()));
            var max = this.yBound - 1;
            if(0 > max) {
                throw haxe_Exception.thrown("FAIL: min <= max");
            }
            this.y = value < 0 ? 0 : value > max ? max : value;
            break;
        case 1:
            var value = this.rx + (-16 + Math.floor(33 * Math.random()));
            var max = this.xBound - 1;
            if(1 > max) {
                throw haxe_Exception.thrown("FAIL: min <= max");
            }
            var r = value < 1 ? 1 : value > max ? max : value;
            this.rx = r;
            this.ry = r;
            break;
        }
    }
    ,clone: function() {
        var circle = new geometrize_shape_Circle(this.xBound,this.yBound);
        circle.x = this.x;
        circle.y = this.y;
        circle.rx = this.rx;
        circle.ry = this.ry;
        return circle;
    }
    ,getType: function() {
        return 5;
    }
    ,getRawShapeData: function() {
        return [this.x,this.y,this.rx];
    }
    ,getSvgShapeData: function() {
        return "<circle cx=\"" + this.x + "\" cy=\"" + this.y + "\" r=\"" + this.rx + "\" " + geometrize_exporter_SvgExporter.SVG_STYLE_HOOK + " />";
    }
});
var geometrize_shape_Line = function(xBound,yBound) {
    this.x1 = Std.random(xBound);
    this.y1 = Std.random(yBound);
    var value = this.x1 + Std.random(32) + 1;
    if(0 > xBound) {
        throw haxe_Exception.thrown("FAIL: min <= max");
    }
    this.x2 = value < 0 ? 0 : value > xBound ? xBound : value;
    var value = this.y1 + Std.random(32) + 1;
    if(0 > yBound) {
        throw haxe_Exception.thrown("FAIL: min <= max");
    }
    this.y2 = value < 0 ? 0 : value > yBound ? yBound : value;
    this.xBound = xBound;
    this.yBound = yBound;
};
geometrize_shape_Line.prototype = {
    rasterize: function() {
        var lines = [];
        var points = geometrize_rasterizer_Rasterizer.bresenham(this.x1,this.y1,this.x2,this.y2);
        var _g = 0;
        while(_g < points.length) {
            var point = points[_g];
            ++_g;
            lines.push(new geometrize_rasterizer_Scanline(point.y,point.x,point.x));
        }
        return geometrize_rasterizer_Scanline.trim(lines,this.xBound,this.yBound);
    }
    ,mutate: function() {
        var r = Std.random(4);
        switch(r) {
        case 0:
            var value = this.x1 + (-16 + Math.floor(33 * Math.random()));
            var max = this.xBound - 1;
            if(0 > max) {
                throw haxe_Exception.thrown("FAIL: min <= max");
            }
            this.x1 = value < 0 ? 0 : value > max ? max : value;
            var value = this.y1 + (-16 + Math.floor(33 * Math.random()));
            var max = this.yBound - 1;
            if(0 > max) {
                throw haxe_Exception.thrown("FAIL: min <= max");
            }
            this.y1 = value < 0 ? 0 : value > max ? max : value;
            break;
        case 1:
            var value = this.x2 + (-16 + Math.floor(33 * Math.random()));
            var max = this.xBound - 1;
            if(0 > max) {
                throw haxe_Exception.thrown("FAIL: min <= max");
            }
            this.x2 = value < 0 ? 0 : value > max ? max : value;
            var value = this.y2 + (-16 + Math.floor(33 * Math.random()));
            var max = this.yBound - 1;
            if(0 > max) {
                throw haxe_Exception.thrown("FAIL: min <= max");
            }
            this.y2 = value < 0 ? 0 : value > max ? max : value;
            break;
        }
    }
    ,clone: function() {
        var line = new geometrize_shape_Line(this.xBound,this.yBound);
        line.x1 = this.x1;
        line.y1 = this.y1;
        line.x2 = this.x2;
        line.y2 = this.y2;
        return line;
    }
    ,getType: function() {
        return 6;
    }
    ,getRawShapeData: function() {
        return [this.x1,this.y1,this.x2,this.y2];
    }
    ,getSvgShapeData: function() {
        return "<line x1=\"" + this.x1 + "\" y1=\"" + this.y1 + "\" x2=\"" + this.x2 + "\" y2=\"" + this.y2 + "\" " + geometrize_exporter_SvgExporter.SVG_STYLE_HOOK + " />";
    }
};
var geometrize_shape_QuadraticBezier = function(xBound,yBound) {
    var upper = xBound - 1;
    if(0 > upper) {
        throw haxe_Exception.thrown("FAIL: lower <= upper");
    }
    this.x1 = Math.floor((upper + 1) * Math.random());
    var upper = yBound - 1;
    if(0 > upper) {
        throw haxe_Exception.thrown("FAIL: lower <= upper");
    }
    this.y1 = Math.floor((upper + 1) * Math.random());
    var upper = xBound - 1;
    if(0 > upper) {
        throw haxe_Exception.thrown("FAIL: lower <= upper");
    }
    this.cx = Math.floor((upper + 1) * Math.random());
    var upper = yBound - 1;
    if(0 > upper) {
        throw haxe_Exception.thrown("FAIL: lower <= upper");
    }
    this.cy = Math.floor((upper + 1) * Math.random());
    var upper = xBound - 1;
    if(0 > upper) {
        throw haxe_Exception.thrown("FAIL: lower <= upper");
    }
    this.x2 = Math.floor((upper + 1) * Math.random());
    var upper = yBound - 1;
    if(0 > upper) {
        throw haxe_Exception.thrown("FAIL: lower <= upper");
    }
    this.y2 = Math.floor((upper + 1) * Math.random());
    this.xBound = xBound;
    this.yBound = yBound;
};
geometrize_shape_QuadraticBezier.prototype = {
    rasterize: function() {
        var lines = [];
        var points = [];
        var pointCount = 20;
        var _g = 0;
        var _g1 = pointCount - 1;
        while(_g < _g1) {
            var i = _g++;
            var t = i / pointCount;
            var tp = 1 - t;
            var x = tp * (tp * this.x1 + t * this.cx) + t * (tp * this.cx + t * this.x2) | 0;
            var y = tp * (tp * this.y1 + t * this.cy) + t * (tp * this.cy + t * this.y2) | 0;
            points.push({ x : x, y : y});
        }
        var _g = 0;
        var _g1 = points.length - 1;
        while(_g < _g1) {
            var i = _g++;
            var p0 = points[i];
            var p1 = points[i + 1];
            var pts = geometrize_rasterizer_Rasterizer.bresenham(p0.x,p0.y,p1.x,p1.y);
            var _g2 = 0;
            while(_g2 < pts.length) {
                var point = pts[_g2];
                ++_g2;
                if(lines.length > 0) {
                    var lastLine = lines[lines.length - 1];
                    if(lastLine.y == point.y && lastLine.x1 == point.x && lastLine.x2 == point.x) {
                        continue;
                    }
                }
                lines.push(new geometrize_rasterizer_Scanline(point.y,point.x,point.x));
            }
        }
        return geometrize_rasterizer_Scanline.trim(lines,this.xBound,this.yBound);
    }
    ,mutate: function() {
        var r = Math.floor(3 * Math.random());
        switch(r) {
        case 0:
            var value = this.cx + (-8 + Math.floor(17 * Math.random()));
            var max = this.xBound - 1;
            if(0 > max) {
                throw haxe_Exception.thrown("FAIL: min <= max");
            }
            this.cx = value < 0 ? 0 : value > max ? max : value;
            var value = this.cy + (-8 + Math.floor(17 * Math.random()));
            var max = this.yBound - 1;
            if(0 > max) {
                throw haxe_Exception.thrown("FAIL: min <= max");
            }
            this.cy = value < 0 ? 0 : value > max ? max : value;
            break;
        case 1:
            var value = this.x1 + (-8 + Math.floor(17 * Math.random()));
            var max = this.xBound - 1;
            if(1 > max) {
                throw haxe_Exception.thrown("FAIL: min <= max");
            }
            this.x1 = value < 1 ? 1 : value > max ? max : value;
            var value = this.y1 + (-8 + Math.floor(17 * Math.random()));
            var max = this.yBound - 1;
            if(1 > max) {
                throw haxe_Exception.thrown("FAIL: min <= max");
            }
            this.y1 = value < 1 ? 1 : value > max ? max : value;
            break;
        case 2:
            var value = this.x2 + (-8 + Math.floor(17 * Math.random()));
            var max = this.xBound - 1;
            if(1 > max) {
                throw haxe_Exception.thrown("FAIL: min <= max");
            }
            this.x2 = value < 1 ? 1 : value > max ? max : value;
            var value = this.y2 + (-8 + Math.floor(17 * Math.random()));
            var max = this.yBound - 1;
            if(1 > max) {
                throw haxe_Exception.thrown("FAIL: min <= max");
            }
            this.y2 = value < 1 ? 1 : value > max ? max : value;
            break;
        }
    }
    ,clone: function() {
        var bezier = new geometrize_shape_QuadraticBezier(this.xBound,this.yBound);
        bezier.cx = this.cx;
        bezier.cy = this.cy;
        bezier.x1 = this.x1;
        bezier.y1 = this.y1;
        bezier.x2 = this.x2;
        bezier.y2 = this.y2;
        return bezier;
    }
    ,getType: function() {
        return 7;
    }
    ,getRawShapeData: function() {
        return [this.x1,this.y1,this.cx,this.cy,this.x2,this.y2];
    }
    ,getSvgShapeData: function() {
        return "<path d=\"M" + this.x1 + " " + this.y1 + " Q " + this.cx + " " + this.cy + " " + this.x2 + " " + this.y2 + "\" " + geometrize_exporter_SvgExporter.SVG_STYLE_HOOK + " />";
    }
};
var geometrize_shape_Rectangle = function(xBound,yBound) {
    this.x1 = Std.random(xBound);
    this.y1 = Std.random(yBound);
    var value = this.x1 + Std.random(32) + 1;
    var max = xBound - 1;
    if(0 > max) {
        throw haxe_Exception.thrown("FAIL: min <= max");
    }
    this.x2 = value < 0 ? 0 : value > max ? max : value;
    var value = this.y1 + Std.random(32) + 1;
    var max = yBound - 1;
    if(0 > max) {
        throw haxe_Exception.thrown("FAIL: min <= max");
    }
    this.y2 = value < 0 ? 0 : value > max ? max : value;
    this.xBound = xBound;
    this.yBound = yBound;
};
geometrize_shape_Rectangle.prototype = {
    rasterize: function() {
        var lines = [];
        var first = this.y1;
        var second = this.y2;
        var yMin = first < second ? first : second;
        var first = this.y1;
        var second = this.y2;
        var yMax = first > second ? first : second;
        if(yMin == yMax) {
            var first = this.x1;
            var second = this.x2;
            var first1 = this.x1;
            var second1 = this.x2;
            lines.push(new geometrize_rasterizer_Scanline(yMin,first < second ? first : second,first1 > second1 ? first1 : second1));
        } else {
            var _g = yMin;
            var _g1 = yMax;
            while(_g < _g1) {
                var y = _g++;
                var first = this.x1;
                var second = this.x2;
                var first1 = this.x1;
                var second1 = this.x2;
                lines.push(new geometrize_rasterizer_Scanline(y,first < second ? first : second,first1 > second1 ? first1 : second1));
            }
        }
        return lines;
    }
    ,mutate: function() {
        var r = Std.random(2);
        switch(r) {
        case 0:
            var value = this.x1 + (-16 + Math.floor(33 * Math.random()));
            var max = this.xBound - 1;
            if(0 > max) {
                throw haxe_Exception.thrown("FAIL: min <= max");
            }
            this.x1 = value < 0 ? 0 : value > max ? max : value;
            var value = this.y1 + (-16 + Math.floor(33 * Math.random()));
            var max = this.yBound - 1;
            if(0 > max) {
                throw haxe_Exception.thrown("FAIL: min <= max");
            }
            this.y1 = value < 0 ? 0 : value > max ? max : value;
            break;
        case 1:
            var value = this.x2 + (-16 + Math.floor(33 * Math.random()));
            var max = this.xBound - 1;
            if(0 > max) {
                throw haxe_Exception.thrown("FAIL: min <= max");
            }
            this.x2 = value < 0 ? 0 : value > max ? max : value;
            var value = this.y2 + (-16 + Math.floor(33 * Math.random()));
            var max = this.yBound - 1;
            if(0 > max) {
                throw haxe_Exception.thrown("FAIL: min <= max");
            }
            this.y2 = value < 0 ? 0 : value > max ? max : value;
            break;
        }
    }
    ,clone: function() {
        var rectangle = new geometrize_shape_Rectangle(this.xBound,this.yBound);
        rectangle.x1 = this.x1;
        rectangle.y1 = this.y1;
        rectangle.x2 = this.x2;
        rectangle.y2 = this.y2;
        return rectangle;
    }
    ,getType: function() {
        return 0;
    }
    ,getRawShapeData: function() {
        var first = this.x1;
        var second = this.x2;
        var first1 = this.y1;
        var second1 = this.y2;
        var first2 = this.x1;
        var second2 = this.x2;
        var first3 = this.y1;
        var second3 = this.y2;
        return [first < second ? first : second,first1 < second1 ? first1 : second1,first2 > second2 ? first2 : second2,first3 > second3 ? first3 : second3];
    }
    ,getSvgShapeData: function() {
        var first = this.x1;
        var second = this.x2;
        var first1 = this.y1;
        var second1 = this.y2;
        var first2 = this.x1;
        var second2 = this.x2;
        var first3 = this.x1;
        var second3 = this.x2;
        var first4 = this.y1;
        var second4 = this.y2;
        var first5 = this.y1;
        var second5 = this.y2;
        return "<rect x=\"" + (first < second ? first : second) + "\" y=\"" + (first1 < second1 ? first1 : second1) + "\" width=\"" + ((first2 > second2 ? first2 : second2) - (first3 < second3 ? first3 : second3)) + "\" height=\"" + ((first4 > second4 ? first4 : second4) - (first5 < second5 ? first5 : second5)) + "\" " + geometrize_exporter_SvgExporter.SVG_STYLE_HOOK + " />";
    }
};
var geometrize_shape_RotatedEllipse = function(xBound,yBound) {
    this.x = Std.random(xBound);
    this.y = Std.random(yBound);
    this.rx = Std.random(32) + 1;
    this.ry = Std.random(32) + 1;
    this.angle = Std.random(360);
    this.xBound = xBound;
    this.yBound = yBound;
};
geometrize_shape_RotatedEllipse.prototype = {
    rasterize: function() {
        var pointCount = 20;
        var points = [];
        var rads = this.angle * (Math.PI / 180.0);
        var c = Math.cos(rads);
        var s = Math.sin(rads);
        var _g = 0;
        var _g1 = pointCount;
        while(_g < _g1) {
            var i = _g++;
            var rot = 360.0 / pointCount * i * (Math.PI / 180.0);
            var crx = this.rx * Math.cos(rot);
            var cry = this.ry * Math.sin(rot);
            var tx = crx * c - cry * s + this.x | 0;
            var ty = crx * s + cry * c + this.y | 0;
            points.push({ x : tx, y : ty});
        }
        return geometrize_rasterizer_Scanline.trim(geometrize_rasterizer_Rasterizer.scanlinesForPolygon(points),this.xBound,this.yBound);
    }
    ,mutate: function() {
        var r = Std.random(4);
        switch(r) {
        case 0:
            var value = this.x + (-16 + Math.floor(33 * Math.random()));
            var max = this.xBound - 1;
            if(0 > max) {
                throw haxe_Exception.thrown("FAIL: min <= max");
            }
            this.x = value < 0 ? 0 : value > max ? max : value;
            var value = this.y + (-16 + Math.floor(33 * Math.random()));
            var max = this.yBound - 1;
            if(0 > max) {
                throw haxe_Exception.thrown("FAIL: min <= max");
            }
            this.y = value < 0 ? 0 : value > max ? max : value;
            break;
        case 1:
            var value = this.rx + (-16 + Math.floor(33 * Math.random()));
            var max = this.xBound - 1;
            if(1 > max) {
                throw haxe_Exception.thrown("FAIL: min <= max");
            }
            this.rx = value < 1 ? 1 : value > max ? max : value;
            break;
        case 2:
            var value = this.ry + (-16 + Math.floor(33 * Math.random()));
            var max = this.yBound - 1;
            if(1 > max) {
                throw haxe_Exception.thrown("FAIL: min <= max");
            }
            this.ry = value < 1 ? 1 : value > max ? max : value;
            break;
        case 3:
            var value = this.angle + (-4 + Math.floor(9 * Math.random()));
            this.angle = value < 0 ? 0 : value > 360 ? 360 : value;
            break;
        }
    }
    ,clone: function() {
        var ellipse = new geometrize_shape_RotatedEllipse(this.xBound,this.yBound);
        ellipse.x = this.x;
        ellipse.y = this.y;
        ellipse.rx = this.rx;
        ellipse.ry = this.ry;
        ellipse.angle = this.angle;
        return ellipse;
    }
    ,getType: function() {
        return 4;
    }
    ,getRawShapeData: function() {
        return [this.x,this.y,this.rx,this.ry,this.angle];
    }
    ,getSvgShapeData: function() {
        var s = "<g transform=\"translate(" + this.x + " " + this.y + ") rotate(" + this.angle + ") scale(" + this.rx + " " + this.ry + ")\">";
        s += "<ellipse cx=\"" + 0 + "\" cy=\"" + 0 + "\" rx=\"" + 1 + "\" ry=\"" + 1 + "\" " + geometrize_exporter_SvgExporter.SVG_STYLE_HOOK + " />";
        s += "</g>";
        return s;
    }
};
var geometrize_shape_RotatedRectangle = function(xBound,yBound) {
    this.x1 = Std.random(xBound);
    this.y1 = Std.random(yBound);
    var value = this.x1 + Std.random(32) + 1;
    if(0 > xBound) {
        throw haxe_Exception.thrown("FAIL: min <= max");
    }
    this.x2 = value < 0 ? 0 : value > xBound ? xBound : value;
    var value = this.y1 + Std.random(32) + 1;
    if(0 > yBound) {
        throw haxe_Exception.thrown("FAIL: min <= max");
    }
    this.y2 = value < 0 ? 0 : value > yBound ? yBound : value;
    this.angle = Math.floor(361 * Math.random());
    this.xBound = xBound;
    this.yBound = yBound;
};
geometrize_shape_RotatedRectangle.prototype = {
    rasterize: function() {
        var first = this.x1;
        var second = this.x2;
        var xm1 = first < second ? first : second;
        var first = this.x1;
        var second = this.x2;
        var xm2 = first > second ? first : second;
        var first = this.y1;
        var second = this.y2;
        var ym1 = first < second ? first : second;
        var first = this.y1;
        var second = this.y2;
        var ym2 = first > second ? first : second;
        var cx = (xm1 + xm2) / 2 | 0;
        var cy = (ym1 + ym2) / 2 | 0;
        var ox1 = xm1 - cx;
        var ox2 = xm2 - cx;
        var oy1 = ym1 - cy;
        var oy2 = ym2 - cy;
        var rads = this.angle * Math.PI / 180.0;
        var c = Math.cos(rads);
        var s = Math.sin(rads);
        var ulx = ox1 * c - oy1 * s + cx | 0;
        var uly = ox1 * s + oy1 * c + cy | 0;
        var blx = ox1 * c - oy2 * s + cx | 0;
        var bly = ox1 * s + oy2 * c + cy | 0;
        var urx = ox2 * c - oy1 * s + cx | 0;
        var ury = ox2 * s + oy1 * c + cy | 0;
        var brx = ox2 * c - oy2 * s + cx | 0;
        var bry = ox2 * s + oy2 * c + cy | 0;
        return geometrize_rasterizer_Scanline.trim(geometrize_rasterizer_Rasterizer.scanlinesForPolygon([{ x : ulx, y : uly},{ x : urx, y : ury},{ x : brx, y : bry},{ x : blx, y : bly}]),this.xBound,this.yBound);
    }
    ,mutate: function() {
        var r = Std.random(3);
        switch(r) {
        case 0:
            var value = this.x1 + (-16 + Math.floor(33 * Math.random()));
            var max = this.xBound - 1;
            if(0 > max) {
                throw haxe_Exception.thrown("FAIL: min <= max");
            }
            this.x1 = value < 0 ? 0 : value > max ? max : value;
            var value = this.y1 + (-16 + Math.floor(33 * Math.random()));
            var max = this.yBound - 1;
            if(0 > max) {
                throw haxe_Exception.thrown("FAIL: min <= max");
            }
            this.y1 = value < 0 ? 0 : value > max ? max : value;
            break;
        case 1:
            var value = this.x2 + (-16 + Math.floor(33 * Math.random()));
            var max = this.xBound - 1;
            if(0 > max) {
                throw haxe_Exception.thrown("FAIL: min <= max");
            }
            this.x2 = value < 0 ? 0 : value > max ? max : value;
            var value = this.y2 + (-16 + Math.floor(33 * Math.random()));
            var max = this.yBound - 1;
            if(0 > max) {
                throw haxe_Exception.thrown("FAIL: min <= max");
            }
            this.y2 = value < 0 ? 0 : value > max ? max : value;
            break;
        case 2:
            var value = this.angle + (-4 + Math.floor(9 * Math.random()));
            this.angle = value < 0 ? 0 : value > 360 ? 360 : value;
            break;
        }
    }
    ,clone: function() {
        var rectangle = new geometrize_shape_RotatedRectangle(this.xBound,this.yBound);
        rectangle.x1 = this.x1;
        rectangle.y1 = this.y1;
        rectangle.x2 = this.x2;
        rectangle.y2 = this.y2;
        rectangle.angle = this.angle;
        return rectangle;
    }
    ,getType: function() {
        return 1;
    }
    ,getRawShapeData: function() {
        var first = this.x1;
        var second = this.x2;
        var first1 = this.y1;
        var second1 = this.y2;
        var first2 = this.x1;
        var second2 = this.x2;
        var first3 = this.y1;
        var second3 = this.y2;
        return [first < second ? first : second,first1 < second1 ? first1 : second1,first2 > second2 ? first2 : second2,first3 > second3 ? first3 : second3,this.angle];
    }
    ,getSvgShapeData: function() {
        var first = this.x1;
        var second = this.x2;
        var xm1 = first < second ? first : second;
        var first = this.x1;
        var second = this.x2;
        var xm2 = first > second ? first : second;
        var first = this.y1;
        var second = this.y2;
        var ym1 = first < second ? first : second;
        var first = this.y1;
        var second = this.y2;
        var ym2 = first > second ? first : second;
        var cx = (xm1 + xm2) / 2 | 0;
        var cy = (ym1 + ym2) / 2 | 0;
        var ox1 = xm1 - cx;
        var ox2 = xm2 - cx;
        var oy1 = ym1 - cy;
        var oy2 = ym2 - cy;
        var rads = this.angle * Math.PI / 180.0;
        var c = Math.cos(rads);
        var s = Math.sin(rads);
        var ulx = ox1 * c - oy1 * s + cx | 0;
        var uly = ox1 * s + oy1 * c + cy | 0;
        var blx = ox1 * c - oy2 * s + cx | 0;
        var bly = ox1 * s + oy2 * c + cy | 0;
        var urx = ox2 * c - oy1 * s + cx | 0;
        var ury = ox2 * s + oy1 * c + cy | 0;
        var brx = ox2 * c - oy2 * s + cx | 0;
        var bry = ox2 * s + oy2 * c + cy | 0;
        var points = [{ x : ulx, y : uly},{ x : urx, y : ury},{ x : brx, y : bry},{ x : blx, y : bly}];
        var s = "<polygon points=\"";
        var _g = 0;
        var _g1 = points.length;
        while(_g < _g1) {
            var i = _g++;
            s += points[i].x + " " + points[i].y;
            if(i != points.length - 1) {
                s += " ";
            }
        }
        s += "\" " + geometrize_exporter_SvgExporter.SVG_STYLE_HOOK + "/>";
        return s;
    }
};
var geometrize_shape_ShapeFactory = function() { };
geometrize_shape_ShapeFactory.create = function(type,xBound,yBound) {
    switch(type) {
    case 0:
        return new geometrize_shape_Rectangle(xBound,yBound);
    case 1:
        return new geometrize_shape_RotatedRectangle(xBound,yBound);
    case 2:
        return new geometrize_shape_Triangle(xBound,yBound);
    case 3:
        return new geometrize_shape_Ellipse(xBound,yBound);
    case 4:
        return new geometrize_shape_RotatedEllipse(xBound,yBound);
    case 5:
        return new geometrize_shape_Circle(xBound,yBound);
    case 6:
        return new geometrize_shape_Line(xBound,yBound);
    case 7:
        return new geometrize_shape_QuadraticBezier(xBound,yBound);
    }
};
geometrize_shape_ShapeFactory.randomShapeOf = function(types,xBound,yBound) {
    if(!(types != null && types.length > 0)) {
        throw haxe_Exception.thrown("FAIL: a != null && a.length > 0");
    }
    var upper = types.length - 1;
    if(0 > upper) {
        throw haxe_Exception.thrown("FAIL: lower <= upper");
    }
    return geometrize_shape_ShapeFactory.create(types[Math.floor((upper + 1) * Math.random())],xBound,yBound);
};
var geometrize_shape_ShapeTypes = $hx_exports["geometrize"]["shape"]["ShapeTypes"] = function() { };
var geometrize_shape_Triangle = function(xBound,yBound) {
    this.x1 = Std.random(xBound);
    this.y1 = Std.random(yBound);
    this.x2 = this.x1 + (-16 + Math.floor(33 * Math.random()));
    this.y2 = this.y1 + (-16 + Math.floor(33 * Math.random()));
    this.x3 = this.x1 + (-16 + Math.floor(33 * Math.random()));
    this.y3 = this.y1 + (-16 + Math.floor(33 * Math.random()));
    this.xBound = xBound;
    this.yBound = yBound;
};
geometrize_shape_Triangle.prototype = {
    rasterize: function() {
        return geometrize_rasterizer_Scanline.trim(geometrize_rasterizer_Rasterizer.scanlinesForPolygon([{ x : this.x1, y : this.y1},{ x : this.x2, y : this.y2},{ x : this.x3, y : this.y3}]),this.xBound,this.yBound);
    }
    ,mutate: function() {
        var r = Std.random(3);
        switch(r) {
        case 0:
            var value = this.x1 + (-16 + Math.floor(33 * Math.random()));
            var max = this.xBound - 1;
            if(0 > max) {
                throw haxe_Exception.thrown("FAIL: min <= max");
            }
            this.x1 = value < 0 ? 0 : value > max ? max : value;
            var value = this.y1 + (-16 + Math.floor(33 * Math.random()));
            var max = this.yBound - 1;
            if(0 > max) {
                throw haxe_Exception.thrown("FAIL: min <= max");
            }
            this.y1 = value < 0 ? 0 : value > max ? max : value;
            break;
        case 1:
            var value = this.x2 + (-16 + Math.floor(33 * Math.random()));
            var max = this.xBound - 1;
            if(0 > max) {
                throw haxe_Exception.thrown("FAIL: min <= max");
            }
            this.x2 = value < 0 ? 0 : value > max ? max : value;
            var value = this.y2 + (-16 + Math.floor(33 * Math.random()));
            var max = this.yBound - 1;
            if(0 > max) {
                throw haxe_Exception.thrown("FAIL: min <= max");
            }
            this.y2 = value < 0 ? 0 : value > max ? max : value;
            break;
        case 2:
            var value = this.x3 + (-16 + Math.floor(33 * Math.random()));
            var max = this.xBound - 1;
            if(0 > max) {
                throw haxe_Exception.thrown("FAIL: min <= max");
            }
            this.x3 = value < 0 ? 0 : value > max ? max : value;
            var value = this.y3 + (-16 + Math.floor(33 * Math.random()));
            var max = this.yBound - 1;
            if(0 > max) {
                throw haxe_Exception.thrown("FAIL: min <= max");
            }
            this.y3 = value < 0 ? 0 : value > max ? max : value;
            break;
        }
    }
    ,clone: function() {
        var triangle = new geometrize_shape_Triangle(this.xBound,this.yBound);
        triangle.x1 = this.x1;
        triangle.y1 = this.y1;
        triangle.x2 = this.x2;
        triangle.y2 = this.y2;
        triangle.x3 = this.x3;
        triangle.y3 = this.y3;
        return triangle;
    }
    ,getType: function() {
        return 2;
    }
    ,getRawShapeData: function() {
        return [this.x1,this.y1,this.x2,this.y2,this.x3,this.y3];
    }
    ,getSvgShapeData: function() {
        return "<polygon points=\"" + this.x1 + "," + this.y1 + " " + this.x2 + "," + this.y2 + " " + this.x3 + "," + this.y3 + "\" " + geometrize_exporter_SvgExporter.SVG_STYLE_HOOK + "/>";
    }
};
var haxe_Exception = function(message,previous,native) {
    Error.call(this,message);
    this.message = message;
    this.__previousException = previous;
    this.__nativeException = native != null ? native : this;
};
haxe_Exception.thrown = function(value) {
    if(((value) instanceof haxe_Exception)) {
        return value.get_native();
    } else if(((value) instanceof Error)) {
        return value;
    } else {
        var e = new haxe_ValueException(value);
        return e;
    }
};
haxe_Exception.__super__ = Error;
haxe_Exception.prototype = $extend(Error.prototype,{
    get_native: function() {
        return this.__nativeException;
    }
});
var haxe_ValueException = function(value,previous,native) {
    haxe_Exception.call(this,String(value),previous,native);
    this.value = value;
};
haxe_ValueException.__super__ = haxe_Exception;
haxe_ValueException.prototype = $extend(haxe_Exception.prototype,{
});
var haxe_ds_IntMap = function() {
    this.h = { };
};
haxe_ds_IntMap.prototype = {
    keys: function() {
        var a = [];
        for( var key in this.h ) if(this.h.hasOwnProperty(key)) a.push(+key);
        return new haxe_iterators_ArrayIterator(a);
    }
};
var haxe_io_Bytes = function(data) {
    this.length = data.byteLength;
    this.b = new Uint8Array(data);
    this.b.bufferValue = data;
    data.hxBytes = this;
    data.bytes = this.b;
};
var haxe_iterators_ArrayIterator = function(array) {
    this.current = 0;
    this.array = array;
};
haxe_iterators_ArrayIterator.prototype = {
    hasNext: function() {
        return this.current < this.array.length;
    }
    ,next: function() {
        return this.array[this.current++];
    }
};
onmessage = GeometrizeWorker.prototype.messageHandler;
geometrize_exporter_SvgExporter.SVG_STYLE_HOOK = "::svg_style_hook::";
geometrize_runner_Default.options = { shapeTypes : [2], candidateShapesPerStep : 50, shapeMutationsPerStep : 100, alpha : 128};
geometrize_shape_ShapeTypes.RECTANGLE = 0;
geometrize_shape_ShapeTypes.ROTATED_RECTANGLE = 1;
geometrize_shape_ShapeTypes.TRIANGLE = 2;
geometrize_shape_ShapeTypes.ELLIPSE = 3;
geometrize_shape_ShapeTypes.ROTATED_ELLIPSE = 4;
geometrize_shape_ShapeTypes.CIRCLE = 5;
geometrize_shape_ShapeTypes.LINE = 6;
geometrize_shape_ShapeTypes.QUADRATIC_BEZIER = 7;
})(typeof exports != "undefined" ? exports : typeof window != "undefined" ? window : typeof self != "undefined" ? self : this, {});

</script>

<!-- ==================== LINE DRAWING MODULE ==================== -->
<script>
(function() {
    'use strict';
    
    const geometrizeInput = document.getElementById('geometrizeInput');
    const lineDrawingStyle = document.getElementById('lineDrawingStyle');
    const lineDrawingDetail = document.getElementById('lineDrawingDetail');
    const lineDrawingWeight = document.getElementById('lineDrawingWeight');
    const lineDrawingGrid = document.getElementById('lineDrawingGrid');
    const generateBtn = document.getElementById('generateLineDrawingBtn');
    const downloadBtn = document.getElementById('downloadLineDrawingBtn');
    const mainCanvas = document.getElementById('canvas');
    const statusDiv = document.getElementById('geometrizeStatus');
    
    const MAX_CANVAS_WIDTH = 600;
    const MAX_CANVAS_HEIGHT = 600;
    
    let lineDrawingFullSize = null;
    
    lineDrawingDetail.addEventListener('input', (e) => {
        document.getElementById('ldDetailVal').textContent = e.target.value;
    });
    lineDrawingWeight.addEventListener('input', (e) => {
        document.getElementById('ldWeightVal').textContent = e.target.value;
    });
    
    generateBtn.addEventListener('click', async () => {
        const file = geometrizeInput.files[0];
        if (!file) {
            statusDiv.textContent = 'Please select an image first above.';
            statusDiv.style.color = '#f44336';
            return;
        }
        
        statusDiv.textContent = 'Generating line drawing...';
        statusDiv.style.color = '#ff9800';
        generateBtn.disabled = true;
        
        const style = lineDrawingStyle.value;
        const detail = parseInt(lineDrawingDetail.value);
        const lineWeight = parseInt(lineDrawingWeight.value);
        const showGrid = lineDrawingGrid.checked;
        
        try {
            let resultImg;
            
            // Use API for sketch/detailed, client-side for crosshatch/architectural
            if (style === 'sketch' || style === 'detailed') {
                try {
                    resultImg = await generateViaAPI(file, style, detail, lineWeight, showGrid);
                } catch (e) {
                    console.log('API failed, falling back to client-side');
                    resultImg = await generateClientSide(file, style, detail, lineWeight, showGrid);
                }
            } else {
                resultImg = await generateClientSide(file, style, detail, lineWeight, showGrid);
            }
            
            displayResult(resultImg);
        } catch (error) {
            statusDiv.textContent = 'Error: ' + error.message;
            statusDiv.style.color = '#f44336';
            console.error(error);
        }
        
        generateBtn.disabled = false;
    });
    
    async function generateViaAPI(file, style, detail, lineWeight, showGrid) {
        const formData = new FormData();
        formData.append('image', file);
        formData.append('style', style);
        formData.append('detail', detail);
        formData.append('line_weight', lineWeight);
        formData.append('show_grid', showGrid);
        
        const response = await fetch(`${API_BASE}/line-drawing`, { method: 'POST', body: formData });
        if (!response.ok) throw new Error('API failed');
        
        const data = await response.json();
        return new Promise((resolve, reject) => {
            const img = new Image();
            img.onload = () => resolve(img);
            img.onerror = reject;
            img.src = 'data:image/png;base64,' + data.image_base64;
        });
    }
    
    async function generateClientSide(file, style, detail, lineWeight, showGrid) {
        return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = (e) => {
                const img = new Image();
                img.onload = () => {
                    // Process synchronously to avoid blank canvas
                    try {
                        const result = processImage(img, style, detail, lineWeight, showGrid);
                        resolve(result);
                    } catch (err) { reject(err); }
                };
                img.onerror = reject;
                img.src = e.target.result;
            };
            reader.onerror = reject;
            reader.readAsDataURL(file);
        });
    }
    
    function displayResult(img) {
        const w = img.naturalWidth || img.width;
        const h = img.naturalHeight || img.height;
        
        // Store full size
        const fullCanvas = document.createElement('canvas');
        fullCanvas.width = w;
        fullCanvas.height = h;
        fullCanvas.getContext('2d').drawImage(img, 0, 0);
        lineDrawingFullSize = fullCanvas;
        
        // Display scaled
        let dw = w, dh = h;
        if (w > MAX_CANVAS_WIDTH || h > MAX_CANVAS_HEIGHT) {
            const ratio = Math.min(MAX_CANVAS_WIDTH / w, MAX_CANVAS_HEIGHT / h);
            dw = Math.floor(w * ratio);
            dh = Math.floor(h * ratio);
        }
        
        mainCanvas.width = dw;
        mainCanvas.height = dh;
        mainCanvas.getContext('2d').drawImage(img, 0, 0, dw, dh);
        
        downloadBtn.style.display = 'block';
        statusDiv.textContent = `Line drawing generated (${w}x${h})`;
        statusDiv.style.color = '#4CAF50';
    }
    
    downloadBtn.addEventListener('click', () => {
        if (!lineDrawingFullSize) return;
        const link = document.createElement('a');
        link.download = 'line-drawing-' + Date.now() + '.png';
        link.href = lineDrawingFullSize.toDataURL('image/png');
        link.click();
    });
    
    // ==================== CLIENT-SIDE PROCESSING ====================
    
    function processImage(img, style, detail, lineWeight, showGrid) {
        const w = img.naturalWidth || img.width;
        const h = img.naturalHeight || img.height;
        
        const srcCanvas = document.createElement('canvas');
        srcCanvas.width = w;
        srcCanvas.height = h;
        const srcCtx = srcCanvas.getContext('2d');
        srcCtx.drawImage(img, 0, 0);
        
        const imageData = srcCtx.getImageData(0, 0, w, h);
        const gray = toGrayscale(imageData);
        
        let result;
        switch (style) {
            case 'sketch': result = pencilSketch(gray, w, h, detail, lineWeight); break;
            case 'crosshatch': result = crosshatchFast(gray, w, h, detail, lineWeight); break;
            case 'architectural': result = architecturalFast(gray, w, h, detail, lineWeight); break;
            default: result = detailedSketch(gray, w, h, detail, lineWeight);
        }
        
        if (showGrid) addGridLines(result, w, h);
        
        // Convert to canvas image - SYNCHRONOUS to avoid blank canvas
        const outCanvas = document.createElement('canvas');
        outCanvas.width = w;
        outCanvas.height = h;
        const outCtx = outCanvas.getContext('2d');
        const outData = outCtx.createImageData(w, h);
        
        for (let i = 0; i < result.length; i++) {
            const v = result[i] | 0;
            outData.data[i * 4] = v;
            outData.data[i * 4 + 1] = v;
            outData.data[i * 4 + 2] = v;
            outData.data[i * 4 + 3] = 255;
        }
        outCtx.putImageData(outData, 0, 0);
        
        // Create image synchronously using canvas directly
        const resultImg = new Image();
        resultImg.width = w;
        resultImg.height = h;
        resultImg.src = outCanvas.toDataURL('image/png');
        
        // Return the canvas as an image-like object that works immediately
        return {
            width: w,
            height: h,
            naturalWidth: w,
            naturalHeight: h,
            _canvas: outCanvas,
            // Make it drawable
            get src() { return outCanvas.toDataURL(); }
        };
    }
    
    // Override displayResult to handle our canvas-backed image
    const originalDisplayResult = displayResult;
    displayResult = function(img) {
        if (img._canvas) {
            // It's our canvas-backed object
            const w = img.width;
            const h = img.height;
            
            lineDrawingFullSize = img._canvas;
            
            let dw = w, dh = h;
            if (w > MAX_CANVAS_WIDTH || h > MAX_CANVAS_HEIGHT) {
                const ratio = Math.min(MAX_CANVAS_WIDTH / w, MAX_CANVAS_HEIGHT / h);
                dw = Math.floor(w * ratio);
                dh = Math.floor(h * ratio);
            }
            
            mainCanvas.width = dw;
            mainCanvas.height = dh;
            mainCanvas.getContext('2d').drawImage(img._canvas, 0, 0, dw, dh);
            
            downloadBtn.style.display = 'block';
            statusDiv.textContent = `Line drawing generated (${w}x${h})`;
            statusDiv.style.color = '#4CAF50';
        } else {
            originalDisplayResult(img);
        }
    };
    
    function toGrayscale(imageData) {
        const d = imageData.data, len = imageData.width * imageData.height;
        const gray = new Uint8Array(len);
        for (let i = 0; i < len; i++) {
            gray[i] = (d[i*4] * 77 + d[i*4+1] * 150 + d[i*4+2] * 29) >> 8;
        }
        return gray;
    }
    
    function pencilSketch(gray, w, h, detail, lineWeight) {
        const len = w * h;
        const inverted = new Uint8Array(len);
        for (let i = 0; i < len; i++) inverted[i] = 255 - gray[i];
        
        const blurRadius = Math.max(1, ((110 - detail) / 10) | 0);
        const blurred = boxBlurFast(inverted, w, h, blurRadius);
        
        const result = new Uint8Array(len);
        for (let i = 0; i < len; i++) {
            const b = blurred[i];
            result[i] = b >= 255 ? 255 : Math.min(255, (gray[i] << 8) / (256 - b)) | 0;
        }
        
        const edges = sobelFast(gray, w, h);
        for (let i = 0; i < len; i++) {
            result[i] = Math.max(0, result[i] - (edges[i] >> 2)) | 0;
        }
        
        return result;
    }
    
    function detailedSketch(gray, w, h, detail, lineWeight) {
        const len = w * h;
        const enhanced = localContrastFast(gray, w, h);
        const edges1 = sobelFast(enhanced, w, h);
        const edges2 = laplacianFast(enhanced, w, h);
        
        const inverted = new Uint8Array(len);
        for (let i = 0; i < len; i++) inverted[i] = 255 - gray[i];
        
        const blurRadius = Math.max(1, ((100 - detail) / 15) | 0);
        const blurred = boxBlurFast(inverted, w, h, blurRadius);
        
        const shade = new Uint8Array(len);
        for (let i = 0; i < len; i++) {
            const b = blurred[i];
            shade[i] = b >= 255 ? 255 : Math.min(255, (gray[i] << 8) / (256 - b)) | 0;
        }
        
        const result = new Uint8Array(len);
        const ef = detail / 80;
        for (let i = 0; i < len; i++) {
            const edgeVal = Math.min((edges1[i] + (edges2[i] >> 1)) * ef, 200) | 0;
            result[i] = Math.max(0, shade[i] - edgeVal) | 0;
        }
        
        if (lineWeight > 1) {
            const inv = new Uint8Array(len);
            for (let i = 0; i < len; i++) inv[i] = 255 - result[i];
            const dil = dilateFast(inv, w, h, lineWeight - 1);
            for (let i = 0; i < len; i++) result[i] = 255 - dil[i];
        }
        
        return result;
    }
    
    function crosshatchFast(gray, w, h, detail, lineWeight) {
        const len = w * h;
        const edges = sobelFast(gray, w, h);
        const result = new Uint8Array(len);
        result.fill(255);
        
        const spacing = Math.max(2, 6 - (detail / 25) | 0);
        const sp2 = Math.max(1, spacing >> 1);
        
        for (let y = 0; y < h; y++) {
            const yOff = y * w;
            for (let x = 0; x < w; x++) {
                const i = yOff + x;
                const lum = gray[i];
                let val = 255;
                
                if (lum < 200 && (x + y) % spacing === 0) val = 180;
                if (lum < 150 && Math.abs(x - y) % spacing === 0) val = Math.min(val, 140);
                if (lum < 100 && (x + y) % sp2 === 0) val = Math.min(val, 100);
                if (lum < 50) val = Math.min(val, 60);
                
                if (edges[i] > 50) val = Math.min(val, 255 - Math.min(edges[i], 200));
                
                result[i] = val;
            }
        }
        
        return result;
    }
    
    function architecturalFast(gray, w, h, detail, lineWeight) {
        const len = w * h;
        const blurred = boxBlurFast(gray, w, h, 2);
        const edges = sobelFast(blurred, w, h);
        
        const blockSize = Math.max(11, 31 - (detail / 4) | 0) | 1;
        const adaptive = adaptiveThresholdFast(blurred, w, h, blockSize, 3);
        
        const result = new Uint8Array(len);
        for (let i = 0; i < len; i++) {
            const edgeVal = edges[i] > 40 ? 0 : 255;
            result[i] = Math.min(adaptive[i], edgeVal);
        }
        
        if (lineWeight > 1) {
            const inv = new Uint8Array(len);
            for (let i = 0; i < len; i++) inv[i] = 255 - result[i];
            const dil = dilateFast(inv, w, h, lineWeight);
            for (let i = 0; i < len; i++) result[i] = 255 - dil[i];
        }
        
        return result;
    }
    
    function boxBlurFast(src, w, h, r) {
        if (r < 1) return src.slice();
        let result = src;
        for (let pass = 0; pass < 2; pass++) {
            result = boxBlurH(result, w, h, r);
            result = boxBlurV(result, w, h, r);
        }
        return result;
    }
    
    function boxBlurH(src, w, h, r) {
        const dst = new Uint8Array(w * h);
        const iarr = 1 / (r + r + 1);
        for (let y = 0; y < h; y++) {
            let ti = y * w, li = ti, ri = ti + r;
            const fv = src[ti], lv = src[ti + w - 1];
            let val = (r + 1) * fv;
            for (let j = 0; j < r; j++) val += src[ti + j];
            for (let j = 0; j <= r; j++) { val += src[ri++] - fv; dst[ti++] = (val * iarr + 0.5) | 0; }
            for (let j = r + 1; j < w - r; j++) { val += src[ri++] - src[li++]; dst[ti++] = (val * iarr + 0.5) | 0; }
            for (let j = w - r; j < w; j++) { val += lv - src[li++]; dst[ti++] = (val * iarr + 0.5) | 0; }
        }
        return dst;
    }
    
    function boxBlurV(src, w, h, r) {
        const dst = new Uint8Array(w * h);
        const iarr = 1 / (r + r + 1);
        for (let x = 0; x < w; x++) {
            let ti = x, li = ti, ri = ti + r * w;
            const fv = src[ti], lv = src[ti + w * (h - 1)];
            let val = (r + 1) * fv;
            for (let j = 0; j < r; j++) val += src[ti + j * w];
            for (let j = 0; j <= r; j++) { val += src[ri] - fv; dst[ti] = (val * iarr + 0.5) | 0; ri += w; ti += w; }
            for (let j = r + 1; j < h - r; j++) { val += src[ri] - src[li]; dst[ti] = (val * iarr + 0.5) | 0; li += w; ri += w; ti += w; }
            for (let j = h - r; j < h; j++) { val += lv - src[li]; dst[ti] = (val * iarr + 0.5) | 0; li += w; ti += w; }
        }
        return dst;
    }
    
    function sobelFast(g, w, h) {
        const r = new Uint8Array(w * h);
        for (let y = 1; y < h - 1; y++) {
            for (let x = 1; x < w - 1; x++) {
                const i = y * w + x;
                const gx = -g[i-w-1] + g[i-w+1] - 2*g[i-1] + 2*g[i+1] - g[i+w-1] + g[i+w+1];
                const gy = -g[i-w-1] - 2*g[i-w] - g[i-w+1] + g[i+w-1] + 2*g[i+w] + g[i+w+1];
                r[i] = Math.min(255, Math.sqrt(gx*gx + gy*gy) | 0);
            }
        }
        return r;
    }
    
    function laplacianFast(g, w, h) {
        const r = new Uint8Array(w * h);
        for (let y = 1; y < h - 1; y++) {
            for (let x = 1; x < w - 1; x++) {
                const i = y * w + x;
                const v = Math.abs(-g[i-w] - g[i-1] + 4*g[i] - g[i+1] - g[i+w]);
                r[i] = Math.min(255, v);
            }
        }
        return r;
    }
    
    function localContrastFast(g, w, h) {
        const r = new Uint8Array(w * h);
        const blurL = boxBlurFast(g, w, h, 8);
        for (let i = 0; i < g.length; i++) {
            const diff = g[i] - blurL[i] + 128;
            r[i] = Math.max(0, Math.min(255, diff));
        }
        return r;
    }
    
    function adaptiveThresholdFast(g, w, h, blockSize, c) {
        const r = new Uint8Array(w * h);
        const radius = blockSize >> 1;
        const blurred = boxBlurFast(g, w, h, radius);
        for (let i = 0; i < g.length; i++) {
            r[i] = g[i] > blurred[i] - c ? 255 : 0;
        }
        return r;
    }
    
    function dilateFast(e, w, h, iter) {
        let cur = e;
        for (let it = 0; it < iter; it++) {
            const r = new Uint8Array(w * h);
            for (let y = 1; y < h - 1; y++) {
                for (let x = 1; x < w - 1; x++) {
                    const i = y * w + x;
                    r[i] = Math.max(cur[i-w-1], cur[i-w], cur[i-w+1], cur[i-1], cur[i], cur[i+1], cur[i+w-1], cur[i+w], cur[i+w+1]);
                }
            }
            cur = r;
        }
        return cur;
    }
    
    function addGridLines(r, w, h) {
        const gridSize = Math.max(50, (Math.min(w, h) / 8) | 0);
        for (let x = gridSize; x < w; x += gridSize) {
            for (let y = 0; y < h; y++) r[y * w + x] = Math.min(r[y * w + x], 200);
        }
        for (let y = gridSize; y < h; y += gridSize) {
            for (let x = 0; x < w; x++) r[y * w + x] = Math.min(r[y * w + x], 200);
        }
    }
    
})();
</script>

</body>
</html>