<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Art-AI Renderer - Selective Resolution</title>

<style>
body { font-family: Arial, sans-serif; max-width: 900px; margin: 20px auto; padding: 0 20px; }
.section { margin: 20px 0; }
h3 { margin: 10px 0; font-size: 16px; }
input[type="file"] { margin: 10px 0; }
.radio-group label { display: block; margin: 5px 0; }
button { padding: 8px 16px; margin: 5px; cursor: pointer; }
button.active { background: #4CAF50; color: white; }
.slider-container { margin: 15px 0; }
#slider, #colorGroupSlider { width: 100%; }
canvas { border: 2px solid #ccc; margin-top: 10px; display: block; cursor: crosshair; }
canvas.drawing { cursor: crosshair; }
.info { color: #666; font-size: 14px; }
.modal { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 1000; }
.modal-content { background: white; margin: 10% auto; padding: 20px; width: 500px; border-radius: 8px; max-height: 80vh; overflow-y: auto; }
.modal-content h3 { margin-top: 0; }
.modal-content textarea { width: 100%; height: 150px; font-family: monospace; font-size: 12px; }
.modal-buttons { margin-top: 10px; text-align: right; }
.color-palette { display: flex; flex-wrap: wrap; gap: 8px; margin: 15px 0; }
.color-chip { width: 80px; height: 80px; border-radius: 4px; cursor: move; border: 2px solid #333; display: flex; flex-direction: column; align-items: center; justify-content: center; font-size: 9px; color: white; text-shadow: 1px 1px 2px black; position: relative; box-shadow: 0 2px 4px rgba(0,0,0,0.2); }
.color-chip.dragging { opacity: 0.5; }
.color-chip:hover { border-color: #000; transform: scale(1.05); box-shadow: 0 4px 8px rgba(0,0,0,0.3); }
.color-chip .count { font-size: 8px; font-weight: bold; margin-top: 2px; background: rgba(0,0,0,0.7); padding: 2px 4px; border-radius: 3px; }
.color-chip .chip-number { background: rgba(0,0,0,0.7); padding: 2px 4px; border-radius: 3px; font-size: 9px; }
.color-chip .rgb-value { font-size: 7px; background: rgba(0,0,0,0.7); padding: 2px 3px; border-radius: 2px; margin-top: 2px; font-family: monospace; }
.frequency-info { margin: 10px 0; padding: 10px; background: #f5f5f5; border-radius: 4px; font-size: 13px; }
.region-box { position: absolute; border: 3px solid #FF5722; background: rgba(255, 87, 34, 0.2); pointer-events: none; }
.region-list { margin: 10px 0; padding: 10px; background: #f0f0f0; border-radius: 4px; }
.region-item { display: flex; justify-content: space-between; align-items: center; padding: 5px; margin: 3px 0; background: white; border-radius: 3px; }
.region-item button { padding: 4px 8px; font-size: 12px; }
.highlight { background: #fff3cd; padding: 5px; border-radius: 3px; }
/* Color Picker Styles */
.color-picker-panel { 
    margin: 15px 0; 
    padding: 15px; 
    background: #f8f9fa; 
    border-radius: 8px; 
    border: 2px solid #dee2e6;
    display: none;
}
.color-picker-panel.active { display: block; }
.color-picker-header { 
    display: flex; 
    justify-content: space-between; 
    align-items: center; 
    margin-bottom: 10px;
}
.color-picker-header h4 { margin: 0; font-size: 14px; }
.color-preview-box {
    width: 60px;
    height: 60px;
    border: 3px solid #333;
    border-radius: 8px;
    box-shadow: 0 2px 8px rgba(0,0,0,0.2);
}
.color-details {
    display: grid;
    grid-template-columns: repeat(2, 1fr);
    gap: 8px;
    margin-top: 10px;
}
.color-detail-item {
    background: white;
    padding: 8px 12px;
    border-radius: 4px;
    font-size: 13px;
    border: 1px solid #e0e0e0;
}
.color-detail-item label {
    font-weight: bold;
    color: #666;
    font-size: 11px;
    display: block;
    margin-bottom: 2px;
}
.color-detail-item span {
    font-family: monospace;
    font-size: 14px;
}
.shape-highlight {
    pointer-events: none;
}
canvas.picking { cursor: crosshair; }
#colorPickerBtn.active { background: #00BCD4; color: white; }

/* Color Matcher Styles */
.color-matcher-section {
    margin-top: 15px;
    padding-top: 15px;
    border-top: 1px dashed #dee2e6;
}
.color-matcher-section h5 {
    margin: 0 0 10px 0;
    font-size: 13px;
    color: #495057;
}
.color-matcher-input {
    width: 100%;
    height: 80px;
    font-family: monospace;
    font-size: 11px;
    padding: 8px;
    border: 1px solid #ced4da;
    border-radius: 4px;
    resize: vertical;
    margin-bottom: 8px;
}
.color-matcher-input:focus {
    outline: none;
    border-color: #00BCD4;
    box-shadow: 0 0 0 2px rgba(0, 188, 212, 0.15);
}
#matchColorsBtn {
    background: #673AB7;
    color: white;
    border: none;
    padding: 8px 16px;
    border-radius: 4px;
    cursor: pointer;
    font-size: 13px;
    width: 100%;
}
#matchColorsBtn:hover { background: #5E35B1; }
#matchColorsBtn:disabled { background: #ccc; cursor: not-allowed; }

.match-results {
    margin-top: 12px;
    max-height: 250px;
    overflow-y: auto;
}
.match-results-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 8px;
    font-size: 12px;
    color: #666;
}
.match-result-item {
    display: flex;
    align-items: center;
    gap: 10px;
    padding: 8px;
    background: white;
    border: 1px solid #e0e0e0;
    border-radius: 4px;
    margin-bottom: 6px;
    transition: border-color 0.2s;
}
.match-result-item:hover {
    border-color: #00BCD4;
}
.match-result-item.best-match {
    border: 2px solid #4CAF50;
    background: linear-gradient(135deg, rgba(76, 175, 80, 0.08) 0%, rgba(76, 175, 80, 0.02) 100%);
}
.match-color-swatch {
    width: 36px;
    height: 36px;
    border-radius: 4px;
    border: 1px solid #333;
    flex-shrink: 0;
}
.match-info {
    flex: 1;
    min-width: 0;
}
.match-hex {
    font-family: monospace;
    font-size: 12px;
    font-weight: 600;
}
.match-delta {
    font-size: 10px;
    color: #888;
}
.match-percentage {
    text-align: right;
}
.match-percentage-value {
    font-size: 18px;
    font-weight: bold;
}
.match-percentage-value.high { color: #4CAF50; }
.match-percentage-value.medium { color: #FF9800; }
.match-percentage-value.low { color: #f44336; }
.match-percentage-label {
    font-size: 9px;
    color: #888;
    text-transform: uppercase;
}
.best-badge {
    display: inline-block;
    background: #4CAF50;
    color: white;
    font-size: 9px;
    font-weight: bold;
    padding: 2px 6px;
    border-radius: 3px;
    margin-left: 6px;
    text-transform: uppercase;
}
.match-progress-bar {
    width: 100%;
    height: 4px;
    background: #e0e0e0;
    border-radius: 2px;
    margin-top: 4px;
    overflow: hidden;
}
.match-progress-fill {
    height: 100%;
    border-radius: 2px;
    transition: width 0.3s ease;
}
.match-progress-fill.high { background: #4CAF50; }
.match-progress-fill.medium { background: #FF9800; }
.match-progress-fill.low { background: #f44336; }
.match-error {
    background: #ffebee;
    border: 1px solid #ffcdd2;
    color: #c62828;
    padding: 10px;
    border-radius: 4px;
    font-size: 12px;
    text-align: center;
}
.match-empty {
    text-align: center;
    padding: 20px;
    color: #888;
    font-size: 12px;
}
.threshold-control {
    display: flex;
    align-items: center;
    gap: 8px;
    margin-bottom: 8px;
    font-size: 11px;
    color: #666;
}
.threshold-control input[type="range"] {
    flex: 1;
    height: 4px;
}
.threshold-control span {
    min-width: 35px;
    text-align: right;
    font-family: monospace;
}
/* Palette Preset Styles */
.palette-preset-section {
    margin: 15px 0;
    padding: 15px;
    background: #f8f9fa;
    border-radius: 8px;
    border: 2px solid #dee2e6;
}
.palette-preset-section h4 {
    margin: 0 0 10px 0;
    font-size: 14px;
    color: #495057;
}
.palette-preset-controls {
    display: flex;
    gap: 10px;
    align-items: center;
}
.palette-preset-controls select {
    flex: 1;
    padding: 8px 12px;
    border: 1px solid #ced4da;
    border-radius: 4px;
    font-size: 13px;
    background: white;
    cursor: pointer;
}
.palette-preset-controls select:focus {
    outline: none;
    border-color: #673AB7;
    box-shadow: 0 0 0 2px rgba(103, 58, 183, 0.15);
}
.palette-preset-controls button {
    background: #673AB7;
    color: white;
    border: none;
    padding: 8px 16px;
    border-radius: 4px;
    cursor: pointer;
    font-size: 13px;
}
.palette-preset-controls button:hover {
    background: #5E35B1;
}
.palette-preset-controls button:disabled {
    background: #ccc;
    cursor: not-allowed;
}

/* Unmix / Recipe Styles */
.unmix-section {
    margin-top: 15px;
    padding-top: 15px;
    border-top: 2px solid #4CAF50;
    background: linear-gradient(135deg, rgba(76, 175, 80, 0.05) 0%, rgba(76, 175, 80, 0.02) 100%);
    padding: 15px;
    border-radius: 0 0 8px 8px;
    margin: 0 -15px -15px -15px;
}
.unmix-section h5 {
    margin: 0 0 12px 0;
    font-size: 14px;
    color: #2E7D32;
    display: flex;
    align-items: center;
    gap: 8px;
}
.unmix-section h5::before {
    content: "üé®";
}
.unmix-controls {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 10px;
    margin-bottom: 12px;
}
.unmix-control-item {
    display: flex;
    flex-direction: column;
    gap: 4px;
}
.unmix-control-item label {
    font-size: 11px;
    color: #666;
    font-weight: 600;
}
.unmix-control-item input[type="number"] {
    padding: 6px 10px;
    border: 1px solid #ced4da;
    border-radius: 4px;
    font-size: 13px;
    width: 100%;
    box-sizing: border-box;
}
.unmix-control-item input[type="number"]:focus {
    outline: none;
    border-color: #4CAF50;
    box-shadow: 0 0 0 2px rgba(76, 175, 80, 0.15);
}
#getRecipeBtn {
    background: #4CAF50;
    color: white;
    border: none;
    padding: 10px 16px;
    border-radius: 4px;
    cursor: pointer;
    font-size: 13px;
    font-weight: 600;
    width: 100%;
    transition: background 0.2s;
}
#getRecipeBtn:hover { background: #43A047; }
#getRecipeBtn:disabled { background: #ccc; cursor: not-allowed; }

.recipe-results {
    margin-top: 12px;
}
.recipe-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 10px;
    padding-bottom: 8px;
    border-bottom: 1px solid #e0e0e0;
}
.recipe-header-left {
    display: flex;
    align-items: center;
    gap: 10px;
}
.recipe-target-swatch {
    width: 40px;
    height: 40px;
    border-radius: 4px;
    border: 2px solid #333;
}
.recipe-result-swatch {
    width: 40px;
    height: 40px;
    border-radius: 4px;
    border: 2px solid #333;
}
.recipe-arrow {
    font-size: 20px;
    color: #666;
}
.recipe-match-info {
    text-align: right;
}
.recipe-match-value {
    font-size: 24px;
    font-weight: bold;
}
.recipe-match-value.high { color: #4CAF50; }
.recipe-match-value.medium { color: #FF9800; }
.recipe-match-value.low { color: #f44336; }
.recipe-match-label {
    font-size: 10px;
    color: #888;
}
.recipe-method {
    font-size: 10px;
    color: #666;
    background: #f0f0f0;
    padding: 2px 6px;
    border-radius: 3px;
    margin-top: 2px;
}
.recipe-components {
    display: flex;
    flex-direction: column;
    gap: 8px;
}
.recipe-component {
    display: flex;
    align-items: center;
    gap: 10px;
    padding: 10px;
    background: white;
    border: 1px solid #e0e0e0;
    border-radius: 6px;
    transition: border-color 0.2s;
}
.recipe-component:hover {
    border-color: #4CAF50;
}
.recipe-component-swatch {
    width: 44px;
    height: 44px;
    border-radius: 4px;
    border: 2px solid #333;
    flex-shrink: 0;
}
.recipe-component-info {
    flex: 1;
    min-width: 0;
}
.recipe-component-name {
    font-weight: 600;
    font-size: 13px;
    color: #333;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}
.recipe-component-hex {
    font-family: monospace;
    font-size: 11px;
    color: #666;
}
.recipe-component-amount {
    text-align: right;
    flex-shrink: 0;
}
.recipe-component-parts {
    font-size: 20px;
    font-weight: bold;
    color: #333;
}
.recipe-component-parts-label {
    font-size: 10px;
    color: #888;
}
.recipe-component-percent {
    font-size: 12px;
    color: #4CAF50;
    font-weight: 600;
}
.recipe-total {
    margin-top: 10px;
    padding-top: 10px;
    border-top: 1px dashed #ccc;
    font-size: 12px;
    color: #666;
    text-align: center;
}
.recipe-empty {
    text-align: center;
    padding: 20px;
    color: #888;
    font-size: 12px;
}
.recipe-error {
    background: #ffebee;
    border: 1px solid #ffcdd2;
    color: #c62828;
    padding: 10px;
    border-radius: 4px;
    font-size: 12px;
    text-align: center;
}

/* Shape Checkbox Styles */
.shape-checkbox {
    display: flex;
    align-items: center;
    gap: 4px;
    font-size: 11px;
    color: #333;
    cursor: pointer;
    padding: 4px 8px;
    background: white;
    border: 1px solid #ccc;
    border-radius: 4px;
    transition: all 0.2s;
}
.shape-checkbox:hover {
    border-color: #7c4dff;
}
.shape-checkbox input:checked + span {
    color: #7c4dff;
    font-weight: 600;
}
.shape-checkbox:has(input:checked) {
    border-color: #7c4dff;
    background: #f3e5f5;
}
</style>
<script type="application/json" id="colorsData">
{
    "Common Color Names & Values": [
        [255, 127, 80], [178, 34, 34], [34, 139, 34], [255, 215, 0], [124, 252, 0],
        [128, 0, 0], [25, 25, 112], [0, 0, 128], [128, 128, 0], [107, 142, 35],
        [205, 133, 63], [139, 69, 19], [46, 139, 87]
    ],
    "Artisan - Winsor & Newton": [
        [58, 22, 14], [50, 27, 15], [221, 63, 0], [171, 0, 5], [221, 63, 0],
        [229, 42, 0], [166, 0, 9], [255, 139, 0], [255, 194, 0], [255, 161, 0],
        [0, 97, 102], [0, 74, 91], [0, 39, 71], [21, 15, 17], [8, 8, 32],
        [27, 28, 28], [21, 21, 20], [239, 173, 0], [98, 4, 32], [74, 1, 16],
        [130, 0, 24], [28, 42, 10], [17, 12, 37], [0, 32, 24], [3, 26, 33],
        [15, 11, 11], [117, 70, 17], [37, 26, 20], [0, 53, 40], [187, 128, 18]
    ],
    "Artists Oil - Winsor & Newton": [
        [68, 2, 6], [255, 232, 0], [197, 0, 15], [82, 42, 31], [255, 222, 0],
        [204, 12, 22], [255, 164, 0], [255, 127, 15], [0, 41, 117], [46, 90, 76],
        [0, 99, 127], [78, 23, 80], [50, 61, 164], [168, 113, 37], [71, 74, 14],
        [144, 87, 0], [119, 85, 26], [33, 23, 57], [16, 15, 17], [26, 27, 27],
        [235, 215, 84], [39, 38, 39], [222, 156, 72], [47, 43, 32], [57, 95, 58],
        [84, 2, 17], [71, 16, 26], [68, 50, 73], [34, 24, 24], [18, 28, 41],
        [108, 8, 36], [144, 32, 40], [130, 83, 39], [64, 49, 35], [69, 53, 53],
        [213, 33, 22], [146, 75, 63], [38, 59, 47], [149, 66, 40], [233, 162, 0],
        [70, 21, 17], [62, 38, 126], [39, 27, 19], [127, 49, 29], [0, 62, 53],
        [0, 134, 84], [0, 50, 40], [0, 60, 33], [248, 65, 0], [129, 0, 24],
        [255, 204, 0], [255, 145, 0], [29, 23, 41], [151, 104, 47]
    ],
    "Createx Airbrush Colors": [
        [164, 129, 99], [130, 107, 92], [120, 90, 76], [100, 74, 66], [133, 94, 41],
        [119, 47, 47], [108, 45, 36], [61, 52, 50], [68, 57, 57], [55, 46, 59],
        [85, 43, 36], [36, 31, 42], [91, 55, 54], [78, 56, 47], [42, 36, 49],
        [71, 62, 62], [100, 79, 68], [53, 53, 63], [63, 58, 52], [114, 98, 98]
    ],
    "Sennelier": [
        [68, 47, 38], [50, 42, 33], [125, 80, 35], [95, 40, 20], [168, 110, 40],
        [235, 166, 51], [0, 90, 136], [36, 68, 131], [15, 12, 79], [22, 17, 54],
        [35, 41, 42], [56, 55, 68], [66, 35, 26], [251, 214, 0], [255, 210, 0],
        [255, 155, 0], [251, 223, 0], [255, 131, 0], [214, 159, 0], [230, 124, 0],
        [202, 20, 19], [163, 0, 28], [178, 0, 18], [242, 76, 0], [206, 14, 7],
        [131, 7, 23], [139, 16, 26], [78, 42, 43], [59, 29, 27], [25, 25, 24],
        [22, 20, 18], [74, 112, 66], [0, 46, 37], [34, 45, 48], [8, 76, 60],
        [0, 68, 59], [57, 20, 65], [28, 25, 41], [57, 57, 55], [73, 28, 39],
        [65, 30, 69]
    ],
    "System 3 Original Acrylic - Dal": [
        [51, 49, 50], [49, 49, 49], [43, 91, 192], [51, 48, 80], [46, 46, 60],
        [49, 45, 81], [123, 62, 51], [75, 60, 55], [67, 60, 55], [46, 62, 52],
        [38, 58, 58], [81, 117, 76], [42, 75, 49], [57, 51, 53], [138, 47, 68],
        [189, 45, 44], [159, 43, 44], [210, 45, 37], [238, 139, 0], [227, 71, 37],
        [241, 222, 0], [189, 137, 62], [163, 105, 59], [254, 208, 0]
    ],
    "Vallejo Acrylic Studio": [
        [246, 226, 0], [172, 23, 28], [143, 27, 37], [42, 41, 77], [39, 33, 78],
        [22, 47, 53], [194, 134, 33], [134, 55, 45], [48, 47, 47], [223, 132, 0],
        [43, 38, 39], [220, 58, 34], [37, 52, 40], [96, 81, 62], [82, 59, 51],
        [163, 109, 40], [131, 63, 45], [255, 187, 0], [125, 16, 61], [50, 97, 192],
        [114, 29, 30], [251, 205, 0], [148, 43, 32], [40, 39, 51]
    ]
}
</script>
</head>

<body>
<h2>Art-AI Renderer - Selective Resolution</h2>

<!-- ========================== GEOMETRIZE (Client-Side) ========================= -->
<div class="section" style="background: linear-gradient(135deg, #e3f2fd 0%, #f3e5f5 100%); padding: 20px; border-radius: 8px; border: 2px solid #7c4dff;">
    <h3 style="color: #512da8; margin-top: 0;">Generate from Image</h3>
    <div class="info" style="margin-bottom: 15px;">Upload an image to convert it into geometric shapes</div>
    
    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-bottom: 15px;">
        <div>
            <label style="font-weight: bold; font-size: 12px; color: #666;">Image File:</label>
            <input type="file" id="geometrizeInput" accept="image/*" style="width: 100%; margin-top: 5px;">
        </div>
        <div>
            <label style="font-weight: bold; font-size: 12px; color: #666;">Number of Shapes:</label>
            <input type="number" id="geometrizeShapeCount" value="200" min="10" max="2000" style="width: 100%; padding: 8px; margin-top: 5px; border: 1px solid #ccc; border-radius: 4px;">
        </div>
    </div>
    
    <!-- Advanced Settings Panel -->
    <div style="background: #f0f4f8; border: 1px solid #d0d7de; border-radius: 6px; padding: 12px; margin: 12px 0;">
        <h4 style="margin: 0 0 10px 0; font-size: 13px; color: #495057;">‚öôÔ∏è Advanced Settings</h4>
        <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px;">
            <!-- Shape Types -->
            <div style="grid-column: span 2;">
                <label style="font-size: 11px; color: #666; font-weight: 600;">Shape Types (select multiple):</label>
                <div id="shapeTypeCheckboxes" style="display: flex; flex-wrap: wrap; gap: 8px; margin-top: 4px;">
                    <label class="shape-checkbox"><input type="checkbox" name="shapeType" value="0"> <span>Rectangle</span></label>
                    <label class="shape-checkbox"><input type="checkbox" name="shapeType" value="1"> <span>Rotated Rect</span></label>
                    <label class="shape-checkbox"><input type="checkbox" name="shapeType" value="2" checked> <span>Triangle</span></label>
                    <label class="shape-checkbox"><input type="checkbox" name="shapeType" value="3"> <span>Ellipse</span></label>
                    <label class="shape-checkbox"><input type="checkbox" name="shapeType" value="4"> <span>Rotated Ellipse</span></label>
                    <label class="shape-checkbox"><input type="checkbox" name="shapeType" value="5"> <span>Circle</span></label>
                    <label class="shape-checkbox"><input type="checkbox" name="shapeType" value="6"> <span>Line</span></label>
                    <label class="shape-checkbox"><input type="checkbox" name="shapeType" value="7"> <span>Bezier</span></label>
                </div>
            </div>
            <!-- Alpha -->
            <div>
                <label style="font-size: 11px; color: #666; font-weight: 600;">Alpha (Opacity): <span id="alphaDisplayValue" style="font-family: monospace;">128</span></label>
                <input type="range" id="geometrizeAlpha" min="1" max="255" value="128" style="width: 100%;">
            </div>
            <!-- Candidates Per Step -->
            <div>
                <label style="font-size: 11px; color: #666; font-weight: 600;">Candidates Per Step: <span id="candidatesValue" style="font-family: monospace;">50</span></label>
                <input type="range" id="geometrizeCandidates" min="10" max="500" value="50" style="width: 100%;">
            </div>
            <!-- Mutations Per Step -->
            <div>
                <label style="font-size: 11px; color: #666; font-weight: 600;">Mutations Per Step: <span id="mutationsValue" style="font-family: monospace;">100</span></label>
                <input type="range" id="geometrizeMutations" min="10" max="500" value="100" style="width: 100%;">
            </div>
            <!-- Load Result As -->
            <div>
                <label style="font-size: 11px; color: #666; font-weight: 600;">Load Result As:</label>
                <div style="display: flex; gap: 15px; margin-top: 4px;">
                    <label style="display: flex; align-items: center; gap: 6px; cursor: pointer; font-size: 12px;">
                        <input type="radio" name="geometrizeTarget" value="base" checked>
                        <span>Base (Low-res)</span>
                    </label>
                    <label style="display: flex; align-items: center; gap: 6px; cursor: pointer; font-size: 12px;">
                        <input type="radio" name="geometrizeTarget" value="detail">
                        <span>Detail (High-res)</span>
                    </label>
                </div>
            </div>
        </div>
    </div>
    
    <button id="geometrizeBtn" style="background: #7c4dff; color: white; padding: 12px 24px; border: none; border-radius: 4px; cursor: pointer; font-size: 14px; font-weight: bold; width: 100%;">
        Generate Shapes
    </button>
    <button id="stopGeometrizeBtn" style="background: #f44336; color: white; padding: 10px 20px; border: none; border-radius: 4px; cursor: pointer; font-size: 13px; margin-top: 10px; width: 100%; display: none;">
        Stop Processing
    </button>
    
    <!-- Progress Bar -->
    <div id="progressContainer" style="margin-top: 10px; display: none;">
        <div style="width: 100%; height: 20px; background: #e0e0e0; border-radius: 10px; overflow: hidden;">
            <div id="progressFill" style="height: 100%; background: linear-gradient(90deg, #7c4dff, #b388ff); border-radius: 10px; transition: width 0.1s ease; width: 0%;"></div>
        </div>
        <div id="progressText" style="text-align: center; font-size: 12px; color: #666; margin-top: 5px;">Processing: 0 / 0 shapes</div>
    </div>
    
    <!-- Live Preview -->
    <canvas id="geometrizePreview" width="300" height="300" style="border: 1px solid #ccc; border-radius: 4px; margin-top: 10px; max-width: 100%; display: none;"></canvas>
    
    <button id="downloadJsonBtn" style="background: #4CAF50; color: white; padding: 10px 20px; border: none; border-radius: 4px; cursor: pointer; font-size: 13px; margin-top: 10px; width: 100%;" disabled>
        Download JSON
    </button>
    <div id="geometrizeStatus" class="info" style="margin-top: 10px; text-align: center;"></div>
</div>

<!-- ========================== LOAD JSON ========================= -->
<div class="section">
    <h3>Load JSON Files</h3>

    <label>Base (Low-res):</label>
    <input type="file" id="baseFileInput" accept=".json">
    <span id="baseFileStatus" class="info"></span>
    
    <label>Detail (High-res):</label>
    <input type="file" id="detailFileInput" accept=".json">
    <span id="detailFileStatus" class="info"></span>
</div>

<!-- ====================== SELECTIVE RESOLUTION =================== -->
<div class="section highlight">
    <h3>Selective Resolution Tool</h3>
    <div class="info">Draw rectangles on the canvas to enhance specific regions with high-resolution shapes.</div>

    <button id="selectRegionsBtn">Select Regions for Detail</button>
    <button id="clearRegionsBtn">Clear All Regions</button>
    <button id="applySelectiveBtn">Apply Selective Resolution</button>

    <div class="region-list" id="regionList" style="display:none;"></div>
</div>

<!-- ====================== RENDERING LOGIC ======================== -->
<div class="section">
    <h3>Rendering Logic</h3>

    <div class="radio-group">
        <label><input type="radio" name="logic" value="original" checked> Original Order</label>
        <label><input type="radio" name="logic" value="exterior_to_center"> Exterior ‚Üí Center</label>
        <label><input type="radio" name="logic" value="center_to_exterior"> Center ‚Üí Exterior</label>
        <label><input type="radio" name="logic" value="top_to_bottom"> Top ‚Üí Bottom</label>
        <label><input type="radio" name="logic" value="bottom_to_top"> Bottom ‚Üí Top</label>
        <label><input type="radio" name="logic" value="color_sequence"> Color Sequence</label>
        <label><input type="radio" name="logic" value="light_to_dark"> Light ‚Üí Dark</label>
        <label><input type="radio" name="logic" value="dark_to_light"> Dark ‚Üí Light</label>
        <label><input type="radio" name="logic" value="frequency_by_color"> Most Count ‚Üí Least Count</label>
        <label><input type="radio" name="logic" value="frequency_by_color_reverse"> Least Count ‚Üí Most Count</label>
        <label><input type="radio" name="logic" value="custom_sequence"> Custom Sequence (Drag Colors)</label>
    </div>

    <button id="editColorBtn">Edit Color Sequence</button>
    <button id="dragColorBtn">Drag & Drop Color Order</button>

    <!-- ‚≠ê NEW BAKE OPAQUE BUTTON (Option A) -->
    <button id="bakeOpaqueBtn" style="background:#2196F3; color:white; margin-top:10px;">
        Bake Opaque (Fix Order Issues)
    </button>
    <div class="info">Makes shapes order-independent</div>
</div>

<!-- ====================== COLOR PICKER ======================== -->
<div class="section">
    <h3>Color Picker</h3>
    <div class="info">Click on shapes in the canvas to inspect their color values.</div>
    <button id="colorPickerBtn">Enable Color Picker</button>
    
    <div id="colorPickerPanel" class="color-picker-panel">
        <div class="color-picker-header">
            <h4>Selected Shape</h4>
            <div id="colorPreviewBox" class="color-preview-box"></div>
        </div>
        <div class="color-details">
            <div class="color-detail-item">
                <label>Shape Type</label>
                <span id="shapeTypeValue">-</span>
            </div>
            <div class="color-detail-item">
                <label>Shape Index</label>
                <span id="shapeIndexValue">-</span>
            </div>
            <div class="color-detail-item">
                <label>RGB</label>
                <span id="rgbValue">-</span>
            </div>
            <div class="color-detail-item">
                <label>RGBA</label>
                <span id="rgbaValue">-</span>
            </div>
            <div class="color-detail-item">
                <label>HEX</label>
                <span id="hexValue">-</span>
            </div>
            <div class="color-detail-item">
                <label>Alpha</label>
                <span id="alphaValue">-</span>
            </div>
        </div>
        <div class="color-details" style="margin-top: 8px;">
            <div class="color-detail-item">
                <label>Position (center)</label>
                <span id="positionValue">-</span>
            </div>
            <div class="color-detail-item">
                <label>Score</label>
                <span id="scoreValue">-</span>
            </div>
        </div>
        
        <!-- Palette Preset Section -->
        <div class="palette-preset-section">
            <h4>Load Palette Preset</h4>
            <div class="palette-preset-controls">
                <select id="palettePresetSelect">
                    <option value="">-- Select a palette --</option>
                </select>
                <button id="loadPaletteBtn" disabled>Load</button>
            </div>
        </div>
        
        <!-- Color Matcher Section -->
        <div class="color-matcher-section">
            <h5>Match Against Palette</h5>
            <textarea id="colorMatcherInput" class="color-matcher-input" placeholder="Enter hex colors to compare against (one per line or comma-separated):
#FF5733
#3498DB
#2ECC71"></textarea>

            <div id="matchResults" class="match-results">
                <div class="match-empty">Select a shape and enter palette colors to compare</div>
            </div>
        </div>
        
        <!-- Unmix / Get Recipe Section -->
        <div class="unmix-section">
            <h5>Get Mix Recipe (Unmix)</h5>
            <p style="font-size: 11px; color: #666; margin: 0 0 12px 0;">
                Find which paints to mix (and in what proportions) to recreate the selected color.
            </p>
            <div class="unmix-controls">
                <div class="unmix-control-item">
                    <label>Max Colors in Recipe</label>
                    <input type="number" id="maxColorsInput" value="3" min="1" max="5">
                </div>
                <div class="unmix-control-item">
                    <label>Max Parts (Precision)</label>
                    <input type="number" id="maxPartsInput" value="10" min="2" max="20">
                </div>
            </div>
            <button id="getRecipeBtn" disabled>Get Mix Recipe</button>
            <div id="recipeResults" class="recipe-results">
                <div class="recipe-empty">Select a shape and load a palette to get a mixing recipe</div>
            </div>
        </div>
    </div>
</div>

<!-- ========================= SLIDERS ============================= -->
<div class="section slider-container">
    <h3>Progressive Render</h3>
    <div class="info" id="sliderLabel">Shapes: 0 / 0</div>
    <input type="range" id="slider" min="0" max="0" value="0">
</div>

<div class="section slider-container">
    <h3>Color Grouping (Compress Similar Colors)</h3>
    <div class="info" id="colorGroupLabel">Tolerance: 0 (Unique colors: 0)</div>
    <input type="range" id="colorGroupSlider" min="0" max="100" value="0">
</div>

<!-- ========================== CANVAS ============================= -->
<div style="position: relative;">
    <canvas id="canvas" width="600" height="600"></canvas>
    <div id="regionOverlay" style="position:absolute; top:0; left:0; pointer-events:none;"></div>
</div>

<!-- ========== MODALS (COLOR SEQUENCE + DRAG) ‚Äî UNCHANGED ========= -->
<div id="colorModal" class="modal">
    <div class="modal-content">
        <h3>Edit Color Sequence</h3>
        <textarea id="colorInput"></textarea>
        <div class="modal-buttons">
            <button id="cancelColorBtn">Cancel</button>
            <button id="saveColorBtn">Save</button>
        </div>
    </div>
</div>

<div id="dragModal" class="modal">
    <div class="modal-content">
        <h3>Drag & Drop Color Order</h3>
        <div id="frequencyInfo" class="frequency-info"></div>
        <div id="colorPalette" class="color-palette"></div>
        <div class="modal-buttons">
            <button id="cancelDragBtn">Cancel</button>
            <button id="saveDragBtn">Save Order</button>
        </div>
    </div>
</div>

<script>
const API_BASE = "http://127.0.0.1:8000";
//const API_BASE = "https://slider-options-img-production.up.railway.app";

let baseShapes = [];
let detailShapes = [];
let currentShapes = [];
let groupedShapes = [];
let regions = [];
let customColorOrder = null;
let colorOrder = null;
let colorTolerance = 0;

const baseFileInput = document.getElementById("baseFileInput");
const detailFileInput = document.getElementById("detailFileInput");
const baseFileStatus = document.getElementById("baseFileStatus");
const detailFileStatus = document.getElementById("detailFileStatus");

const selectRegionsBtn = document.getElementById("selectRegionsBtn");
const clearRegionsBtn = document.getElementById("clearRegionsBtn");
const applySelectiveBtn = document.getElementById("applySelectiveBtn");
const regionList = document.getElementById("regionList");
const regionOverlay = document.getElementById("regionOverlay");

const slider = document.getElementById("slider");
const sliderLabel = document.getElementById("sliderLabel");
const colorGroupSlider = document.getElementById("colorGroupSlider");
const colorGroupLabel = document.getElementById("colorGroupLabel");

const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");

const logicRadios = document.querySelectorAll("input[name='logic']");
const editColorBtn = document.getElementById("editColorBtn");
const dragColorBtn = document.getElementById("dragColorBtn");

const bakeOpaqueBtn = document.getElementById("bakeOpaqueBtn");

const colorPickerBtn = document.getElementById("colorPickerBtn");
const colorPickerPanel = document.getElementById("colorPickerPanel");
const colorPreviewBox = document.getElementById("colorPreviewBox");
const shapeTypeValue = document.getElementById("shapeTypeValue");
const shapeIndexValue = document.getElementById("shapeIndexValue");
const rgbValue = document.getElementById("rgbValue");
const rgbaValue = document.getElementById("rgbaValue");
const hexValue = document.getElementById("hexValue");
const alphaValue = document.getElementById("alphaValue");
const positionValue = document.getElementById("positionValue");
const scoreValue = document.getElementById("scoreValue");

// Color Matcher elements
const colorMatcherInput = document.getElementById("colorMatcherInput");
const matchResults = document.getElementById("matchResults");

// Unmix / Recipe elements
const maxColorsInput = document.getElementById("maxColorsInput");
const maxPartsInput = document.getElementById("maxPartsInput");
const getRecipeBtn = document.getElementById("getRecipeBtn");
const recipeResults = document.getElementById("recipeResults");

let isSelecting = false;
let startX = 0, startY = 0;
let currentRegion = null;

let isPickingColor = false;
let selectedShapeIndex = null;
let currentSelectedColor = null;

// Geometrize elements (Client-Side)
const geometrizeInput = document.getElementById("geometrizeInput");
const geometrizeShapeCount = document.getElementById("geometrizeShapeCount");
const geometrizeAlpha = document.getElementById("geometrizeAlpha");
const geometrizeCandidates = document.getElementById("geometrizeCandidates");
const geometrizeMutations = document.getElementById("geometrizeMutations");
const geometrizeBtn = document.getElementById("geometrizeBtn");
const stopGeometrizeBtn = document.getElementById("stopGeometrizeBtn");
const progressContainer = document.getElementById("progressContainer");
const progressFill = document.getElementById("progressFill");
const progressText = document.getElementById("progressText");
const geometrizePreview = document.getElementById("geometrizePreview");
const geometrizeStatus = document.getElementById("geometrizeStatus");
const downloadJsonBtn = document.getElementById("downloadJsonBtn");

// Geometrize state
let geometrizeWorker = null;
let isGeometrizing = false;
let generatedShapes = [];
let previewCtx = geometrizePreview.getContext("2d");

// Update slider display values
geometrizeAlpha.addEventListener("input", () => {
    document.getElementById("alphaDisplayValue").textContent = geometrizeAlpha.value;
});
geometrizeCandidates.addEventListener("input", () => {
    document.getElementById("candidatesValue").textContent = geometrizeCandidates.value;
});
geometrizeMutations.addEventListener("input", () => {
    document.getElementById("mutationsValue").textContent = geometrizeMutations.value;
});

/* ==========================================================
   DOWNLOAD JSON
========================================================== */

downloadJsonBtn.addEventListener("click", () => {
    if (!currentShapes.length) {
        alert("No shapes to download. Generate or load shapes first.");
        return;
    }
    
    const json = JSON.stringify(currentShapes, null, 2);
    const blob = new Blob([json], { type: "application/json" });
    const url = URL.createObjectURL(blob);
    
    const a = document.createElement("a");
    a.href = url;
    a.download = "shapes.json";
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
});

/* ==========================================================
   GEOMETRIZE - Client-Side Shape Generation
========================================================== */

// Get selected shape types from checkboxes
function getSelectedShapeTypes() {
    const checkboxes = document.querySelectorAll('input[name="shapeType"]:checked');
    const types = Array.from(checkboxes).map(cb => parseInt(cb.value));
    return types.length > 0 ? types : [2]; // Default to triangle
}

// Convert image to bitmap data for worker
async function imageToBitmapData(imageFile) {
    return new Promise((resolve, reject) => {
        const img = new Image();
        img.onload = () => {
            // Resize if too large for performance
            let width = img.width;
            let height = img.height;
            const maxDim = 256;
            
            if (width > maxDim || height > maxDim) {
                const ratio = Math.min(maxDim / width, maxDim / height);
                width = Math.floor(width * ratio);
                height = Math.floor(height * ratio);
            }
            
            const canvas = document.createElement('canvas');
            canvas.width = width;
            canvas.height = height;
            const ctx = canvas.getContext('2d');
            ctx.drawImage(img, 0, 0, width, height);
            
            const imageData = ctx.getImageData(0, 0, width, height);
            const pixels = imageData.data;
            
            // Convert to format expected by geometrize (RGBA packed into 32-bit integers)
            const data = new Array(width * height);
            let rSum = 0, gSum = 0, bSum = 0;
            
            for (let i = 0; i < width * height; i++) {
                const r = pixels[i * 4];
                const g = pixels[i * 4 + 1];
                const b = pixels[i * 4 + 2];
                const a = pixels[i * 4 + 3];
                
                rSum += r;
                gSum += g;
                bSum += b;
                
                // Pack as RGBA (r in high bits)
                data[i] = ((r & 255) << 24) | ((g & 255) << 16) | ((b & 255) << 8) | (a & 255);
            }
            
            const avgR = Math.round(rSum / (width * height));
            const avgG = Math.round(gSum / (width * height));
            const avgB = Math.round(bSum / (width * height));
            
            resolve({
                width: width,
                height: height,
                data: data,
                originalWidth: img.width,
                originalHeight: img.height,
                avgColor: [avgR, avgG, avgB, 255]
            });
        };
        img.onerror = reject;
        img.src = URL.createObjectURL(imageFile);
    });
}

// Parse the JSON string returned by geometrize library and scale coordinates
function parseAndScaleShapes(jsonString, scaleX, scaleY) {
    // The library returns a JSON string like: "    {\n        \"type\":4,\n..."
    // We need to parse it as JSON array
    try {
        const fullJson = "[\n" + jsonString + "\n]";
        const shapes = JSON.parse(fullJson);
        
        return shapes.map(shape => {
            const type = shape.type;
            const data = shape.data;
            let scaledData;
            
            switch(type) {
                case 0: // Rectangle
                    scaledData = [
                        Math.round(data[0] * scaleX), Math.round(data[1] * scaleY),
                        Math.round(data[2] * scaleX), Math.round(data[3] * scaleY)
                    ];
                    break;
                case 1: // Rotated Rectangle
                    scaledData = [
                        Math.round(data[0] * scaleX), Math.round(data[1] * scaleY),
                        Math.round(data[2] * scaleX), Math.round(data[3] * scaleY),
                        data[4]
                    ];
                    break;
                case 2: // Triangle
                    scaledData = [
                        Math.round(data[0] * scaleX), Math.round(data[1] * scaleY),
                        Math.round(data[2] * scaleX), Math.round(data[3] * scaleY),
                        Math.round(data[4] * scaleX), Math.round(data[5] * scaleY)
                    ];
                    break;
                case 3: // Ellipse -> convert to type 4 format
                    scaledData = [
                        Math.round(data[0] * scaleX), Math.round(data[1] * scaleY),
                        Math.round(data[2] * scaleX), Math.round(data[3] * scaleY),
                        0
                    ];
                    return { type: 4, data: scaledData, color: shape.color, score: shape.score };
                case 4: // Rotated Ellipse
                    scaledData = [
                        Math.round(data[0] * scaleX), Math.round(data[1] * scaleY),
                        Math.round(data[2] * scaleX), Math.round(data[3] * scaleY),
                        data[4]
                    ];
                    break;
                case 5: // Circle -> convert to type 1 format
                    const avgScale = (scaleX + scaleY) / 2;
                    scaledData = [
                        Math.round(data[0] * scaleX), Math.round(data[1] * scaleY),
                        Math.round(data[2] * avgScale)
                    ];
                    return { type: 1, data: scaledData, color: shape.color, score: shape.score };
                case 6: // Line
                    scaledData = [
                        Math.round(data[0] * scaleX), Math.round(data[1] * scaleY),
                        Math.round(data[2] * scaleX), Math.round(data[3] * scaleY)
                    ];
                    break;
                case 7: // Quadratic Bezier
                    scaledData = [
                        Math.round(data[0] * scaleX), Math.round(data[1] * scaleY),
                        Math.round(data[2] * scaleX), Math.round(data[3] * scaleY),
                        Math.round(data[4] * scaleX), Math.round(data[5] * scaleY)
                    ];
                    break;
                default:
                    scaledData = data;
            }
            
            return { type: type, data: scaledData, color: shape.color, score: shape.score };
        });
    } catch (e) {
        console.error("Error parsing shapes:", e, jsonString);
        return [];
    }
}

// Stop processing
stopGeometrizeBtn.addEventListener("click", () => {
    if (geometrizeWorker) {
        geometrizeWorker.terminate();
        geometrizeWorker = null;
    }
    isGeometrizing = false;
    geometrizeBtn.disabled = false;
    stopGeometrizeBtn.style.display = "none";
    progressContainer.style.display = "none";
    geometrizeStatus.textContent = "Processing stopped.";
    geometrizeStatus.style.color = "#f44336";
});

// Main geometrize function
geometrizeBtn.addEventListener("click", async () => {
    const file = geometrizeInput.files[0];
    if (!file) {
        geometrizeStatus.textContent = "Please select an image file first.";
        geometrizeStatus.style.color = "#f44336";
        return;
    }
    
    const shapeCount = parseInt(geometrizeShapeCount.value) || 200;
    const alpha = parseInt(geometrizeAlpha.value) || 128;
    const candidatesPerStep = parseInt(geometrizeCandidates.value) || 50;
    const mutationsPerStep = parseInt(geometrizeMutations.value) || 100;
    const shapeTypes = getSelectedShapeTypes();
    const target = document.querySelector('input[name="geometrizeTarget"]:checked').value;
    
    geometrizeBtn.disabled = true;
    stopGeometrizeBtn.style.display = "block";
    progressContainer.style.display = "block";
    geometrizePreview.style.display = "block";
    geometrizeStatus.textContent = "Loading image...";
    geometrizeStatus.style.color = "#666";
    
    try {
        // Load and convert image
        const bitmapData = await imageToBitmapData(file);
        const { width, height, data, originalWidth, originalHeight, avgColor } = bitmapData;
        
        // Calculate scale factors
        const scaleX = originalWidth / width;
        const scaleY = originalHeight / height;
        
        // Setup preview canvas
        const previewScale = Math.min(300 / originalWidth, 300 / originalHeight);
        geometrizePreview.width = Math.floor(originalWidth * previewScale);
        geometrizePreview.height = Math.floor(originalHeight * previewScale);
        previewCtx.fillStyle = `rgb(${avgColor[0]},${avgColor[1]},${avgColor[2]})`;
        previewCtx.fillRect(0, 0, geometrizePreview.width, geometrizePreview.height);
        
        // Initialize shapes with background using average color
        generatedShapes = [{
            type: 0,
            data: [0, 0, originalWidth, originalHeight],
            color: avgColor,
            score: 0
        }];
        
        isGeometrizing = true;
        let currentStep = 0;
        
        geometrizeStatus.textContent = `Processing: 0 / ${shapeCount} shapes`;
        
        // Create worker using the embedded geometrize library directly
        // The library is designed to be used as a worker - it sets onmessage automatically
        const geometrizeLibCode = document.getElementById('geometrize-lib').textContent;
        const workerBlob = new Blob([geometrizeLibCode], { type: 'application/javascript' });
        geometrizeWorker = new Worker(URL.createObjectURL(workerBlob));
        
        // Process step by step
        await new Promise((resolve, reject) => {
            geometrizeWorker.onmessage = (e) => {
                const msg = e.data;
                
                if (msg.id === "did_set_target_image") {
                    // Start stepping
                    doStep();
                }
                else if (msg.id === "did_step") {
                    if (!isGeometrizing) {
                        resolve();
                        return;
                    }
                    
                    // Parse the JSON string and scale coordinates
                    if (msg.jsonData) {
                        const newShapes = parseAndScaleShapes(msg.jsonData, scaleX, scaleY);
                        generatedShapes.push(...newShapes);
                    }
                    
                    currentStep++;
                    
                    // Update progress
                    const progress = (currentStep / shapeCount) * 100;
                    progressFill.style.width = progress + "%";
                    progressText.textContent = `Processing: ${currentStep} / ${shapeCount} shapes`;
                    
                    // Update preview every 10 steps for performance
                    if (currentStep % 10 === 0 || currentStep >= shapeCount) {
                        drawPreview(generatedShapes, originalWidth, originalHeight);
                    }
                    
                    if (currentStep >= shapeCount) {
                        resolve();
                    } else {
                        doStep();
                    }
                }
            };
            
            geometrizeWorker.onerror = (err) => {
                console.error("Worker error:", err);
                reject(err);
            };
            
            function doStep() {
                geometrizeWorker.postMessage({
                    id: "should_step",
                    data: {
                        shapeTypes: shapeTypes,
                        alpha: alpha,
                        candidateShapesPerStep: candidatesPerStep,
                        shapeMutationsPerStep: mutationsPerStep
                    }
                });
            }
            
            // Send target image to worker
            geometrizeWorker.postMessage({
                id: "should_set_target_image",
                data: { width, height, data }
            });
        });
        
        // Processing complete
        if (geometrizeWorker) {
            geometrizeWorker.terminate();
            geometrizeWorker = null;
        }
        
        isGeometrizing = false;
        geometrizeBtn.disabled = false;
        stopGeometrizeBtn.style.display = "none";
        
        // Load results
        if (target === "base") {
            baseShapes = [...generatedShapes];
            currentShapes = [...baseShapes];
            groupedShapes = [...currentShapes];
            
            window.sourceWidth = originalWidth;
            window.sourceHeight = originalHeight;
            
            baseFileStatus.textContent = `Generated (${generatedShapes.length} shapes)`;
            
            slider.max = generatedShapes.length;
            slider.value = generatedShapes.length;
            sliderLabel.textContent = `Shapes: ${generatedShapes.length} / ${generatedShapes.length}`;
            
            drawCanvas(currentShapes);
            downloadJsonBtn.disabled = false;
            
            geometrizeStatus.textContent = `‚úì Generated ${generatedShapes.length} shapes as Base (${originalWidth}x${originalHeight})`;
        } else {
            detailShapes = [...generatedShapes];
            detailFileStatus.textContent = `Generated (${generatedShapes.length} shapes)`;
            
            geometrizeStatus.textContent = `‚úì Generated ${generatedShapes.length} shapes as Detail (${originalWidth}x${originalHeight})`;
        }
        
        geometrizeStatus.style.color = "#4CAF50";
        
    } catch (err) {
        console.error("Geometrize error:", err);
        geometrizeStatus.textContent = `Error: ${err.message}`;
        geometrizeStatus.style.color = "#f44336";
        
        if (geometrizeWorker) {
            geometrizeWorker.terminate();
            geometrizeWorker = null;
        }
        isGeometrizing = false;
        geometrizeBtn.disabled = false;
        stopGeometrizeBtn.style.display = "none";
    }
});

// Draw preview of generated shapes
function drawPreview(shapes, srcWidth, srcHeight) {
    const scale = Math.min(geometrizePreview.width / srcWidth, geometrizePreview.height / srcHeight);
    
    previewCtx.fillStyle = "white";
    previewCtx.fillRect(0, 0, geometrizePreview.width, geometrizePreview.height);
    
    shapes.forEach(s => {
        const [r, g, b, a] = s.color;
        previewCtx.fillStyle = `rgba(${r},${g},${b},${a / 255})`;
        
        if (s.type === 0) {
            previewCtx.fillRect(0, 0, geometrizePreview.width, geometrizePreview.height);
        }
        else if (s.type === 1) {
            // Circle
            const [cx, cy, rad] = s.data;
            previewCtx.beginPath();
            previewCtx.arc(cx * scale, cy * scale, rad * scale, 0, Math.PI * 2);
            previewCtx.fill();
        }
        else if (s.type === 2) {
            // Triangle
            const [A, B, C, D, E, F] = s.data;
            previewCtx.beginPath();
            previewCtx.moveTo(A * scale, B * scale);
            previewCtx.lineTo(C * scale, D * scale);
            previewCtx.lineTo(E * scale, F * scale);
            previewCtx.closePath();
            previewCtx.fill();
        }
        else if (s.type === 4) {
            // Rotated Ellipse
            const [cx, cy, rx, ry, ang] = s.data;
            previewCtx.save();
            previewCtx.translate(cx * scale, cy * scale);
            previewCtx.rotate((ang || 0) * Math.PI / 180);
            previewCtx.beginPath();
            previewCtx.ellipse(0, 0, rx * scale, ry * scale, 0, 0, Math.PI * 2);
            previewCtx.fill();
            previewCtx.restore();
        }
    });
}

/* ==========================================================
   LOAD JSON
========================================================== */

baseFileInput.addEventListener("change", async e => {
    const file = e.target.files[0];
    if (!file) return;

    const text = await file.text();
    baseShapes = JSON.parse(text);

    currentShapes = [...baseShapes];
    groupedShapes = [...currentShapes];
    
    // Clear stored dimensions so getImageRect uses background shape
    window.sourceWidth = null;
    window.sourceHeight = null;

    baseFileStatus.textContent = `Loaded (${baseShapes.length} shapes)`;
    downloadJsonBtn.disabled = false;

    updateRender();
});

detailFileInput.addEventListener("change", async e => {
    const file = e.target.files[0];
    if (!file) return;

    const text = await file.text();
    detailShapes = JSON.parse(text);
    detailFileStatus.textContent = `Loaded (${detailShapes.length} shapes)`;
});

/* ==========================================================
   REGION SELECTION
========================================================== */

selectRegionsBtn.addEventListener("click", () => {
    isSelecting = !isSelecting;
    selectRegionsBtn.classList.toggle("active", isSelecting);
    selectRegionsBtn.textContent = isSelecting ? "Stop Selecting" : "Select Regions for Detail";
    
    // Disable color picker when region selection is active
    if (isSelecting && isPickingColor) {
        isPickingColor = false;
        colorPickerBtn.classList.remove("active");
        colorPickerBtn.textContent = "Enable Color Picker";
        canvas.classList.remove("picking");
        colorPickerPanel.classList.remove("active");
        clearShapeHighlight();
    }
});

clearRegionsBtn.addEventListener("click", () => {
    regions = [];
    updateRegionUI();
    updateRender();
});

canvas.addEventListener("mousedown", e => {
    if (!isSelecting) return;

    const rect = canvas.getBoundingClientRect();
    startX = e.clientX - rect.left;
    startY = e.clientY - rect.top;

    currentRegion = { x: startX, y: startY, width: 0, height: 0 };
});

canvas.addEventListener("mousemove", e => {
    if (!isSelecting || !currentRegion) return;

    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;

    currentRegion.width = x - startX;
    currentRegion.height = y - startY;

    drawCanvas();
    drawRegionOverlay(currentRegion, true);
});

canvas.addEventListener("mouseup", e => {
    if (!isSelecting || !currentRegion) return;

    if (currentRegion.width < 0) {
        currentRegion.x += currentRegion.width;
        currentRegion.width = Math.abs(currentRegion.width);
    }
    if (currentRegion.height < 0) {
        currentRegion.y += currentRegion.height;
        currentRegion.height = Math.abs(currentRegion.height);
    }

    const imgRect = getImageRect();
    const scale = imgRect.scale;

    const region = {
        x: (currentRegion.x - imgRect.x) / scale,
        y: (currentRegion.y - imgRect.y) / scale,
        width: currentRegion.width / scale,
        height: currentRegion.height / scale
    };

    if (region.width > 5 && region.height > 5) regions.push(region);

    currentRegion = null;
    updateRegionUI();
    updateRender();
});

/* ==========================================================
   REGION UI
========================================================== */

function updateRegionUI() {
    regionOverlay.innerHTML = "";

    if (regions.length === 0) {
        regionList.style.display = "none";
        return;
    }

    regionList.style.display = "block";
    regionList.innerHTML = `<strong>Selected Regions (${regions.length}):</strong>`;

    const imgRect = getImageRect();
    const scale = imgRect.scale;

    regions.forEach((r, i) => {
        const box = document.createElement("div");
        box.className = "region-box";
        box.style.left = imgRect.x + r.x * scale + "px";
        box.style.top = imgRect.y + r.y * scale + "px";
        box.style.width = r.width * scale + "px";
        box.style.height = r.height * scale + "px";

        regionOverlay.appendChild(box);

        const item = document.createElement("div");
        item.className = "region-item";
        item.innerHTML = `
            Region ${i + 1}: ${Math.round(r.width)}√ó${Math.round(r.height)}
            <button onclick="removeRegion(${i})">Remove</button>
        `;
        regionList.appendChild(item);
    });
}

window.removeRegion = function(i) {
    regions.splice(i, 1);
    updateRegionUI();
    updateRender();
};

/* ==========================================================
   IMAGE SCALE HELPERS
========================================================== */

function getImageRect() {
    const bg = currentShapes.find(s => s.type === 0);
    let w = 600, h = 600;

    if (bg) {
        const [x1, y1, x2, y2] = bg.data;
        w = Math.abs(x2 - x1) || x2 || 600;
        h = Math.abs(y2 - y1) || y2 || 600;
    }
    
    // Use stored source dimensions if available (from geometrize)
    if (window.sourceWidth && window.sourceHeight) {
        w = window.sourceWidth;
        h = window.sourceHeight;
    }

    const scale = Math.min(canvas.width / w, canvas.height / h);
    const x = (canvas.width - w * scale) / 2;
    const y = (canvas.height - h * scale) / 2;

    return { x, y, w, h, scale };
}

/* ==========================================================
   APPLY SELECTIVE RESOLUTION
========================================================== */

applySelectiveBtn.addEventListener("click", async () => {
    if (!baseShapes.length || !detailShapes.length) {
        alert("Load both base and detail JSON first.");
        return;
    }
    if (!regions.length) {
        alert("Select regions first.");
        return;
    }

    const res = await fetch(`${API_BASE}/selective_resolution`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
            base_shapes: baseShapes,
            detail_shapes: detailShapes,
            regions
        })
    });

    const data = await res.json();

    currentShapes = [...data.shapes];
    groupedShapes = [...currentShapes];
    colorTolerance = 0;
    colorGroupSlider.value = 0;

    alert("Selective resolution applied successfully!");

    updateRender();
});

/* ==========================================================
   BAKE OPAQUE ‚Äî PAGE 31 FIX
========================================================== */

bakeOpaqueBtn.addEventListener("click", async () => {
    if (!currentShapes.length) {
        alert("Load shapes first.");
        return;
    }

    // Render final image to canvas
    drawCanvas();

    const pngBlob = await new Promise(resolve => canvas.toBlob(resolve, "image/png"));

    const form = new FormData();
    form.append("file", pngBlob, "render.png");
    form.append(
        "request",
        new Blob(
            [JSON.stringify({ shapes: currentShapes, logic: "original", limit: null })],
            { type: "application/json" }
        )
    );

    const res = await fetch(`${API_BASE}/bake_opaque`, {
        method: "POST",
        body: form
    });

    const data = await res.json();

    currentShapes = [...data.shapes];
    groupedShapes = [...currentShapes];
    colorTolerance = 0;

    alert("Baked successfully! Shapes are now order-independent.");

    updateRender();
});

/* ==========================================================
   COLOR PICKER TOOL
========================================================== */

colorPickerBtn.addEventListener("click", () => {
    isPickingColor = !isPickingColor;
    colorPickerBtn.classList.toggle("active", isPickingColor);
    colorPickerBtn.textContent = isPickingColor ? "Disable Color Picker" : "Enable Color Picker";
    canvas.classList.toggle("picking", isPickingColor);
    
    // Disable region selection when color picking is active
    if (isPickingColor && isSelecting) {
        isSelecting = false;
        selectRegionsBtn.classList.remove("active");
        selectRegionsBtn.textContent = "Select Regions for Detail";
    }
    
    if (!isPickingColor) {
        colorPickerPanel.classList.remove("active");
        clearShapeHighlight();
    }
});

function getShapeTypeName(type) {
    const types = {
        0: "Background",
        1: "Circle",
        2: "Triangle",
        3: "Quad",
        4: "Ellipse"
    };
    return types[type] || `Type ${type}`;
}

function rgbToHex(r, g, b) {
    return "#" + [r, g, b].map(x => {
        const hex = Math.round(x).toString(16);
        return hex.length === 1 ? "0" + hex : hex;
    }).join("").toUpperCase();
}

function getShapeCenter(shape, imgRect) {
    if (shape.type === 0 && shape.data.length >= 4) {
        const [x1, y1, x2, y2] = shape.data;
        return { x: (x1 + x2) / 2, y: (y1 + y2) / 2 };
    }
    if (shape.type === 1 && shape.data.length >= 3) {
        return { x: shape.data[0], y: shape.data[1] };
    }
    if (shape.type === 2 && shape.data.length >= 6) {
        const [A, B, C, D, E, F] = shape.data;
        return { x: (A + C + E) / 3, y: (B + D + F) / 3 };
    }
    if (shape.type === 4 && shape.data.length >= 2) {
        return { x: shape.data[0], y: shape.data[1] };
    }
    return { x: imgRect.w / 2, y: imgRect.h / 2 };
}

function isPointInShape(x, y, shape, imgRect) {
    // Convert canvas coordinates to image coordinates
    const imgX = (x - imgRect.x) / imgRect.scale;
    const imgY = (y - imgRect.y) / imgRect.scale;
    
    if (shape.type === 0) {
        // Background - covers entire canvas
        return true;
    }
    
    if (shape.type === 1) {
        // Circle
        const [cx, cy, rad] = shape.data;
        const dist = Math.hypot(imgX - cx, imgY - cy);
        return dist <= rad;
    }
    
    if (shape.type === 2) {
        // Triangle - use barycentric coordinates
        const [A, B, C, D, E, F] = shape.data;
        return isPointInTriangle(imgX, imgY, A, B, C, D, E, F);
    }
    
    if (shape.type === 4) {
        // Ellipse
        const [cx, cy, rx, ry, ang = 0] = shape.data;
        const angleRad = (ang * Math.PI) / 180;
        const cos = Math.cos(-angleRad);
        const sin = Math.sin(-angleRad);
        const dx = imgX - cx;
        const dy = imgY - cy;
        const rotX = dx * cos - dy * sin;
        const rotY = dx * sin + dy * cos;
        return (rotX * rotX) / (rx * rx) + (rotY * rotY) / (ry * ry) <= 1;
    }
    
    return false;
}

function isPointInTriangle(px, py, x1, y1, x2, y2, x3, y3) {
    const area = 0.5 * (-y2 * x3 + y1 * (-x2 + x3) + x1 * (y2 - y3) + x2 * y3);
    const s = 1 / (2 * area) * (y1 * x3 - x1 * y3 + (y3 - y1) * px + (x1 - x3) * py);
    const t = 1 / (2 * area) * (x1 * y2 - y1 * x2 + (y1 - y2) * px + (x2 - x1) * py);
    return s >= 0 && t >= 0 && (1 - s - t) >= 0;
}

function findShapeAtPoint(x, y) {
    const imgRect = getImageRect();
    const working = groupedShapes.length ? groupedShapes : currentShapes;
    
    // Get currently displayed shapes based on slider
    const limit = parseInt(slider.value);
    const displayedShapes = limit > 0 ? working.slice(0, limit) : working;
    
    // Search from top (last rendered) to bottom (first rendered)
    for (let i = displayedShapes.length - 1; i >= 0; i--) {
        const shape = displayedShapes[i];
        if (isPointInShape(x, y, shape, imgRect)) {
            return { shape, index: i };
        }
    }
    return null;
}

function displayShapeInfo(shape, index) {
    const imgRect = getImageRect();
    const [r, g, b, a] = shape.color;
    
    // Set current selected color for matching
    currentSelectedColor = rgbToHex(r, g, b);
    updateMatchButtonState();
    
    colorPickerPanel.classList.add("active");
    colorPreviewBox.style.backgroundColor = `rgba(${r},${g},${b},${a/255})`;
    
    shapeTypeValue.textContent = getShapeTypeName(shape.type);
    shapeIndexValue.textContent = index;
    rgbValue.textContent = `${r}, ${g}, ${b}`;
    rgbaValue.textContent = `${r}, ${g}, ${b}, ${a}`;
    hexValue.textContent = rgbToHex(r, g, b);
    alphaValue.textContent = `${a} (${(a/255*100).toFixed(1)}%)`;
    
    const center = getShapeCenter(shape, imgRect);
    positionValue.textContent = `${center.x.toFixed(1)}, ${center.y.toFixed(1)}`;
    scoreValue.textContent = shape.score?.toFixed(4) || "-";
    
    highlightShape(shape, imgRect);
}

function highlightShape(shape, imgRect) {
    clearShapeHighlight();
    
    // Create SVG overlay for precise shape outline
    const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    svg.id = "shapeHighlight";
    svg.style.position = "absolute";
    svg.style.left = imgRect.x + "px";
    svg.style.top = imgRect.y + "px";
    svg.style.width = imgRect.w * imgRect.scale + "px";
    svg.style.height = imgRect.h * imgRect.scale + "px";
    svg.style.pointerEvents = "none";
    svg.style.overflow = "visible";
    
    let pathElement;
    const scale = imgRect.scale;
    
    if (shape.type === 0) {
        // Background - rectangle outline
        pathElement = document.createElementNS("http://www.w3.org/2000/svg", "rect");
        pathElement.setAttribute("x", "2");
        pathElement.setAttribute("y", "2");
        pathElement.setAttribute("width", imgRect.w * scale - 4);
        pathElement.setAttribute("height", imgRect.h * scale - 4);
    } else if (shape.type === 1) {
        // Circle
        const [cx, cy, rad] = shape.data;
        pathElement = document.createElementNS("http://www.w3.org/2000/svg", "circle");
        pathElement.setAttribute("cx", cx * scale);
        pathElement.setAttribute("cy", cy * scale);
        pathElement.setAttribute("r", rad * scale);
    } else if (shape.type === 2) {
        // Triangle
        const [A, B, C, D, E, F] = shape.data;
        pathElement = document.createElementNS("http://www.w3.org/2000/svg", "polygon");
        const points = `${A * scale},${B * scale} ${C * scale},${D * scale} ${E * scale},${F * scale}`;
        pathElement.setAttribute("points", points);
    } else if (shape.type === 4) {
        // Ellipse (with rotation support)
        const [cx, cy, rx, ry, ang = 0] = shape.data;
        pathElement = document.createElementNS("http://www.w3.org/2000/svg", "ellipse");
        pathElement.setAttribute("cx", cx * scale);
        pathElement.setAttribute("cy", cy * scale);
        pathElement.setAttribute("rx", rx * scale);
        pathElement.setAttribute("ry", ry * scale);
        if (ang !== 0) {
            pathElement.setAttribute("transform", `rotate(${ang} ${cx * scale} ${cy * scale})`);
        }
    } else {
        return;
    }
    
    // Style the outline
    pathElement.setAttribute("fill", "rgba(0, 188, 212, 0.15)");
    pathElement.setAttribute("stroke", "#00BCD4");
    pathElement.setAttribute("stroke-width", "3");
    pathElement.setAttribute("stroke-dasharray", "8,4");
    
    // Add animated dash effect
    const animate = document.createElementNS("http://www.w3.org/2000/svg", "animate");
    animate.setAttribute("attributeName", "stroke-dashoffset");
    animate.setAttribute("from", "0");
    animate.setAttribute("to", "24");
    animate.setAttribute("dur", "1s");
    animate.setAttribute("repeatCount", "indefinite");
    pathElement.appendChild(animate);
    
    svg.appendChild(pathElement);
    regionOverlay.appendChild(svg);
}

function clearShapeHighlight() {
    const existing = document.getElementById("shapeHighlight");
    if (existing) existing.remove();
}

canvas.addEventListener("click", e => {
    if (!isPickingColor) return;
    if (isSelecting) return;
    
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    
    const result = findShapeAtPoint(x, y);
    
    if (result) {
        selectedShapeIndex = result.index;
        displayShapeInfo(result.shape, result.index);
    } else {
        colorPickerPanel.classList.remove("active");
        clearShapeHighlight();
    }
});

/* ==========================================================
   PALETTE PRESET FUNCTIONALITY
========================================================== */

// Embedded palette data to avoid CORS issues with local files
let palettePresetsData = null;

// Load colors.json data
async function loadPalettePresets() {
    try {
        // Try to fetch colors.json if server is available
        const response = await fetch('colors.json');
        palettePresetsData = await response.json();
    } catch (error) {
        console.warn('Could not fetch colors.json, using embedded fallback');
        // Fallback: Load from embedded script tag or use default
        const colorsScript = document.getElementById('colorsData');
        if (colorsScript && colorsScript.textContent) {
            try {
                palettePresetsData = JSON.parse(colorsScript.textContent);
            } catch (e) {
                console.error('Error parsing embedded colors data:', e);
                return;
            }
        } else {
            console.error('No colors data available');
            return;
        }
    }
    
    if (!palettePresetsData) return;
    
    const select = document.getElementById('palettePresetSelect');
    
    // Clear existing options except the first one
    while (select.options.length > 1) {
        select.remove(1);
    }
    
    // Populate dropdown with palette names
    Object.keys(palettePresetsData).forEach(paletteName => {
        const option = document.createElement('option');
        option.value = paletteName;
        option.textContent = `${paletteName} (${palettePresetsData[paletteName].length} colors)`;
        select.appendChild(option);
    });
    
    console.log('Loaded palette presets:', Object.keys(palettePresetsData));
}

// Enable/disable load button based on selection
document.getElementById('palettePresetSelect').addEventListener('change', (e) => {
    document.getElementById('loadPaletteBtn').disabled = !e.target.value;
});

// Load selected palette into the color matcher input
document.getElementById('loadPaletteBtn').addEventListener('click', () => {
    const select = document.getElementById('palettePresetSelect');
    const selectedPalette = select.value;
    
    if (!selectedPalette || !palettePresetsData[selectedPalette]) {
        return;
    }
    
    const colorArray = palettePresetsData[selectedPalette];
    
    // Convert RGB arrays to hex format
    const hexColors = colorArray.map(rgb => {
        const r = Math.round(rgb[0]);
        const g = Math.round(rgb[1]);
        const b = Math.round(rgb[2]);
        return rgbToHex(r, g, b);
    });
    
    // Populate the color matcher input textarea
    const colorMatcherInput = document.getElementById('colorMatcherInput');
    colorMatcherInput.value = hexColors.join('\n');
    
    // Update match button state
    updateMatchButtonState();
    
    console.log(`Loaded ${hexColors.length} colors from "${selectedPalette}"`);
});

// Initialize palette presets on page load
loadPalettePresets();

/* ==========================================================
   COLOR MATCHER FUNCTIONALITY (via API)
========================================================== */

colorMatcherInput.addEventListener("input", updateMatchButtonState);

function updateMatchButtonState() {
    const hasColor = currentSelectedColor !== null;
    const hasPalette = colorMatcherInput.value.trim().length > 0;
    // Also update recipe button
    if (typeof updateRecipeButtonState === 'function') {
        updateRecipeButtonState();
    } else {
        getRecipeBtn.disabled = !(hasColor && hasPalette);
    }
}

function parsePaletteColors(input) {
    return input
        .split(/[\n,]+/)
        .map(c => c.trim())
        .filter(c => c.length > 0)
        .map(c => c.startsWith('#') ? c : '#' + c)
        .filter(c => /^#[0-9A-Fa-f]{3,6}$/i.test(c));
}

function getMatchClass(percentage) {
    if (percentage >= 70) return 'high';
    if (percentage >= 40) return 'medium';
    return 'low';
}

function renderMatchResults(data) {
    if (data.error && !data.has_matches) {
        let html = `<div class="match-error">‚ö†Ô∏è ${data.error}</div>`;
        
        // Still show results if we have them (just with low matches)
        if (data.matches && data.matches.length > 0) {
            html += `<div class="match-results-header" style="margin-top: 12px;">
                <span>All Comparisons</span>
                <span>${data.matches.length} colors</span>
            </div>`;
            html += data.matches.map((m, i) => renderMatchItem(m, i === 0)).join('');
        }
        
        matchResults.innerHTML = html;
        return;
    }
    
    if (!data.matches || data.matches.length === 0) {
        matchResults.innerHTML = `<div class="match-empty">No valid colors found in the palette</div>`;
        return;
    }
    
    let html = `<div class="match-results-header">
        <span>Match Results</span>
        <span>${data.matches.length} colors</span>
    </div>`;
    
    html += data.matches.map((m, i) => renderMatchItem(m, i === 0)).join('');
    
    matchResults.innerHTML = html;
}

function renderMatchItem(match, isBest) {
    const matchClass = getMatchClass(match.match_percentage);
    return `
        <div class="match-result-item ${isBest ? 'best-match' : ''}">
            <div class="match-color-swatch" style="background: ${match.hex}"></div>
            <div class="match-info">
                <div class="match-hex">
                    ${match.hex}
                    ${isBest ? '<span class="best-badge">Best</span>' : ''}
                </div>
                <div class="match-delta">ŒîE: ${match.delta_e.toFixed(2)}</div>
                <div class="match-progress-bar">
                    <div class="match-progress-fill ${matchClass}" style="width: ${match.match_percentage}%"></div>
                </div>
            </div>
            <div class="match-percentage">
                <div class="match-percentage-value ${matchClass}">${match.match_percentage.toFixed(1)}%</div>
                <div class="match-percentage-label">match</div>
            </div>
        </div>
    `;
}



/* ==========================================================
   UNMIX / GET RECIPE FUNCTIONALITY (via API)
========================================================== */

// Update recipe button state
function updateRecipeButtonState() {
    const hasColor = currentSelectedColor !== null;
    const hasPalette = colorMatcherInput.value.trim().length > 0;
    getRecipeBtn.disabled = !(hasColor && hasPalette);
}

// Also update recipe button when palette changes
colorMatcherInput.addEventListener("input", updateRecipeButtonState);

function getRecipeMatchClass(percentage) {
    if (percentage >= 70) return 'high';
    if (percentage >= 40) return 'medium';
    return 'low';
}

function formatMixMethod(method) {
    const methods = {
        'kubelka_munk': 'Kubelka-Munk (Paint)',
        'yn_km': 'Yule-Nielsen KM',
        'linear': 'Linear RGB (Light)',
        'exact': 'Exact Match'
    };
    return methods[method] || method;
}

function renderRecipeResults(data) {
    if (data.error) {
        recipeResults.innerHTML = `<div class="recipe-error">‚ö†Ô∏è ${data.error}</div>`;
        return;
    }
    
    if (!data.recipe || data.recipe.length === 0) {
        recipeResults.innerHTML = `<div class="recipe-empty">No recipe found for this color</div>`;
        return;
    }
    
    const matchClass = getRecipeMatchClass(data.match_percentage);
    
    let html = `
        <div class="recipe-header">
            <div class="recipe-header-left">
                <div class="recipe-target-swatch" style="background: ${data.target_color}" title="Target"></div>
                <div class="recipe-arrow">‚Üí</div>
                <div class="recipe-result-swatch" style="background: ${data.result_color}" title="Result"></div>
            </div>
            <div class="recipe-match-info">
                <div class="recipe-match-value ${matchClass}">${data.match_percentage}%</div>
                <div class="recipe-match-label">match</div>
                <div class="recipe-method">${formatMixMethod(data.mix_method)}</div>
            </div>
        </div>
        <div class="recipe-components">
    `;
    
    data.recipe.forEach(comp => {
        const displayName = comp.name || comp.hex;
        html += `
            <div class="recipe-component">
                <div class="recipe-component-swatch" style="background: ${comp.hex}"></div>
                <div class="recipe-component-info">
                    <div class="recipe-component-name" title="${displayName}">${displayName}</div>
                    <div class="recipe-component-hex">${comp.hex}</div>
                </div>
                <div class="recipe-component-amount">
                    <div class="recipe-component-parts">${comp.parts}</div>
                    <div class="recipe-component-parts-label">parts</div>
                    <div class="recipe-component-percent">${comp.percentage}%</div>
                </div>
            </div>
        `;
    });
    
    html += `</div>`;
    html += `<div class="recipe-total">Total: ${data.total_parts} parts ¬∑ ŒîE: ${data.delta_e}</div>`;
    
    recipeResults.innerHTML = html;
}

// Build palette with names for the unmix request
function buildPaletteWithNames(hexColors) {
    // Try to get names from the loaded palette preset
    const select = document.getElementById('palettePresetSelect');
    const selectedPalette = select.value;
    
    if (selectedPalette && palettePresetsData && palettePresetsData[selectedPalette]) {
        const colorArray = palettePresetsData[selectedPalette];
        const paletteMap = new Map();
        
        // Build map of hex -> name
        colorArray.forEach((rgb, idx) => {
            const r = Math.round(rgb[0]);
            const g = Math.round(rgb[1]);
            const b = Math.round(rgb[2]);
            const hex = rgbToHex(r, g, b).toUpperCase();
            paletteMap.set(hex, `${selectedPalette} #${idx + 1}`);
        });
        
        // Return palette with names where available
        return hexColors.map(hex => ({
            hex: hex,
            name: paletteMap.get(hex.toUpperCase()) || null
        }));
    }
    
    // No preset loaded, return without names
    return hexColors.map(hex => ({ hex: hex, name: null }));
}

getRecipeBtn.addEventListener("click", async () => {
    if (!currentSelectedColor) {
        alert("Please select a shape first using the color picker.");
        return;
    }
    
    const paletteColors = parsePaletteColors(colorMatcherInput.value);
    
    if (paletteColors.length === 0) {
        recipeResults.innerHTML = `<div class="recipe-error">‚ö†Ô∏è Please enter valid hex colors in the palette</div>`;
        return;
    }
    
    const maxColors = parseInt(maxColorsInput.value) || 3;
    const maxParts = parseInt(maxPartsInput.value) || 10;
    
    // Build palette with names
    const paletteWithNames = buildPaletteWithNames(paletteColors);
    
    // Show loading state
    recipeResults.innerHTML = `<div class="recipe-empty">‚è≥ Finding best recipe...</div>`;
    getRecipeBtn.disabled = true;
    
    try {
        const response = await fetch(`${API_BASE}/unmix`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
                target_color: currentSelectedColor,
                palette: paletteWithNames,
                max_colors: maxColors,
                max_parts: maxParts
            })
        });
        
        if (!response.ok) {
            throw new Error(`API error: ${response.status}`);
        }
        
        const data = await response.json();
        renderRecipeResults(data);
        
    } catch (error) {
        console.error("Unmix API error:", error);
        recipeResults.innerHTML = `<div class="recipe-error">‚ö†Ô∏è API Error: ${error.message}. Make sure the backend is running.</div>`;
    } finally {
        updateRecipeButtonState();
    }
});

/* ==========================================================
   LOGIC ORDERING ‚Äì CALL BACKEND
========================================================== */

logicRadios.forEach(r => r.addEventListener("change", updateRender));

slider.addEventListener("input", updateRender);

colorGroupSlider.addEventListener("input", () => {
    colorTolerance = parseInt(colorGroupSlider.value);
    applyColorGrouping();
    updateRender();
});

/* ==========================================================
   UPDATE RENDER
========================================================== */

async function updateRender() {
    if (!currentShapes.length) return;
    
    // Clear any shape highlight when re-rendering
    clearShapeHighlight();

    const working = groupedShapes.length ? groupedShapes : currentShapes;

    const logic = document.querySelector("input[name='logic']:checked").value;
    const limit = parseInt(slider.value);

    if (logic === "original") {
        slider.max = working.length;
        sliderLabel.textContent = `Shapes: ${limit} / ${working.length}`;
        drawCanvas(working.slice(0, limit || working.length));
        updateRegionUI();
        return;
    }

    const activeOrder =
        logic === "color_sequence" ? colorOrder :
        logic === "custom_sequence" ? customColorOrder : null;

    const res = await fetch(`${API_BASE}/order_shapes_from_json`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
            shapes: working,
            logic,
            limit,
            color_order: activeOrder
        })
    });

    const data = await res.json();

    slider.max = data.total_shapes;
    sliderLabel.textContent = `Shapes: ${limit} / ${data.total_shapes}`;

    drawCanvas(data.shapes);
    updateRegionUI();
}
/* ==========================================================
   DRAW CANVAS
========================================================== */
function drawCanvas(shapes = currentShapes) {
    ctx.fillStyle = "white";
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    if (!shapes.length) return;

    const img = getImageRect();
    const { x, y, scale } = img;

    const off = document.createElement("canvas");
    off.width = img.w;
    off.height = img.h;
    const o = off.getContext("2d");

    shapes.forEach(s => {
        const [r, g, b, a] = s.color;
        o.fillStyle = `rgba(${r},${g},${b},${a / 255})`;

        if (s.type === 0) {
            const [x1, y1, x2, y2] = s.data;
            o.fillRect(0, 0, img.w, img.h);
        }

        else if (s.type === 1) {
            const [cx, cy, rad] = s.data;
            o.beginPath();
            o.arc(cx, cy, rad, 0, Math.PI * 2);
            o.fill();
        }

        else if (s.type === 2) {
            const [A, B, C, D, E, F] = s.data;
            o.beginPath();
            o.moveTo(A, B);
            o.lineTo(C, D);
            o.lineTo(E, F);
            o.closePath();
            o.fill();
        }

        else if (s.type === 4) {
            const [cx, cy, rx, ry, ang] = s.data;
            o.save();
            o.translate(cx, cy);
            o.rotate((ang * Math.PI) / 180);
            o.beginPath();
            o.ellipse(0, 0, rx, ry, 0, 0, Math.PI * 2);
            o.fill();
            o.restore();
        }
    });

    ctx.drawImage(off, x, y, img.w * scale, img.h * scale);
}

/* ==========================================================
   COLOR GROUPING (TOLERANCE)
========================================================== */

function applyColorGrouping() {
    if (!currentShapes.length) return;

    const tol = colorTolerance * 2;

    if (tol === 0) {
        groupedShapes = [...currentShapes];
        updateColorGroupLabel();
        return;
    }

    const colorMap = new Map();

    currentShapes.forEach((s, idx) => {
        if (s.type === 0) return;
        const key = JSON.stringify(s.color);
        if (!colorMap.has(key)) colorMap.set(key, []);
        colorMap.get(key).push(idx);
    });

    const colorList = [...colorMap.keys()].map(k => JSON.parse(k));

    const groups = [];
    const used = new Set();

    colorList.forEach((c1, i) => {
        if (used.has(i)) return;

        const group = [c1];
        const indices = [...colorMap.get(JSON.stringify(c1))];
        used.add(i);

        colorList.forEach((c2, j) => {
            if (used.has(j)) return;
            const dist = Math.sqrt(
                (c1[0] - c2[0]) ** 2 +
                (c1[1] - c2[1]) ** 2 +
                (c1[2] - c2[2]) ** 2
            );
            if (dist <= tol) {
                used.add(j);
                group.push(c2);
                indices.push(...colorMap.get(JSON.stringify(c2)));
            }
        });

        const rep = findRepresentativeColor(group);
        groups.push({ rep, indices });
    });

    groupedShapes = currentShapes.map((s, idx) => {
        if (s.type === 0) return s;
        const g = groups.find(g => g.indices.includes(idx));
        if (!g) return s;
        return { ...s, color: g.rep };
    });

    updateColorGroupLabel();
}

function updateColorGroupLabel() {
    const unique = new Set();

    groupedShapes.forEach(s => {
        if (s.type !== 0) unique.add(JSON.stringify(s.color));
    });

    colorGroupLabel.textContent =
        `Tolerance: ${colorTolerance} (Unique colors: ${unique.size})`;
}

function findRepresentativeColor(colors) {
    let r = 0, g = 0, b = 0, a = 0;
    colors.forEach(c => {
        r += c[0];
        g += c[1];
        b += c[2];
        a += c[3];
    });
    const n = colors.length;
    return [Math.round(r / n), Math.round(g / n), Math.round(b / n), 255];
}

/* ==========================================================
   COLOR ORDER MODAL (EDIT JSON)
========================================================== */

editColorBtn.addEventListener("click", () => {
    if (!currentShapes.length) return alert("Load shapes first.");
    colorInput.value = JSON.stringify(colorOrder || [], null, 2);
    document.getElementById("colorModal").style.display = "block";
});

document.getElementById("cancelColorBtn").onclick = () =>
    (document.getElementById("colorModal").style.display = "none");

document.getElementById("saveColorBtn").onclick = () => {
    try {
        colorOrder = JSON.parse(colorInput.value);
        document.getElementById("colorModal").style.display = "none";
        updateRender();
    } catch {
        alert("Invalid JSON format.");
    }
};

/* ==========================================================
   DRAG & DROP COLOR ORDER
========================================================== */

dragColorBtn.addEventListener("click", () => {
    if (!currentShapes.length) return alert("Load shapes first.");

    populateColorPalette();
    document.getElementById("dragModal").style.display = "block";
});

document.getElementById("cancelDragBtn").onclick = () =>
    (document.getElementById("dragModal").style.display = "none");

document.getElementById("saveDragBtn").onclick = () => {
    const chips = [...document.getElementById("colorPalette").children];
    customColorOrder = chips.map(chip => JSON.parse(chip.dataset.color));
    document.getElementById("dragModal").style.display = "none";
    updateRender();
};

function populateColorPalette() {
    const palette = document.getElementById("colorPalette");
    palette.innerHTML = "";

    const freq = new Map();
    const working = groupedShapes.length ? groupedShapes : currentShapes;

    working.forEach(s => {
        if (s.type === 0) return;
        const k = JSON.stringify(s.color);
        freq.set(k, (freq.get(k) || 0) + 1);
    });

    const list = [...freq.entries()].map(([k, count]) => ({
        color: JSON.parse(k),
        count
    }));

    list.sort((a, b) => b.count - a.count);

    list.forEach((item, i) => {
        const chip = document.createElement("div");
        chip.className = "color-chip";
        chip.draggable = true;
        chip.dataset.color = JSON.stringify(item.color);

        chip.style.backgroundColor =
            `rgba(${item.color[0]},${item.color[1]},${item.color[2]},${item.color[3]/255})`;

        chip.innerHTML = `
            <div class="chip-number">#${i + 1}</div>
            <div class="rgb-value">${item.color.slice(0,3).join(", ")}</div>
            <div class="count">${item.count}√ó</div>
        `;

        chip.addEventListener("dragstart", () => chip.classList.add("dragging"));
        chip.addEventListener("dragend", () => chip.classList.remove("dragging"));
        chip.addEventListener("dragover", e => e.preventDefault());
        chip.addEventListener("drop", e => {
            e.preventDefault();
            const dragging = document.querySelector(".dragging");
            if (dragging && dragging !== chip) {
                const all = [...palette.children];
                const from = all.indexOf(dragging);
                const to = all.indexOf(chip);

                if (from < to) chip.after(dragging);
                else chip.before(dragging);
            }
        });

        palette.appendChild(chip);
    });
}

window.onclick = e => {
    if (e.target.classList.contains("modal")) e.target.style.display = "none";
};

/* ==========================================================
   END SCRIPT
========================================================== */
</script>

<!-- Embedded Geometrize Library -->
<script type="text/javascript" id="geometrize-lib">
(function ($hx_exports, $global) { "use strict";
$hx_exports["geometrize"] = $hx_exports["geometrize"] || {};
$hx_exports["geometrize"]["bitmap"] = $hx_exports["geometrize"]["bitmap"] || {};
;$hx_exports["geometrize"]["exporter"] = $hx_exports["geometrize"]["exporter"] || {};
;$hx_exports["geometrize"]["runner"] = $hx_exports["geometrize"]["runner"] || {};
;$hx_exports["geometrize"]["shape"] = $hx_exports["geometrize"]["shape"] || {};
function $extend(from, fields) {
    var proto = Object.create(from);
    for (var name in fields) proto[name] = fields[name];
    if( fields.toString !== Object.prototype.toString ) proto.toString = fields.toString;
    return proto;
}
var GeometrizeWorker = function() { };
GeometrizeWorker.prototype = {
    messageHandler: function(event) {
        if(event == null || event.data == null) {
            return;
        }
        var message = event.data;
        switch(message.id) {
        case "should_set_target_image":
            var target = message.data;
            this.runner = new geometrize_runner_ImageRunner(target,geometrize_Util.getAverageImageColor(target));
            this.postMessage({ id : "did_set_target_image"});
            break;
        case "should_step":
            var options = message.data;
            var results = this.runner.step(options);
            var svgData = geometrize_exporter_SvgExporter.exportShapes(results);
            var jsonData = geometrize_exporter_ShapeJsonExporter.exportShapes(results);
            this.postMessage({ id : "did_step", svgData : svgData, jsonData : jsonData});
            break;
        }
    }
    ,postMessage: function(message) {
    }
};
var Std = function() { };
Std.random = function(x) {
    if(x <= 0) {
        return 0;
    } else {
        return Math.floor(Math.random() * x);
    }
};
var StringTools = function() { };
StringTools.replace = function(s,sub,by) {
    return s.split(sub).join(by);
};
var UInt = {};
UInt.toFloat = function(this1) {
    var int = this1;
    if(int < 0) {
        return 4294967296.0 + int;
    } else {
        return int + 0.0;
    }
};
var geometrize_ArraySet = {};
geometrize_ArraySet.create = function(array) {
    if(array == null) {
        var this1 = [];
        return this1;
    }
    return geometrize_ArraySet.toSet(array);
};
geometrize_ArraySet.add = function(this1,element) {
    if(element == null) {
        throw haxe_Exception.thrown("FAIL: element != null");
    }
    if(geometrize_ArraySet.contains(this1,element)) {
        return false;
    }
    this1.push(element);
    return true;
};
geometrize_ArraySet.contains = function(this1,element) {
    var _g = 0;
    while(_g < this1.length) {
        var i = this1[_g];
        ++_g;
        if(i == element) {
            return true;
        }
    }
    return false;
};
geometrize_ArraySet.toArray = function(this1) {
    return this1.slice();
};
geometrize_ArraySet.toSet = function(array) {
    var this1 = [];
    var set = this1;
    var _g = 0;
    while(_g < array.length) {
        var v = array[_g];
        ++_g;
        geometrize_ArraySet.add(set,v);
    }
    return set;
};
var geometrize_Core = function() { };
geometrize_Core.computeColor = function(target,current,lines,alpha) {
    if(target == null) {
        throw haxe_Exception.thrown("FAIL: target != null");
    }
    if(current == null) {
        throw haxe_Exception.thrown("FAIL: current != null");
    }
    if(lines == null) {
        throw haxe_Exception.thrown("FAIL: lines != null");
    }
    if(alpha < 0) {
        throw haxe_Exception.thrown("FAIL: alpha >= 0");
    }
    var totalRed = 0;
    var totalGreen = 0;
    var totalBlue = 0;
    var count = 0;
    var f = 65535 / alpha;
    var a = f | 0;
    var _g = 0;
    while(_g < lines.length) {
        var line = lines[_g];
        ++_g;
        var y = line.y;
        var _g1 = line.x1;
        var _g2 = line.x2 + 1;
        while(_g1 < _g2) {
            var x = _g1++;
            var t = target.data[target.width * y + x];
            var c = current.data[current.width * y + x];
            totalRed += ((t >> 24 & 255) - (c >> 24 & 255)) * a + (c >> 24 & 255) * 257;
            totalGreen += ((t >> 16 & 255) - (c >> 16 & 255)) * a + (c >> 16 & 255) * 257;
            totalBlue += ((t >> 8 & 255) - (c >> 8 & 255)) * a + (c >> 8 & 255) * 257;
            ++count;
        }
    }
    if(count == 0) {
        return 0;
    }
    var value = (totalRed / count | 0) >> 8;
    var r = value < 0 ? 0 : value > 255 ? 255 : value;
    var value = (totalGreen / count | 0) >> 8;
    var g = value < 0 ? 0 : value > 255 ? 255 : value;
    var value = (totalBlue / count | 0) >> 8;
    var b = value < 0 ? 0 : value > 255 ? 255 : value;
    return ((r < 0 ? 0 : r > 255 ? 255 : r) << 24) + ((g < 0 ? 0 : g > 255 ? 255 : g) << 16) + ((b < 0 ? 0 : b > 255 ? 255 : b) << 8) + (alpha < 0 ? 0 : alpha > 255 ? 255 : alpha);
};
geometrize_Core.differenceFull = function(first,second) {
    if(first == null) {
        throw haxe_Exception.thrown("FAIL: first != null");
    }
    if(second == null) {
        throw haxe_Exception.thrown("FAIL: second != null");
    }
    if(first.width == 0) {
        throw haxe_Exception.thrown("FAIL: first.width != 0");
    }
    if(first.height == 0) {
        throw haxe_Exception.thrown("FAIL: first.height != 0");
    }
    if(second.width == 0) {
        throw haxe_Exception.thrown("FAIL: second.width != 0");
    }
    if(second.height == 0) {
        throw haxe_Exception.thrown("FAIL: second.height != 0");
    }
    var actual = first.width;
    var expected = second.width;
    if(actual != expected) {
        throw haxe_Exception.thrown("FAIL: values are not equal (expected: " + expected + ", actual: " + actual + ")");
    }
    var actual = first.height;
    var expected = second.height;
    if(actual != expected) {
        throw haxe_Exception.thrown("FAIL: values are not equal (expected: " + expected + ", actual: " + actual + ")");
    }
    var total = 0;
    var width = first.width;
    var height = first.height;
    var _g = 0;
    var _g1 = height;
    while(_g < _g1) {
        var y = _g++;
        var _g2 = 0;
        var _g3 = width;
        while(_g2 < _g3) {
            var x = _g2++;
            var f = first.data[first.width * y + x];
            var s = second.data[second.width * y + x];
            var dr = (f >> 24 & 255) - (s >> 24 & 255);
            var dg = (f >> 16 & 255) - (s >> 16 & 255);
            var db = (f >> 8 & 255) - (s >> 8 & 255);
            var da = (f & 255) - (s & 255);
            total += dr * dr + dg * dg + db * db + da * da;
        }
    }
    var result = Math.sqrt(total / (width * height * 4.0)) / 255;
    if(!isFinite(result)) {
        throw haxe_Exception.thrown("FAIL: Math.isFinite(result)");
    }
    return result;
};
geometrize_Core.differencePartial = function(target,before,after,score,lines) {
    if(target == null) {
        throw haxe_Exception.thrown("FAIL: target != null");
    }
    if(before == null) {
        throw haxe_Exception.thrown("FAIL: before != null");
    }
    if(after == null) {
        throw haxe_Exception.thrown("FAIL: after != null");
    }
    if(lines == null) {
        throw haxe_Exception.thrown("FAIL: lines != null");
    }
    if(lines.length == 0) {
        throw haxe_Exception.thrown("FAIL: lines.length != 0");
    }
    var width = target.width;
    var height = target.height;
    var rgbaCount = width * height * 4;
    var total = Math.pow(score * 255,2) * rgbaCount;
    var _g = 0;
    while(_g < lines.length) {
        var line = lines[_g];
        ++_g;
        var y = line.y;
        var _g1 = line.x1;
        var _g2 = line.x2 + 1;
        while(_g1 < _g2) {
            var x = _g1++;
            var t = target.data[target.width * y + x];
            var b = before.data[before.width * y + x];
            var a = after.data[after.width * y + x];
            var dtbr = (t >> 24 & 255) - (b >> 24 & 255);
            var dtbg = (t >> 16 & 255) - (b >> 16 & 255);
            var dtbb = (t >> 8 & 255) - (b >> 8 & 255);
            var dtba = (t & 255) - (b & 255);
            var dtar = (t >> 24 & 255) - (a >> 24 & 255);
            var dtag = (t >> 16 & 255) - (a >> 16 & 255);
            var dtab = (t >> 8 & 255) - (a >> 8 & 255);
            var dtaa = (t & 255) - (a & 255);
            total -= dtbr * dtbr + dtbg * dtbg + dtbb * dtbb + dtba * dtba;
            total += dtar * dtar + dtag * dtag + dtab * dtab + dtaa * dtaa;
        }
    }
    var result = Math.sqrt(total / rgbaCount) / 255;
    if(!isFinite(result)) {
        throw haxe_Exception.thrown("FAIL: Math.isFinite(result)");
    }
    return result;
};
geometrize_Core.bestRandomState = function(shapes,alpha,n,target,current,buffer,lastScore) {
    var bestEnergy = 0;
    var bestState = null;
    var _g = 0;
    var _g1 = n;
    while(_g < _g1) {
        var i = _g++;
        var state = new geometrize_State(geometrize_shape_ShapeFactory.randomShapeOf(shapes,current.width,current.height),alpha,target,current,buffer);
        var energy = state.energy(lastScore);
        if(i == 0 || energy < bestEnergy) {
            bestEnergy = energy;
            bestState = state;
        }
    }
    return bestState;
};
geometrize_Core.bestHillClimbState = function(shapes,alpha,n,age,target,current,buffer,lastScore) {
    var state = geometrize_Core.bestRandomState(shapes,alpha,n,target,current,buffer,lastScore);
    state = geometrize_Core.hillClimb(state,age,lastScore);
    return state;
};
geometrize_Core.hillClimb = function(state,maxAge,lastScore) {
    if(state == null) {
        throw haxe_Exception.thrown("FAIL: state != null");
    }
    if(maxAge < 0) {
        throw haxe_Exception.thrown("FAIL: maxAge >= 0");
    }
    var state1 = state.clone();
    var bestState = state1.clone();
    var bestEnergy = state1.energy(lastScore);
    var age = 0;
    while(age < maxAge) {
        var undo = state1.mutate();
        var energy = state1.energy(lastScore);
        if(energy >= bestEnergy) {
            state1 = undo;
        } else {
            bestEnergy = energy;
            bestState = state1.clone();
            age = -1;
        }
        ++age;
    }
    return bestState;
};
geometrize_Core.energy = function(shape,alpha,target,current,buffer,score) {
    if(shape == null) {
        throw haxe_Exception.thrown("FAIL: shape != null");
    }
    if(target == null) {
        throw haxe_Exception.thrown("FAIL: target != null");
    }
    if(current == null) {
        throw haxe_Exception.thrown("FAIL: current != null");
    }
    if(buffer == null) {
        throw haxe_Exception.thrown("FAIL: buffer != null");
    }
    var lines = shape.rasterize();
    if(lines == null) {
        throw haxe_Exception.thrown("FAIL: lines != null");
    }
    if(lines.length == 0) {
        throw haxe_Exception.thrown("FAIL: lines.length != 0");
    }
    var color = geometrize_Core.computeColor(target,current,lines,alpha);
    geometrize_rasterizer_Rasterizer.copyLines(buffer,current,lines);
    geometrize_rasterizer_Rasterizer.drawLines(buffer,color,lines);
    return geometrize_Core.differencePartial(target,current,buffer,score,lines);
};
var geometrize_Model = function(target,backgroundColor) {
    if(target == null) {
        throw haxe_Exception.thrown("FAIL: target != null");
    }
    this.width = target.width;
    this.height = target.height;
    this.target = target;
    var w = target.width;
    var h = target.height;
    var bitmap = new geometrize_bitmap_Bitmap();
    bitmap.width = w;
    bitmap.height = h;
    var this1 = new Array(w * h);
    bitmap.data = this1;
    var i = 0;
    while(i < bitmap.data.length) {
        bitmap.data[i] = backgroundColor;
        ++i;
    }
    this.current = bitmap;
    var w = target.width;
    var h = target.height;
    var bitmap = new geometrize_bitmap_Bitmap();
    bitmap.width = w;
    bitmap.height = h;
    var this1 = new Array(w * h);
    bitmap.data = this1;
    var i = 0;
    while(i < bitmap.data.length) {
        bitmap.data[i] = backgroundColor;
        ++i;
    }
    this.buffer = bitmap;
    this.score = geometrize_Core.differenceFull(target,this.current);
};
geometrize_Model.prototype = {
    step: function(shapeTypes,alpha,n,age) {
        var state = geometrize_Core.bestHillClimbState(shapeTypes,alpha,n,age,this.target,this.current,this.buffer,this.score);
        var results = [this.addShape(state.shape,state.alpha)];
        return results;
    }
    ,addShape: function(shape,alpha) {
        if(shape == null) {
            throw haxe_Exception.thrown("FAIL: shape != null");
        }
        var _this = this.current;
        var bitmap = new geometrize_bitmap_Bitmap();
        bitmap.width = _this.width;
        bitmap.height = _this.height;
        var this1 = new Array(_this.data.length);
        bitmap.data = this1;
        var _g = 0;
        var _g1 = _this.data.length;
        while(_g < _g1) {
            var i = _g++;
            bitmap.data[i] = _this.data[i];
        }
        var before = bitmap;
        var lines = shape.rasterize();
        var color = geometrize_Core.computeColor(this.target,this.current,lines,alpha);
        geometrize_rasterizer_Rasterizer.drawLines(this.current,color,lines);
        this.score = geometrize_Core.differencePartial(this.target,before,this.current,this.score,lines);
        var result = { score : this.score, color : color, shape : shape};
        return result;
    }
};
var geometrize_State = function(shape,alpha,target,current,buffer) {
    if(shape == null) {
        throw haxe_Exception.thrown("FAIL: shape != null");
    }
    this.shape = shape;
    this.alpha = alpha;
    this.score = -1;
    this.target = target;
    this.current = current;
    this.buffer = buffer;
};
geometrize_State.prototype = {
    energy: function(lastScore) {
        if(this.score < 0) {
            this.score = geometrize_Core.energy(this.shape,this.alpha,this.target,this.current,this.buffer,lastScore);
        }
        return this.score;
    }
    ,mutate: function() {
        var oldState = this.clone();
        this.shape.mutate();
        return oldState;
    }
    ,clone: function() {
        return new geometrize_State(this.shape.clone(),this.alpha,this.target,this.current,this.buffer);
    }
};
var geometrize_Util = function() { };
geometrize_Util.getAverageImageColor = function(image,alpha) {
    if(alpha == null) {
        alpha = 255;
    }
    if(image == null) {
        throw haxe_Exception.thrown("FAIL: image != null");
    }
    var totalRed = 0;
    var totalGreen = 0;
    var totalBlue = 0;
    var _g = 0;
    var _g1 = image.width;
    while(_g < _g1) {
        var x = _g++;
        var _g2 = 0;
        var _g3 = image.height;
        while(_g2 < _g3) {
            var y = _g2++;
            var pixel = image.data[image.width * y + x];
            totalRed += pixel >> 24 & 255;
            totalGreen += pixel >> 16 & 255;
            totalBlue += pixel >> 8 & 255;
        }
    }
    var size = image.width * image.height;
    var red = totalRed / size | 0;
    var green = totalGreen / size | 0;
    var blue = totalBlue / size | 0;
    return ((red < 0 ? 0 : red > 255 ? 255 : red) << 24) + ((green < 0 ? 0 : green > 255 ? 255 : green) << 16) + ((blue < 0 ? 0 : blue > 255 ? 255 : blue) << 8) + (alpha < 0 ? 0 : alpha > 255 ? 255 : alpha);
};
var geometrize_bitmap_Bitmap = $hx_exports["geometrize"]["bitmap"]["Bitmap"] = function() {
};
geometrize_bitmap_Bitmap.create = function(w,h,color) {
    var bitmap = new geometrize_bitmap_Bitmap();
    bitmap.width = w;
    bitmap.height = h;
    var this1 = new Array(w * h);
    bitmap.data = this1;
    var i = 0;
    while(i < bitmap.data.length) {
        bitmap.data[i] = color;
        ++i;
    }
    return bitmap;
};
geometrize_bitmap_Bitmap.createFromBytes = function(w,h,bytes) {
    var bitmap = new geometrize_bitmap_Bitmap();
    if(bytes == null) {
        throw haxe_Exception.thrown("FAIL: bytes != null");
    }
    var actual = bytes.length;
    var expected = w * h * 4;
    if(actual != expected) {
        throw haxe_Exception.thrown("FAIL: values are not equal (expected: " + expected + ", actual: " + actual + ")");
    }
    bitmap.width = w;
    bitmap.height = h;
    var this1 = new Array(bytes.length / 4 | 0);
    bitmap.data = this1;
    var i = 0;
    var x = 0;
    while(i < bytes.length) {
        var red = bytes.b[i];
        var green = bytes.b[i + 1];
        var blue = bytes.b[i + 2];
        var alpha = bytes.b[i + 3];
        bitmap.data[x] = ((red < 0 ? 0 : red > 255 ? 255 : red) << 24) + ((green < 0 ? 0 : green > 255 ? 255 : green) << 16) + ((blue < 0 ? 0 : blue > 255 ? 255 : blue) << 8) + (alpha < 0 ? 0 : alpha > 255 ? 255 : alpha);
        i += 4;
        ++x;
    }
    return bitmap;
};
geometrize_bitmap_Bitmap.createFromByteArray = function(w,h,bytes) {
    var data = new haxe_io_Bytes(new ArrayBuffer(bytes.length));
    var i = 0;
    while(i < bytes.length) {
        data.b[i] = bytes[i];
        ++i;
    }
    var bitmap = new geometrize_bitmap_Bitmap();
    if(data == null) {
        throw haxe_Exception.thrown("FAIL: bytes != null");
    }
    var actual = data.length;
    var expected = w * h * 4;
    if(actual != expected) {
        throw haxe_Exception.thrown("FAIL: values are not equal (expected: " + expected + ", actual: " + actual + ")");
    }
    bitmap.width = w;
    bitmap.height = h;
    var this1 = new Array(data.length / 4 | 0);
    bitmap.data = this1;
    var i = 0;
    var x = 0;
    while(i < data.length) {
        var red = data.b[i];
        var green = data.b[i + 1];
        var blue = data.b[i + 2];
        var alpha = data.b[i + 3];
        bitmap.data[x] = ((red < 0 ? 0 : red > 255 ? 255 : red) << 24) + ((green < 0 ? 0 : green > 255 ? 255 : green) << 16) + ((blue < 0 ? 0 : blue > 255 ? 255 : blue) << 8) + (alpha < 0 ? 0 : alpha > 255 ? 255 : alpha);
        i += 4;
        ++x;
    }
    return bitmap;
};
geometrize_bitmap_Bitmap.prototype = {
    getPixel: function(x,y) {
        return this.data[this.width * y + x];
    }
    ,setPixel: function(x,y,color) {
        this.data[this.width * y + x] = color;
    }
    ,clone: function() {
        var bitmap = new geometrize_bitmap_Bitmap();
        bitmap.width = this.width;
        bitmap.height = this.height;
        var this1 = new Array(this.data.length);
        bitmap.data = this1;
        var _g = 0;
        var _g1 = this.data.length;
        while(_g < _g1) {
            var i = _g++;
            bitmap.data[i] = this.data[i];
        }
        return bitmap;
    }
    ,fill: function(color) {
        var idx = 0;
        while(idx < this.data.length) {
            this.data[idx] = color >> 24 & 255;
            this.data[idx + 1] = color >> 16 & 255;
            this.data[idx + 2] = color >> 8 & 255;
            this.data[idx + 3] = color & 255;
            idx += 4;
        }
    }
    ,getBytes: function() {
        var bytes = new haxe_io_Bytes(new ArrayBuffer(this.data.length * 4));
        var i = 0;
        while(i < this.data.length) {
            var idx = i * 4;
            bytes.b[idx] = this.data[i] >> 24 & 255;
            bytes.b[idx + 1] = this.data[i] >> 16 & 255;
            bytes.b[idx + 2] = this.data[i] >> 8 & 255;
            bytes.b[idx + 3] = this.data[i] & 255;
            ++i;
        }
        return bytes;
    }
};
var geometrize_exporter_ShapeJsonExporter = $hx_exports["geometrize"]["exporter"]["ShapeJsonExporter"] = function() { };
geometrize_exporter_ShapeJsonExporter.export = function(shapes) {
    return "[\n" + geometrize_exporter_ShapeJsonExporter.exportShapes(shapes) + "\n]";
};
geometrize_exporter_ShapeJsonExporter.exportShapes = function(shapes) {
    var results = "";
    var _g = 0;
    var _g1 = shapes.length;
    while(_g < _g1) {
        var i = _g++;
        results += geometrize_exporter_ShapeJsonExporter.exportShape(shapes[i]);
        if(i != shapes.length - 1) {
            results += ",\n";
        }
    }
    return results;
};
geometrize_exporter_ShapeJsonExporter.exportShape = function(shape) {
    var result = "    {\n";
    var type = shape.shape.getType();
    var data = shape.shape.getRawShapeData();
    var color = shape.color;
    var score = shape.score;
    result += "        \"type\":" + type + ",\n";
    result += "        \"data\":" + "[";
    var _g = 0;
    var _g1 = data.length;
    while(_g < _g1) {
        var item = _g++;
        result += data[item];
        if(item <= data.length - 2) {
            result += ",";
        }
    }
    result += "],\n";
    result += "        \"color\":" + "[";
    result += (color >> 24 & 255) + ",";
    result += (color >> 16 & 255) + ",";
    result += (color >> 8 & 255) + ",";
    result += color & 255;
    result += "],\n";
    result += "        \"score\":" + score + "\n";
    result += "    }";
    return result;
};
var geometrize_exporter_SvgExporter = $hx_exports["geometrize"]["exporter"]["SvgExporter"] = function() { };
geometrize_exporter_SvgExporter.export = function(shapes,width,height) {
    var results = geometrize_exporter_SvgExporter.getSvgPrelude();
    results += geometrize_exporter_SvgExporter.getSvgNodeOpen(width,height);
    results += geometrize_exporter_SvgExporter.exportShapes(shapes);
    results += geometrize_exporter_SvgExporter.getSvgNodeClose();
    return results;
};
geometrize_exporter_SvgExporter.exportShapes = function(shapes) {
    var results = "";
    var _g = 0;
    var _g1 = shapes.length;
    while(_g < _g1) {
        var i = _g++;
        results += geometrize_exporter_SvgExporter.exportShape(shapes[i]);
        if(i != shapes.length - 1) {
            results += "\n";
        }
    }
    return results;
};
geometrize_exporter_SvgExporter.exportShape = function(shape) {
    return StringTools.replace(shape.shape.getSvgShapeData(),geometrize_exporter_SvgExporter.SVG_STYLE_HOOK,geometrize_exporter_SvgExporter.stylesForShape(shape));
};
geometrize_exporter_SvgExporter.getSvgPrelude = function() {
    return "<?xml version=\"1.0\" standalone=\"no\"?>\n";
};
geometrize_exporter_SvgExporter.getSvgNodeOpen = function(width,height) {
    return "<svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.2\" baseProfile=\"tiny\" width=\"" + width + "\" height=\"" + height + "\">\n";
};
geometrize_exporter_SvgExporter.getSvgNodeClose = function() {
    return "</svg>";
};
geometrize_exporter_SvgExporter.stylesForShape = function(shape) {
    switch(shape.shape.getType()) {
    case 6:case 7:
        return geometrize_exporter_SvgExporter.strokeForColor(shape.color) + " stroke-width=\"1\" fill=\"none\" " + geometrize_exporter_SvgExporter.strokeOpacityForAlpha(shape.color & 255);
    default:
        return geometrize_exporter_SvgExporter.fillForColor(shape.color) + " " + geometrize_exporter_SvgExporter.fillOpacityForAlpha(shape.color & 255);
    }
};
geometrize_exporter_SvgExporter.rgbForColor = function(color) {
    return "rgb(" + (color >> 24 & 255) + "," + (color >> 16 & 255) + "," + (color >> 8 & 255) + ")";
};
geometrize_exporter_SvgExporter.strokeForColor = function(color) {
    return "stroke=\"" + geometrize_exporter_SvgExporter.rgbForColor(color) + "\"";
};
geometrize_exporter_SvgExporter.fillForColor = function(color) {
    return "fill=\"" + geometrize_exporter_SvgExporter.rgbForColor(color) + "\"";
};
geometrize_exporter_SvgExporter.fillOpacityForAlpha = function(alpha) {
    return "fill-opacity=\"" + alpha / 255.0 + "\"";
};
geometrize_exporter_SvgExporter.strokeOpacityForAlpha = function(alpha) {
    return "stroke-opacity=\"" + alpha / 255.0 + "\"";
};
var geometrize_rasterizer_Rasterizer = function() { };
geometrize_rasterizer_Rasterizer.drawLines = function(image,c,lines) {
    if(image == null) {
        throw haxe_Exception.thrown("FAIL: image != null");
    }
    if(lines == null) {
        throw haxe_Exception.thrown("FAIL: lines != null");
    }
    var sr = c >> 24 & 255;
    sr |= sr << 8;
    sr *= c & 255;
    sr = sr / 255 | 0;
    var sg = c >> 16 & 255;
    sg |= sg << 8;
    sg *= c & 255;
    sg = sg / 255 | 0;
    var sb = c >> 8 & 255;
    sb |= sb << 8;
    sb *= c & 255;
    sb = sb / 255 | 0;
    var sa = c & 255;
    sa |= sa << 8;
    var _g = 0;
    while(_g < lines.length) {
        var line = lines[_g];
        ++_g;
        var y = line.y;
        var ma = 65535;
        var m = 65535;
        var as = (m - sa * (ma / m)) * 257;
        var a = as | 0;
        var _g1 = line.x1;
        var _g2 = line.x2 + 1;
        while(_g1 < _g2) {
            var x = _g1++;
            var d = image.data[image.width * y + x];
            var dr = d >> 24 & 255;
            var dg = d >> 16 & 255;
            var db = d >> 8 & 255;
            var da = d & 255;
            var r = (UInt.toFloat(dr * a + sr * ma) / UInt.toFloat(m) | 0) >> 8;
            var g = (UInt.toFloat(dg * a + sg * ma) / UInt.toFloat(m) | 0) >> 8;
            var b = (UInt.toFloat(db * a + sb * ma) / UInt.toFloat(m) | 0) >> 8;
            var a1 = (UInt.toFloat(da * a + sa * ma) / UInt.toFloat(m) | 0) >> 8;
            image.data[image.width * y + x] = ((r < 0 ? 0 : r > 255 ? 255 : r) << 24) + ((g < 0 ? 0 : g > 255 ? 255 : g) << 16) + ((b < 0 ? 0 : b > 255 ? 255 : b) << 8) + (a1 < 0 ? 0 : a1 > 255 ? 255 : a1);
        }
    }
};
geometrize_rasterizer_Rasterizer.copyLines = function(destination,source,lines) {
    if(destination == null) {
        throw haxe_Exception.thrown("FAIL: destination != null");
    }
    if(source == null) {
        throw haxe_Exception.thrown("FAIL: source != null");
    }
    if(lines == null) {
        throw haxe_Exception.thrown("FAIL: lines != null");
    }
    var _g = 0;
    while(_g < lines.length) {
        var line = lines[_g];
        ++_g;
        var y = line.y;
        var _g1 = line.x1;
        var _g2 = line.x2 + 1;
        while(_g1 < _g2) {
            var x = _g1++;
            destination.data[destination.width * y + x] = source.data[source.width * y + x];
        }
    }
};
geometrize_rasterizer_Rasterizer.bresenham = function(x1,y1,x2,y2) {
    var dx = x2 - x1;
    var ix = (dx > 0 ? 1 : 0) - (dx < 0 ? 1 : 0);
    dx = (dx < 0 ? -dx : dx) << 1;
    var dy = y2 - y1;
    var iy = (dy > 0 ? 1 : 0) - (dy < 0 ? 1 : 0);
    dy = (dy < 0 ? -dy : dy) << 1;
    var points = [];
    points.push({ x : x1, y : y1});
    if(dx >= dy) {
        var error = dy - (dx >> 1);
        while(x1 != x2) {
            if(error >= 0 && (error != 0 || ix > 0)) {
                error -= dx;
                y1 += iy;
            }
            error += dy;
            x1 += ix;
            points.push({ x : x1, y : y1});
        }
    } else {
        var error = dx - (dy >> 1);
        while(y1 != y2) {
            if(error >= 0 && (error != 0 || iy > 0)) {
                error -= dy;
                x1 += ix;
            }
            error += dx;
            y1 += iy;
            points.push({ x : x1, y : y1});
        }
    }
    return points;
};
geometrize_rasterizer_Rasterizer.scanlinesForPolygon = function(points) {
    var lines = [];
    var edges = [];
    var _g = 0;
    var _g1 = points.length;
    while(_g < _g1) {
        var i = _g++;
        var p1 = points[i];
        var p2 = i == points.length - 1 ? points[0] : points[i + 1];
        var p1p2 = geometrize_rasterizer_Rasterizer.bresenham(p1.x,p1.y,p2.x,p2.y);
        edges = edges.concat(p1p2);
    }
    var yToXs = new haxe_ds_IntMap();
    var _g = 0;
    while(_g < edges.length) {
        var point = edges[_g];
        ++_g;
        var s = yToXs.h[point.y];
        if(s != null) {
            geometrize_ArraySet.add(s,point.x);
        } else {
            s = geometrize_ArraySet.create();
            geometrize_ArraySet.add(s,point.x);
            yToXs.h[point.y] = s;
        }
    }
    var key = yToXs.keys();
    while(key.hasNext()) {
        var key1 = key.next();
        var a = geometrize_ArraySet.toArray(yToXs.h[key1]);
        var minMaxElements;
        if(a == null || a.length == 0) {
            minMaxElements = { x : 0, y : 0};
        } else {
            var min = a[0];
            var max = a[0];
            var _g = 0;
            while(_g < a.length) {
                var value = a[_g];
                ++_g;
                if(min > value) {
                    min = value;
                }
                if(max < value) {
                    max = value;
                }
            }
            minMaxElements = { x : min, y : max};
        }
        lines.push(new geometrize_rasterizer_Scanline(key1,minMaxElements.x,minMaxElements.y));
    }
    return lines;
};
var geometrize_rasterizer_Scanline = function(y,x1,x2) {
    this.y = y;
    this.x1 = x1;
    this.x2 = x2;
};
geometrize_rasterizer_Scanline.trim = function(scanlines,w,h) {
    if(scanlines == null) {
        throw haxe_Exception.thrown("FAIL: scanlines != null");
    }
    var w1 = w;
    var h1 = h;
    var f = function(line) {
        if(line.y < 0 || line.y >= h1 || line.x1 >= w1 || line.x2 < 0) {
            return false;
        } else {
            var value = line.x1;
            var max = w1 - 1;
            if(0 > max) {
                throw haxe_Exception.thrown("FAIL: min <= max");
            }
            line.x1 = value < 0 ? 0 : value > max ? max : value;
            var value = line.x2;
            var max = w1 - 1;
            if(0 > max) {
                throw haxe_Exception.thrown("FAIL: min <= max");
            }
            line.x2 = value < 0 ? 0 : value > max ? max : value;
            return line.x1 <= line.x2;
        }
    };
    var _g = [];
    var _g1 = 0;
    var _g2 = scanlines;
    while(_g1 < _g2.length) {
        var v = _g2[_g1];
        ++_g1;
        if(f(v)) {
            _g.push(v);
        }
    }
    return _g;
};
var geometrize_runner_ImageRunner = $hx_exports["geometrize"]["runner"]["ImageRunner"] = function(inputImage,backgroundColor) {
    this.model = null;
    this.model = new geometrize_Model(inputImage,backgroundColor);
};
geometrize_runner_ImageRunner.prototype = {
    step: function(options) {
        var finalOptions_shapeTypes = options.shapeTypes != null && options.shapeTypes.length != 0 ? options.shapeTypes : geometrize_runner_Default.options.shapeTypes;
        var finalOptions_alpha = options.alpha != null ? options.alpha : geometrize_runner_Default.options.alpha;
        var finalOptions_candidateShapesPerStep = options.candidateShapesPerStep != null ? options.candidateShapesPerStep : geometrize_runner_Default.options.candidateShapesPerStep;
        var finalOptions_shapeMutationsPerStep = options.shapeMutationsPerStep != null ? options.shapeMutationsPerStep : geometrize_runner_Default.options.shapeMutationsPerStep;
        return this.model.step(finalOptions_shapeTypes,finalOptions_alpha,finalOptions_candidateShapesPerStep,finalOptions_shapeMutationsPerStep);
    }
    ,getImageData: function() {
        if(this.model == null) {
            throw haxe_Exception.thrown("FAIL: model != null");
        }
        return this.model.current;
    }
};
var geometrize_runner_Default = function() { };
var geometrize_shape_Ellipse = function(xBound,yBound) {
    this.x = Std.random(xBound);
    this.y = Std.random(yBound);
    this.rx = Std.random(32) + 1;
    this.ry = Std.random(32) + 1;
    this.xBound = xBound;
    this.yBound = yBound;
};
geometrize_shape_Ellipse.prototype = {
    rasterize: function() {
        var lines = [];
        var aspect = this.rx / this.ry;
        var w = this.xBound;
        var h = this.yBound;
        var _g = 0;
        var _g1 = this.ry;
        while(_g < _g1) {
            var dy = _g++;
            var y1 = this.y - dy;
            var y2 = this.y + dy;
            if((y1 < 0 || y1 >= h) && (y2 < 0 || y2 >= h)) {
                continue;
            }
            var s = Math.sqrt(this.ry * this.ry - dy * dy) * aspect | 0;
            var x1 = this.x - s;
            var x2 = this.x + s;
            if(x1 < 0) {
                x1 = 0;
            }
            if(x2 >= w) {
                x2 = w - 1;
            }
            if(y1 >= 0 && y1 < h) {
                lines.push(new geometrize_rasterizer_Scanline(y1,x1,x2));
            }
            if(y2 >= 0 && y2 < h && dy > 0) {
                lines.push(new geometrize_rasterizer_Scanline(y2,x1,x2));
            }
        }
        return lines;
    }
    ,mutate: function() {
        var r = Std.random(3);
        switch(r) {
        case 0:
            var value = this.x + (-16 + Math.floor(33 * Math.random()));
            var max = this.xBound - 1;
            if(0 > max) {
                throw haxe_Exception.thrown("FAIL: min <= max");
            }
            this.x = value < 0 ? 0 : value > max ? max : value;
            var value = this.y + (-16 + Math.floor(33 * Math.random()));
            var max = this.yBound - 1;
            if(0 > max) {
                throw haxe_Exception.thrown("FAIL: min <= max");
            }
            this.y = value < 0 ? 0 : value > max ? max : value;
            break;
        case 1:
            var value = this.rx + (-16 + Math.floor(33 * Math.random()));
            var max = this.xBound - 1;
            if(1 > max) {
                throw haxe_Exception.thrown("FAIL: min <= max");
            }
            this.rx = value < 1 ? 1 : value > max ? max : value;
            break;
        case 2:
            var value = this.ry + (-16 + Math.floor(33 * Math.random()));
            var max = this.xBound - 1;
            if(1 > max) {
                throw haxe_Exception.thrown("FAIL: min <= max");
            }
            this.ry = value < 1 ? 1 : value > max ? max : value;
            break;
        }
    }
    ,clone: function() {
        var ellipse = new geometrize_shape_Ellipse(this.xBound,this.yBound);
        ellipse.x = this.x;
        ellipse.y = this.y;
        ellipse.rx = this.rx;
        ellipse.ry = this.ry;
        return ellipse;
    }
    ,getType: function() {
        return 3;
    }
    ,getRawShapeData: function() {
        return [this.x,this.y,this.rx,this.ry];
    }
    ,getSvgShapeData: function() {
        return "<ellipse cx=\"" + this.x + "\" cy=\"" + this.y + "\" rx=\"" + this.rx + "\" ry=\"" + this.ry + "\" " + geometrize_exporter_SvgExporter.SVG_STYLE_HOOK + " />";
    }
};
var geometrize_shape_Circle = function(xBound,yBound) {
    geometrize_shape_Ellipse.call(this,xBound,yBound);
    this.rx = Std.random(32) + 1;
    this.ry = this.rx;
};
geometrize_shape_Circle.__super__ = geometrize_shape_Ellipse;
geometrize_shape_Circle.prototype = $extend(geometrize_shape_Ellipse.prototype,{
    mutate: function() {
        var r = Std.random(2);
        switch(r) {
        case 0:
            var value = this.x + (-16 + Math.floor(33 * Math.random()));
            var max = this.xBound - 1;
            if(0 > max) {
                throw haxe_Exception.thrown("FAIL: min <= max");
            }
            this.x = value < 0 ? 0 : value > max ? max : value;
            var value = this.y + (-16 + Math.floor(33 * Math.random()));
            var max = this.yBound - 1;
            if(0 > max) {
                throw haxe_Exception.thrown("FAIL: min <= max");
            }
            this.y = value < 0 ? 0 : value > max ? max : value;
            break;
        case 1:
            var value = this.rx + (-16 + Math.floor(33 * Math.random()));
            var max = this.xBound - 1;
            if(1 > max) {
                throw haxe_Exception.thrown("FAIL: min <= max");
            }
            var r = value < 1 ? 1 : value > max ? max : value;
            this.rx = r;
            this.ry = r;
            break;
        }
    }
    ,clone: function() {
        var circle = new geometrize_shape_Circle(this.xBound,this.yBound);
        circle.x = this.x;
        circle.y = this.y;
        circle.rx = this.rx;
        circle.ry = this.ry;
        return circle;
    }
    ,getType: function() {
        return 5;
    }
    ,getRawShapeData: function() {
        return [this.x,this.y,this.rx];
    }
    ,getSvgShapeData: function() {
        return "<circle cx=\"" + this.x + "\" cy=\"" + this.y + "\" r=\"" + this.rx + "\" " + geometrize_exporter_SvgExporter.SVG_STYLE_HOOK + " />";
    }
});
var geometrize_shape_Line = function(xBound,yBound) {
    this.x1 = Std.random(xBound);
    this.y1 = Std.random(yBound);
    var value = this.x1 + Std.random(32) + 1;
    if(0 > xBound) {
        throw haxe_Exception.thrown("FAIL: min <= max");
    }
    this.x2 = value < 0 ? 0 : value > xBound ? xBound : value;
    var value = this.y1 + Std.random(32) + 1;
    if(0 > yBound) {
        throw haxe_Exception.thrown("FAIL: min <= max");
    }
    this.y2 = value < 0 ? 0 : value > yBound ? yBound : value;
    this.xBound = xBound;
    this.yBound = yBound;
};
geometrize_shape_Line.prototype = {
    rasterize: function() {
        var lines = [];
        var points = geometrize_rasterizer_Rasterizer.bresenham(this.x1,this.y1,this.x2,this.y2);
        var _g = 0;
        while(_g < points.length) {
            var point = points[_g];
            ++_g;
            lines.push(new geometrize_rasterizer_Scanline(point.y,point.x,point.x));
        }
        return geometrize_rasterizer_Scanline.trim(lines,this.xBound,this.yBound);
    }
    ,mutate: function() {
        var r = Std.random(4);
        switch(r) {
        case 0:
            var value = this.x1 + (-16 + Math.floor(33 * Math.random()));
            var max = this.xBound - 1;
            if(0 > max) {
                throw haxe_Exception.thrown("FAIL: min <= max");
            }
            this.x1 = value < 0 ? 0 : value > max ? max : value;
            var value = this.y1 + (-16 + Math.floor(33 * Math.random()));
            var max = this.yBound - 1;
            if(0 > max) {
                throw haxe_Exception.thrown("FAIL: min <= max");
            }
            this.y1 = value < 0 ? 0 : value > max ? max : value;
            break;
        case 1:
            var value = this.x2 + (-16 + Math.floor(33 * Math.random()));
            var max = this.xBound - 1;
            if(0 > max) {
                throw haxe_Exception.thrown("FAIL: min <= max");
            }
            this.x2 = value < 0 ? 0 : value > max ? max : value;
            var value = this.y2 + (-16 + Math.floor(33 * Math.random()));
            var max = this.yBound - 1;
            if(0 > max) {
                throw haxe_Exception.thrown("FAIL: min <= max");
            }
            this.y2 = value < 0 ? 0 : value > max ? max : value;
            break;
        }
    }
    ,clone: function() {
        var line = new geometrize_shape_Line(this.xBound,this.yBound);
        line.x1 = this.x1;
        line.y1 = this.y1;
        line.x2 = this.x2;
        line.y2 = this.y2;
        return line;
    }
    ,getType: function() {
        return 6;
    }
    ,getRawShapeData: function() {
        return [this.x1,this.y1,this.x2,this.y2];
    }
    ,getSvgShapeData: function() {
        return "<line x1=\"" + this.x1 + "\" y1=\"" + this.y1 + "\" x2=\"" + this.x2 + "\" y2=\"" + this.y2 + "\" " + geometrize_exporter_SvgExporter.SVG_STYLE_HOOK + " />";
    }
};
var geometrize_shape_QuadraticBezier = function(xBound,yBound) {
    var upper = xBound - 1;
    if(0 > upper) {
        throw haxe_Exception.thrown("FAIL: lower <= upper");
    }
    this.x1 = Math.floor((upper + 1) * Math.random());
    var upper = yBound - 1;
    if(0 > upper) {
        throw haxe_Exception.thrown("FAIL: lower <= upper");
    }
    this.y1 = Math.floor((upper + 1) * Math.random());
    var upper = xBound - 1;
    if(0 > upper) {
        throw haxe_Exception.thrown("FAIL: lower <= upper");
    }
    this.cx = Math.floor((upper + 1) * Math.random());
    var upper = yBound - 1;
    if(0 > upper) {
        throw haxe_Exception.thrown("FAIL: lower <= upper");
    }
    this.cy = Math.floor((upper + 1) * Math.random());
    var upper = xBound - 1;
    if(0 > upper) {
        throw haxe_Exception.thrown("FAIL: lower <= upper");
    }
    this.x2 = Math.floor((upper + 1) * Math.random());
    var upper = yBound - 1;
    if(0 > upper) {
        throw haxe_Exception.thrown("FAIL: lower <= upper");
    }
    this.y2 = Math.floor((upper + 1) * Math.random());
    this.xBound = xBound;
    this.yBound = yBound;
};
geometrize_shape_QuadraticBezier.prototype = {
    rasterize: function() {
        var lines = [];
        var points = [];
        var pointCount = 20;
        var _g = 0;
        var _g1 = pointCount - 1;
        while(_g < _g1) {
            var i = _g++;
            var t = i / pointCount;
            var tp = 1 - t;
            var x = tp * (tp * this.x1 + t * this.cx) + t * (tp * this.cx + t * this.x2) | 0;
            var y = tp * (tp * this.y1 + t * this.cy) + t * (tp * this.cy + t * this.y2) | 0;
            points.push({ x : x, y : y});
        }
        var _g = 0;
        var _g1 = points.length - 1;
        while(_g < _g1) {
            var i = _g++;
            var p0 = points[i];
            var p1 = points[i + 1];
            var pts = geometrize_rasterizer_Rasterizer.bresenham(p0.x,p0.y,p1.x,p1.y);
            var _g2 = 0;
            while(_g2 < pts.length) {
                var point = pts[_g2];
                ++_g2;
                if(lines.length > 0) {
                    var lastLine = lines[lines.length - 1];
                    if(lastLine.y == point.y && lastLine.x1 == point.x && lastLine.x2 == point.x) {
                        continue;
                    }
                }
                lines.push(new geometrize_rasterizer_Scanline(point.y,point.x,point.x));
            }
        }
        return geometrize_rasterizer_Scanline.trim(lines,this.xBound,this.yBound);
    }
    ,mutate: function() {
        var r = Math.floor(3 * Math.random());
        switch(r) {
        case 0:
            var value = this.cx + (-8 + Math.floor(17 * Math.random()));
            var max = this.xBound - 1;
            if(0 > max) {
                throw haxe_Exception.thrown("FAIL: min <= max");
            }
            this.cx = value < 0 ? 0 : value > max ? max : value;
            var value = this.cy + (-8 + Math.floor(17 * Math.random()));
            var max = this.yBound - 1;
            if(0 > max) {
                throw haxe_Exception.thrown("FAIL: min <= max");
            }
            this.cy = value < 0 ? 0 : value > max ? max : value;
            break;
        case 1:
            var value = this.x1 + (-8 + Math.floor(17 * Math.random()));
            var max = this.xBound - 1;
            if(1 > max) {
                throw haxe_Exception.thrown("FAIL: min <= max");
            }
            this.x1 = value < 1 ? 1 : value > max ? max : value;
            var value = this.y1 + (-8 + Math.floor(17 * Math.random()));
            var max = this.yBound - 1;
            if(1 > max) {
                throw haxe_Exception.thrown("FAIL: min <= max");
            }
            this.y1 = value < 1 ? 1 : value > max ? max : value;
            break;
        case 2:
            var value = this.x2 + (-8 + Math.floor(17 * Math.random()));
            var max = this.xBound - 1;
            if(1 > max) {
                throw haxe_Exception.thrown("FAIL: min <= max");
            }
            this.x2 = value < 1 ? 1 : value > max ? max : value;
            var value = this.y2 + (-8 + Math.floor(17 * Math.random()));
            var max = this.yBound - 1;
            if(1 > max) {
                throw haxe_Exception.thrown("FAIL: min <= max");
            }
            this.y2 = value < 1 ? 1 : value > max ? max : value;
            break;
        }
    }
    ,clone: function() {
        var bezier = new geometrize_shape_QuadraticBezier(this.xBound,this.yBound);
        bezier.cx = this.cx;
        bezier.cy = this.cy;
        bezier.x1 = this.x1;
        bezier.y1 = this.y1;
        bezier.x2 = this.x2;
        bezier.y2 = this.y2;
        return bezier;
    }
    ,getType: function() {
        return 7;
    }
    ,getRawShapeData: function() {
        return [this.x1,this.y1,this.cx,this.cy,this.x2,this.y2];
    }
    ,getSvgShapeData: function() {
        return "<path d=\"M" + this.x1 + " " + this.y1 + " Q " + this.cx + " " + this.cy + " " + this.x2 + " " + this.y2 + "\" " + geometrize_exporter_SvgExporter.SVG_STYLE_HOOK + " />";
    }
};
var geometrize_shape_Rectangle = function(xBound,yBound) {
    this.x1 = Std.random(xBound);
    this.y1 = Std.random(yBound);
    var value = this.x1 + Std.random(32) + 1;
    var max = xBound - 1;
    if(0 > max) {
        throw haxe_Exception.thrown("FAIL: min <= max");
    }
    this.x2 = value < 0 ? 0 : value > max ? max : value;
    var value = this.y1 + Std.random(32) + 1;
    var max = yBound - 1;
    if(0 > max) {
        throw haxe_Exception.thrown("FAIL: min <= max");
    }
    this.y2 = value < 0 ? 0 : value > max ? max : value;
    this.xBound = xBound;
    this.yBound = yBound;
};
geometrize_shape_Rectangle.prototype = {
    rasterize: function() {
        var lines = [];
        var first = this.y1;
        var second = this.y2;
        var yMin = first < second ? first : second;
        var first = this.y1;
        var second = this.y2;
        var yMax = first > second ? first : second;
        if(yMin == yMax) {
            var first = this.x1;
            var second = this.x2;
            var first1 = this.x1;
            var second1 = this.x2;
            lines.push(new geometrize_rasterizer_Scanline(yMin,first < second ? first : second,first1 > second1 ? first1 : second1));
        } else {
            var _g = yMin;
            var _g1 = yMax;
            while(_g < _g1) {
                var y = _g++;
                var first = this.x1;
                var second = this.x2;
                var first1 = this.x1;
                var second1 = this.x2;
                lines.push(new geometrize_rasterizer_Scanline(y,first < second ? first : second,first1 > second1 ? first1 : second1));
            }
        }
        return lines;
    }
    ,mutate: function() {
        var r = Std.random(2);
        switch(r) {
        case 0:
            var value = this.x1 + (-16 + Math.floor(33 * Math.random()));
            var max = this.xBound - 1;
            if(0 > max) {
                throw haxe_Exception.thrown("FAIL: min <= max");
            }
            this.x1 = value < 0 ? 0 : value > max ? max : value;
            var value = this.y1 + (-16 + Math.floor(33 * Math.random()));
            var max = this.yBound - 1;
            if(0 > max) {
                throw haxe_Exception.thrown("FAIL: min <= max");
            }
            this.y1 = value < 0 ? 0 : value > max ? max : value;
            break;
        case 1:
            var value = this.x2 + (-16 + Math.floor(33 * Math.random()));
            var max = this.xBound - 1;
            if(0 > max) {
                throw haxe_Exception.thrown("FAIL: min <= max");
            }
            this.x2 = value < 0 ? 0 : value > max ? max : value;
            var value = this.y2 + (-16 + Math.floor(33 * Math.random()));
            var max = this.yBound - 1;
            if(0 > max) {
                throw haxe_Exception.thrown("FAIL: min <= max");
            }
            this.y2 = value < 0 ? 0 : value > max ? max : value;
            break;
        }
    }
    ,clone: function() {
        var rectangle = new geometrize_shape_Rectangle(this.xBound,this.yBound);
        rectangle.x1 = this.x1;
        rectangle.y1 = this.y1;
        rectangle.x2 = this.x2;
        rectangle.y2 = this.y2;
        return rectangle;
    }
    ,getType: function() {
        return 0;
    }
    ,getRawShapeData: function() {
        var first = this.x1;
        var second = this.x2;
        var first1 = this.y1;
        var second1 = this.y2;
        var first2 = this.x1;
        var second2 = this.x2;
        var first3 = this.y1;
        var second3 = this.y2;
        return [first < second ? first : second,first1 < second1 ? first1 : second1,first2 > second2 ? first2 : second2,first3 > second3 ? first3 : second3];
    }
    ,getSvgShapeData: function() {
        var first = this.x1;
        var second = this.x2;
        var first1 = this.y1;
        var second1 = this.y2;
        var first2 = this.x1;
        var second2 = this.x2;
        var first3 = this.x1;
        var second3 = this.x2;
        var first4 = this.y1;
        var second4 = this.y2;
        var first5 = this.y1;
        var second5 = this.y2;
        return "<rect x=\"" + (first < second ? first : second) + "\" y=\"" + (first1 < second1 ? first1 : second1) + "\" width=\"" + ((first2 > second2 ? first2 : second2) - (first3 < second3 ? first3 : second3)) + "\" height=\"" + ((first4 > second4 ? first4 : second4) - (first5 < second5 ? first5 : second5)) + "\" " + geometrize_exporter_SvgExporter.SVG_STYLE_HOOK + " />";
    }
};
var geometrize_shape_RotatedEllipse = function(xBound,yBound) {
    this.x = Std.random(xBound);
    this.y = Std.random(yBound);
    this.rx = Std.random(32) + 1;
    this.ry = Std.random(32) + 1;
    this.angle = Std.random(360);
    this.xBound = xBound;
    this.yBound = yBound;
};
geometrize_shape_RotatedEllipse.prototype = {
    rasterize: function() {
        var pointCount = 20;
        var points = [];
        var rads = this.angle * (Math.PI / 180.0);
        var c = Math.cos(rads);
        var s = Math.sin(rads);
        var _g = 0;
        var _g1 = pointCount;
        while(_g < _g1) {
            var i = _g++;
            var rot = 360.0 / pointCount * i * (Math.PI / 180.0);
            var crx = this.rx * Math.cos(rot);
            var cry = this.ry * Math.sin(rot);
            var tx = crx * c - cry * s + this.x | 0;
            var ty = crx * s + cry * c + this.y | 0;
            points.push({ x : tx, y : ty});
        }
        return geometrize_rasterizer_Scanline.trim(geometrize_rasterizer_Rasterizer.scanlinesForPolygon(points),this.xBound,this.yBound);
    }
    ,mutate: function() {
        var r = Std.random(4);
        switch(r) {
        case 0:
            var value = this.x + (-16 + Math.floor(33 * Math.random()));
            var max = this.xBound - 1;
            if(0 > max) {
                throw haxe_Exception.thrown("FAIL: min <= max");
            }
            this.x = value < 0 ? 0 : value > max ? max : value;
            var value = this.y + (-16 + Math.floor(33 * Math.random()));
            var max = this.yBound - 1;
            if(0 > max) {
                throw haxe_Exception.thrown("FAIL: min <= max");
            }
            this.y = value < 0 ? 0 : value > max ? max : value;
            break;
        case 1:
            var value = this.rx + (-16 + Math.floor(33 * Math.random()));
            var max = this.xBound - 1;
            if(1 > max) {
                throw haxe_Exception.thrown("FAIL: min <= max");
            }
            this.rx = value < 1 ? 1 : value > max ? max : value;
            break;
        case 2:
            var value = this.ry + (-16 + Math.floor(33 * Math.random()));
            var max = this.yBound - 1;
            if(1 > max) {
                throw haxe_Exception.thrown("FAIL: min <= max");
            }
            this.ry = value < 1 ? 1 : value > max ? max : value;
            break;
        case 3:
            var value = this.angle + (-4 + Math.floor(9 * Math.random()));
            this.angle = value < 0 ? 0 : value > 360 ? 360 : value;
            break;
        }
    }
    ,clone: function() {
        var ellipse = new geometrize_shape_RotatedEllipse(this.xBound,this.yBound);
        ellipse.x = this.x;
        ellipse.y = this.y;
        ellipse.rx = this.rx;
        ellipse.ry = this.ry;
        ellipse.angle = this.angle;
        return ellipse;
    }
    ,getType: function() {
        return 4;
    }
    ,getRawShapeData: function() {
        return [this.x,this.y,this.rx,this.ry,this.angle];
    }
    ,getSvgShapeData: function() {
        var s = "<g transform=\"translate(" + this.x + " " + this.y + ") rotate(" + this.angle + ") scale(" + this.rx + " " + this.ry + ")\">";
        s += "<ellipse cx=\"" + 0 + "\" cy=\"" + 0 + "\" rx=\"" + 1 + "\" ry=\"" + 1 + "\" " + geometrize_exporter_SvgExporter.SVG_STYLE_HOOK + " />";
        s += "</g>";
        return s;
    }
};
var geometrize_shape_RotatedRectangle = function(xBound,yBound) {
    this.x1 = Std.random(xBound);
    this.y1 = Std.random(yBound);
    var value = this.x1 + Std.random(32) + 1;
    if(0 > xBound) {
        throw haxe_Exception.thrown("FAIL: min <= max");
    }
    this.x2 = value < 0 ? 0 : value > xBound ? xBound : value;
    var value = this.y1 + Std.random(32) + 1;
    if(0 > yBound) {
        throw haxe_Exception.thrown("FAIL: min <= max");
    }
    this.y2 = value < 0 ? 0 : value > yBound ? yBound : value;
    this.angle = Math.floor(361 * Math.random());
    this.xBound = xBound;
    this.yBound = yBound;
};
geometrize_shape_RotatedRectangle.prototype = {
    rasterize: function() {
        var first = this.x1;
        var second = this.x2;
        var xm1 = first < second ? first : second;
        var first = this.x1;
        var second = this.x2;
        var xm2 = first > second ? first : second;
        var first = this.y1;
        var second = this.y2;
        var ym1 = first < second ? first : second;
        var first = this.y1;
        var second = this.y2;
        var ym2 = first > second ? first : second;
        var cx = (xm1 + xm2) / 2 | 0;
        var cy = (ym1 + ym2) / 2 | 0;
        var ox1 = xm1 - cx;
        var ox2 = xm2 - cx;
        var oy1 = ym1 - cy;
        var oy2 = ym2 - cy;
        var rads = this.angle * Math.PI / 180.0;
        var c = Math.cos(rads);
        var s = Math.sin(rads);
        var ulx = ox1 * c - oy1 * s + cx | 0;
        var uly = ox1 * s + oy1 * c + cy | 0;
        var blx = ox1 * c - oy2 * s + cx | 0;
        var bly = ox1 * s + oy2 * c + cy | 0;
        var urx = ox2 * c - oy1 * s + cx | 0;
        var ury = ox2 * s + oy1 * c + cy | 0;
        var brx = ox2 * c - oy2 * s + cx | 0;
        var bry = ox2 * s + oy2 * c + cy | 0;
        return geometrize_rasterizer_Scanline.trim(geometrize_rasterizer_Rasterizer.scanlinesForPolygon([{ x : ulx, y : uly},{ x : urx, y : ury},{ x : brx, y : bry},{ x : blx, y : bly}]),this.xBound,this.yBound);
    }
    ,mutate: function() {
        var r = Std.random(3);
        switch(r) {
        case 0:
            var value = this.x1 + (-16 + Math.floor(33 * Math.random()));
            var max = this.xBound - 1;
            if(0 > max) {
                throw haxe_Exception.thrown("FAIL: min <= max");
            }
            this.x1 = value < 0 ? 0 : value > max ? max : value;
            var value = this.y1 + (-16 + Math.floor(33 * Math.random()));
            var max = this.yBound - 1;
            if(0 > max) {
                throw haxe_Exception.thrown("FAIL: min <= max");
            }
            this.y1 = value < 0 ? 0 : value > max ? max : value;
            break;
        case 1:
            var value = this.x2 + (-16 + Math.floor(33 * Math.random()));
            var max = this.xBound - 1;
            if(0 > max) {
                throw haxe_Exception.thrown("FAIL: min <= max");
            }
            this.x2 = value < 0 ? 0 : value > max ? max : value;
            var value = this.y2 + (-16 + Math.floor(33 * Math.random()));
            var max = this.yBound - 1;
            if(0 > max) {
                throw haxe_Exception.thrown("FAIL: min <= max");
            }
            this.y2 = value < 0 ? 0 : value > max ? max : value;
            break;
        case 2:
            var value = this.angle + (-4 + Math.floor(9 * Math.random()));
            this.angle = value < 0 ? 0 : value > 360 ? 360 : value;
            break;
        }
    }
    ,clone: function() {
        var rectangle = new geometrize_shape_RotatedRectangle(this.xBound,this.yBound);
        rectangle.x1 = this.x1;
        rectangle.y1 = this.y1;
        rectangle.x2 = this.x2;
        rectangle.y2 = this.y2;
        rectangle.angle = this.angle;
        return rectangle;
    }
    ,getType: function() {
        return 1;
    }
    ,getRawShapeData: function() {
        var first = this.x1;
        var second = this.x2;
        var first1 = this.y1;
        var second1 = this.y2;
        var first2 = this.x1;
        var second2 = this.x2;
        var first3 = this.y1;
        var second3 = this.y2;
        return [first < second ? first : second,first1 < second1 ? first1 : second1,first2 > second2 ? first2 : second2,first3 > second3 ? first3 : second3,this.angle];
    }
    ,getSvgShapeData: function() {
        var first = this.x1;
        var second = this.x2;
        var xm1 = first < second ? first : second;
        var first = this.x1;
        var second = this.x2;
        var xm2 = first > second ? first : second;
        var first = this.y1;
        var second = this.y2;
        var ym1 = first < second ? first : second;
        var first = this.y1;
        var second = this.y2;
        var ym2 = first > second ? first : second;
        var cx = (xm1 + xm2) / 2 | 0;
        var cy = (ym1 + ym2) / 2 | 0;
        var ox1 = xm1 - cx;
        var ox2 = xm2 - cx;
        var oy1 = ym1 - cy;
        var oy2 = ym2 - cy;
        var rads = this.angle * Math.PI / 180.0;
        var c = Math.cos(rads);
        var s = Math.sin(rads);
        var ulx = ox1 * c - oy1 * s + cx | 0;
        var uly = ox1 * s + oy1 * c + cy | 0;
        var blx = ox1 * c - oy2 * s + cx | 0;
        var bly = ox1 * s + oy2 * c + cy | 0;
        var urx = ox2 * c - oy1 * s + cx | 0;
        var ury = ox2 * s + oy1 * c + cy | 0;
        var brx = ox2 * c - oy2 * s + cx | 0;
        var bry = ox2 * s + oy2 * c + cy | 0;
        var points = [{ x : ulx, y : uly},{ x : urx, y : ury},{ x : brx, y : bry},{ x : blx, y : bly}];
        var s = "<polygon points=\"";
        var _g = 0;
        var _g1 = points.length;
        while(_g < _g1) {
            var i = _g++;
            s += points[i].x + " " + points[i].y;
            if(i != points.length - 1) {
                s += " ";
            }
        }
        s += "\" " + geometrize_exporter_SvgExporter.SVG_STYLE_HOOK + "/>";
        return s;
    }
};
var geometrize_shape_ShapeFactory = function() { };
geometrize_shape_ShapeFactory.create = function(type,xBound,yBound) {
    switch(type) {
    case 0:
        return new geometrize_shape_Rectangle(xBound,yBound);
    case 1:
        return new geometrize_shape_RotatedRectangle(xBound,yBound);
    case 2:
        return new geometrize_shape_Triangle(xBound,yBound);
    case 3:
        return new geometrize_shape_Ellipse(xBound,yBound);
    case 4:
        return new geometrize_shape_RotatedEllipse(xBound,yBound);
    case 5:
        return new geometrize_shape_Circle(xBound,yBound);
    case 6:
        return new geometrize_shape_Line(xBound,yBound);
    case 7:
        return new geometrize_shape_QuadraticBezier(xBound,yBound);
    }
};
geometrize_shape_ShapeFactory.randomShapeOf = function(types,xBound,yBound) {
    if(!(types != null && types.length > 0)) {
        throw haxe_Exception.thrown("FAIL: a != null && a.length > 0");
    }
    var upper = types.length - 1;
    if(0 > upper) {
        throw haxe_Exception.thrown("FAIL: lower <= upper");
    }
    return geometrize_shape_ShapeFactory.create(types[Math.floor((upper + 1) * Math.random())],xBound,yBound);
};
var geometrize_shape_ShapeTypes = $hx_exports["geometrize"]["shape"]["ShapeTypes"] = function() { };
var geometrize_shape_Triangle = function(xBound,yBound) {
    this.x1 = Std.random(xBound);
    this.y1 = Std.random(yBound);
    this.x2 = this.x1 + (-16 + Math.floor(33 * Math.random()));
    this.y2 = this.y1 + (-16 + Math.floor(33 * Math.random()));
    this.x3 = this.x1 + (-16 + Math.floor(33 * Math.random()));
    this.y3 = this.y1 + (-16 + Math.floor(33 * Math.random()));
    this.xBound = xBound;
    this.yBound = yBound;
};
geometrize_shape_Triangle.prototype = {
    rasterize: function() {
        return geometrize_rasterizer_Scanline.trim(geometrize_rasterizer_Rasterizer.scanlinesForPolygon([{ x : this.x1, y : this.y1},{ x : this.x2, y : this.y2},{ x : this.x3, y : this.y3}]),this.xBound,this.yBound);
    }
    ,mutate: function() {
        var r = Std.random(3);
        switch(r) {
        case 0:
            var value = this.x1 + (-16 + Math.floor(33 * Math.random()));
            var max = this.xBound - 1;
            if(0 > max) {
                throw haxe_Exception.thrown("FAIL: min <= max");
            }
            this.x1 = value < 0 ? 0 : value > max ? max : value;
            var value = this.y1 + (-16 + Math.floor(33 * Math.random()));
            var max = this.yBound - 1;
            if(0 > max) {
                throw haxe_Exception.thrown("FAIL: min <= max");
            }
            this.y1 = value < 0 ? 0 : value > max ? max : value;
            break;
        case 1:
            var value = this.x2 + (-16 + Math.floor(33 * Math.random()));
            var max = this.xBound - 1;
            if(0 > max) {
                throw haxe_Exception.thrown("FAIL: min <= max");
            }
            this.x2 = value < 0 ? 0 : value > max ? max : value;
            var value = this.y2 + (-16 + Math.floor(33 * Math.random()));
            var max = this.yBound - 1;
            if(0 > max) {
                throw haxe_Exception.thrown("FAIL: min <= max");
            }
            this.y2 = value < 0 ? 0 : value > max ? max : value;
            break;
        case 2:
            var value = this.x3 + (-16 + Math.floor(33 * Math.random()));
            var max = this.xBound - 1;
            if(0 > max) {
                throw haxe_Exception.thrown("FAIL: min <= max");
            }
            this.x3 = value < 0 ? 0 : value > max ? max : value;
            var value = this.y3 + (-16 + Math.floor(33 * Math.random()));
            var max = this.yBound - 1;
            if(0 > max) {
                throw haxe_Exception.thrown("FAIL: min <= max");
            }
            this.y3 = value < 0 ? 0 : value > max ? max : value;
            break;
        }
    }
    ,clone: function() {
        var triangle = new geometrize_shape_Triangle(this.xBound,this.yBound);
        triangle.x1 = this.x1;
        triangle.y1 = this.y1;
        triangle.x2 = this.x2;
        triangle.y2 = this.y2;
        triangle.x3 = this.x3;
        triangle.y3 = this.y3;
        return triangle;
    }
    ,getType: function() {
        return 2;
    }
    ,getRawShapeData: function() {
        return [this.x1,this.y1,this.x2,this.y2,this.x3,this.y3];
    }
    ,getSvgShapeData: function() {
        return "<polygon points=\"" + this.x1 + "," + this.y1 + " " + this.x2 + "," + this.y2 + " " + this.x3 + "," + this.y3 + "\" " + geometrize_exporter_SvgExporter.SVG_STYLE_HOOK + "/>";
    }
};
var haxe_Exception = function(message,previous,native) {
    Error.call(this,message);
    this.message = message;
    this.__previousException = previous;
    this.__nativeException = native != null ? native : this;
};
haxe_Exception.thrown = function(value) {
    if(((value) instanceof haxe_Exception)) {
        return value.get_native();
    } else if(((value) instanceof Error)) {
        return value;
    } else {
        var e = new haxe_ValueException(value);
        return e;
    }
};
haxe_Exception.__super__ = Error;
haxe_Exception.prototype = $extend(Error.prototype,{
    get_native: function() {
        return this.__nativeException;
    }
});
var haxe_ValueException = function(value,previous,native) {
    haxe_Exception.call(this,String(value),previous,native);
    this.value = value;
};
haxe_ValueException.__super__ = haxe_Exception;
haxe_ValueException.prototype = $extend(haxe_Exception.prototype,{
});
var haxe_ds_IntMap = function() {
    this.h = { };
};
haxe_ds_IntMap.prototype = {
    keys: function() {
        var a = [];
        for( var key in this.h ) if(this.h.hasOwnProperty(key)) a.push(+key);
        return new haxe_iterators_ArrayIterator(a);
    }
};
var haxe_io_Bytes = function(data) {
    this.length = data.byteLength;
    this.b = new Uint8Array(data);
    this.b.bufferValue = data;
    data.hxBytes = this;
    data.bytes = this.b;
};
var haxe_iterators_ArrayIterator = function(array) {
    this.current = 0;
    this.array = array;
};
haxe_iterators_ArrayIterator.prototype = {
    hasNext: function() {
        return this.current < this.array.length;
    }
    ,next: function() {
        return this.array[this.current++];
    }
};
onmessage = GeometrizeWorker.prototype.messageHandler;
geometrize_exporter_SvgExporter.SVG_STYLE_HOOK = "::svg_style_hook::";
geometrize_runner_Default.options = { shapeTypes : [2], candidateShapesPerStep : 50, shapeMutationsPerStep : 100, alpha : 128};
geometrize_shape_ShapeTypes.RECTANGLE = 0;
geometrize_shape_ShapeTypes.ROTATED_RECTANGLE = 1;
geometrize_shape_ShapeTypes.TRIANGLE = 2;
geometrize_shape_ShapeTypes.ELLIPSE = 3;
geometrize_shape_ShapeTypes.ROTATED_ELLIPSE = 4;
geometrize_shape_ShapeTypes.CIRCLE = 5;
geometrize_shape_ShapeTypes.LINE = 6;
geometrize_shape_ShapeTypes.QUADRATIC_BEZIER = 7;
})(typeof exports != "undefined" ? exports : typeof window != "undefined" ? window : typeof self != "undefined" ? self : this, {});

</script>

</body>
</html>